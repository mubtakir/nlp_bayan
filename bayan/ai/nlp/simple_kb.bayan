# ============================================
# قاعدة معرفة بسيطة - Simple Knowledge Base (with frequencies)
# ============================================

# قاعدة المعرفة: مفتاح (subject_predicate) -> قاموس قيم مع التكرارات {value: count}
knowledge_base = {}

# دالة: إضافة حقيقة (تراكمية)
# تزيد عدد مرات ظهور القيمة لنفس (الموضوع، العلاقة)
def add_fact(subject, predicate, value): {
}
{
    key = subject + "_" + predicate
    # استبدال 'not in' بـ 'not (.. in ..)' لتوافق النحو
    if (not (key in knowledge_base)) {
        knowledge_base[key] = {}
    }
    counts = knowledge_base[key]
    if (value in counts) {
        counts[value] = counts[value] + 1
    }
    else {
    
        counts[value] = 1
    }
    return True
}

# دالة: أفضل قيمة مع أعلى احتمال
# تعيد قاموساً يحوي: value, count, total, prob
# prob = count / total

def find_best_with_prob(subject, predicate): {
}
{
    key = subject + "_" + predicate
    # استبدال 'not in' بـ 'not (.. in ..)'
    if (not (key in knowledge_base)) {
        return { "found": False }
    }
    counts = knowledge_base[key]
    # البحث عن أعلى تكرار
    best_value = ""
    best_count = -1
    total = 0
    for v in (counts) {
        c = counts[v]
        total = total + c
        if (c > best_count) {
            best_count = c
            best_value = v
        }
    }
    # حساب الاحتمال (كنسبة مبسطة)
    prob = 0
    if (total > 0) {
        prob = best_count / total
    }
    percent = prob * 100
    # إرجاع قاموس جاهز بدلاً من التعيين بالعُنونة
    return { "found": True, "value": best_value, "count": best_count, "total": total, "prob": prob, "percent": percent }
}

# دالة: البحث عن حقيقة (ترجع أفضل قيمة فقط)
def find_fact(subject, predicate): {
}
{
    res = find_best_with_prob(subject, predicate)
    if (res["found"]) {
        return res["value"]
    }
    return None
}

# دالة: توزيع القيم لكل (موضوع، علاقة)
def find_distribution(subject, predicate): {
}
{
    key = subject + "_" + predicate
    if (key in knowledge_base) {
        return knowledge_base[key]
    }
    return {}
}

# دالة: البحث بالموضوع (ترجع قائمة بأفضل القيم لكل علاقة)
def find_by_subject(subject): {
}
{
    results = []
    prefix = subject + "_"
    for key in (knowledge_base) {
        if (key.startswith(prefix)) {
            # استخرج أفضل قيمة لهذا المفتاح
            # المفتاح بصيغة subject_predicate -> افصل العلاقة لأغراض العرض
            parts = key.split("_")
            pred = parts[len(parts)-1]
            val = find_fact(subject, pred)
            results.append(val)
        }
    }
    return results
}
# دالة: أفضل N قيم مع النسب المئوية
# تعيد قائمة من قواميس: [{value, count, prob, percent}]

def find_top_n(subject, predicate, n): {
}
{
    key = subject + "_" + predicate
    if (not (key in knowledge_base)) {
        return []
    }
    counts = knowledge_base[key]
    total = 0
    for v in (counts) {
        total = total + counts[v]
    }
    used = []
    top = []
    i = 0
    while (i < n) {
        best_v = ""
        best_c = -1
        for v in (counts) {
            if (not (v in used)) {
                c = counts[v]
                if (c > best_c) {
                    best_c = c
                    best_v = v
                }
            }
        }
        if (best_c == -1) {
            break
        }
        prob = 0
        if (total > 0) {
            prob = best_c / total
        }
        percent = prob * 100
        entry = { "value": best_v, "count": best_c, "prob": prob, "percent": percent }
        top.append(entry)
        used.append(best_v)
        i = i + 1
    }
    return top
}


# دالة: عدد الحقائق (عدد المفاتيح الفريدة)
def count_facts(): {
}
{
    return len(knowledge_base)
}

# دالة: عرض كل المعرفة
def show_all(): {
}
{
    return knowledge_base
}



# =============================
# توسيع: سياق/زمن بسيط + كشف تعارضات
# =============================

# حالة السياق الحالية (تغيير داخل القاموس لتفادي إعادة الربط)
context_state = { "current": "" }

def set_context(ctx): {
}
{
    context_state["current"] = ctx
    return True
}

def clear_context(): {
}
{
    context_state["current"] = ""
    return True
}

# إضافة حقيقة ضمن سياق معيّن
# التخزين بمفتاح: subject_predicate_@_context

def add_fact_in_ctx(subject, predicate, value, ctx): {
}
{
    key = subject + "_" + predicate + "_@_" + ctx
    if (not (key in knowledge_base)) {
        knowledge_base[key] = {}
    }
    counts = knowledge_base[key]
    if (value in counts) {
        counts[value] = counts[value] + 1
    }
    else {
    
        counts[value] = 1
    }
    return True
}

# توزيع ضمن سياق

def find_distribution_in_ctx(subject, predicate, ctx): {
}
{
    key = subject + "_" + predicate + "_@_" + ctx
    if (key in knowledge_base) {
        return knowledge_base[key]
    }
    return {}
}

# أفضل قيمة ضمن سياق

def find_best_with_prob_in_ctx(subject, predicate, ctx): {
}
{
    key = subject + "_" + predicate + "_@_" + ctx
    if (not (key in knowledge_base)) {
        return { "found": False }
    }
    counts = knowledge_base[key]
    best_value = ""
    best_count = -1
    total = 0
    for v in (counts) {
        c = counts[v]
        total = total + c
        if (c > best_count) {
            best_count = c
            best_value = v
        }
    }
    prob = 0
    if (total > 0) {
        prob = best_count / total
    }
    percent = prob * 100
    return { "found": True, "value": best_value, "count": best_count, "total": total, "prob": prob, "percent": percent }
}

# كشف التعارضات على (subject, predicate)

def find_contradictions(subject, predicate): {
}
{
    dist = find_distribution(subject, predicate)
    unique = 0
    for v in (dist) {
        unique = unique + 1
    }
    if (unique > 1) {
        return { "conflict": True, "distribution": dist, "unique": unique }
    }
    return { "conflict": False, "distribution": dist, "unique": unique }
}


# =============================
# توسع: بُعد الزمن البسيط (تسمية زمنية)
# =============================

# إضافة حقيقة عند تسمية زمنية
# المفتاح: subject_predicate_#_tlabel

def add_fact_at_t(subject, predicate, value, tlabel): {
}
{
    key = subject + "_" + predicate + "_#_" + tlabel
    if (not (key in knowledge_base)) {
        knowledge_base[key] = {}
    }
    counts = knowledge_base[key]
    if (value in counts) {
        counts[value] = counts[value] + 1
    }
    else {
    
        counts[value] = 1
    }
    return True
}

# أفضل قيمة عند تسمية زمنية

def find_best_with_prob_at_t(subject, predicate, tlabel): {
}
{
    key = subject + "_" + predicate + "_#_" + tlabel
    if (not (key in knowledge_base)) {
        return { "found": False }
    }
    counts = knowledge_base[key]
    best_value = ""
    best_count = -1
    total = 0
    for v in (counts) {
        c = counts[v]
        total = total + c
        if (c > best_count) {
            best_count = c
            best_value = v
        }
    }
    prob = 0
    if (total > 0) {
        prob = best_count / total
    }
    percent = prob * 100
    return { "found": True, "value": best_value, "count": best_count, "total": total, "prob": prob, "percent": percent }
}

# =============================
# إدارة الثقة والسياسة (الأحدث/الأوثق/الأكثر شيوعاً)
# =============================

meta_store = {}
resolution_policy = { "current": "most_frequent" }

# إضافة حقيقة مع ميتاداتا (زمن وثقة)

def add_fact_meta(subject, predicate, value, ts, conf): {
}
{
    add_fact(subject, predicate, value)
    key = subject + "_" + predicate
    if (not (key in meta_store)) {
        meta_store[key] = {}
    }
    vals = meta_store[key]
    if (value in vals) {
        m = vals[value]
        # تحديث أحدث زمن وأقصى ثقة
        if (ts > m["last"]) {
            m["last"] = ts
        }
        if (conf > m["max_conf"]) {
            m["max_conf"] = conf
        }
        m["count_meta"] = m["count_meta"] + 1
    }
    else {
    
        vals[value] = { "last": ts, "max_conf": conf, "count_meta": 1 }
    }
    return True
}

# تغيير سياسة الترجيح

def set_resolution_policy(pol): {
}
{
    # القيم المدعومة: most_frequent, most_recent, highest_confidence
    resolution_policy["current"] = pol
    return True
}

# الحصول على السياسة الحالية

def get_resolution_policy(): {
}
{
    return resolution_policy["current"]
}

# اختيار أفضل قيمة حسب السياسة

def find_best_with_policy(subject, predicate): {
}
{
    pol = resolution_policy["current"]
    if (pol == "most_frequent") {
        return find_best_with_prob(subject, predicate)
    }
    key = subject + "_" + predicate
    dist = find_distribution(subject, predicate)
    # إن لم توجد ميتاداتا كافية نعود للطريقة التقليدية
    if (not (key in meta_store)) {
        return find_best_with_prob(subject, predicate)
    }
    mvals = meta_store[key]
    best_value = ""
    has_best = False
    if (pol == "most_recent") {
        best_score = ""
    }
    else {
    
        best_score = -1
    }
    for v in (dist) {
        if (v in mvals) {
            m = mvals[v]
            if (pol == "most_recent") {
                score = m["last"]
                if ((not has_best) or (score > best_score)) {
                    best_score = score
                    best_value = v
                    has_best = True
                }
            }
            else {
            
                # highest_confidence
                score = m["max_conf"]
                if ((not has_best) or (score > best_score)) {
                    best_score = score
                    best_value = v
                    has_best = True
                }
            }
        }
    }
    if (best_value == "") {
        return find_best_with_prob(subject, predicate)
    }
    # حساب النسبة على التوزيع العام
    total = 0
    for v2 in (dist) {
        total = total + dist[v2]
    }
    cnt = dist[best_value]
    prob = 0
    if (total > 0) {
        prob = cnt / total
    }
    percent = prob * 100
    return { "found": True, "value": best_value, "count": cnt, "total": total, "prob": prob, "percent": percent }
}
