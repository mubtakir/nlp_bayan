{% extends 'base.html' %}
{% block content %}
<div class="row g-3">
  <div class="col-12 col-lg-3">
    <div class="card h-100">
      <div class="card-header d-flex align-items-center justify-content-between">
        <strong>Ø§Ù„Ù…Ù„ÙØ§Øª</strong>
        <div class="btn-group btn-group-sm" role="group">
          <a class="btn btn-primary" id="btn-new">+ Ø¬Ø¯ÙŠØ¯</a>
          <a class="btn btn-secondary" id="btn-refresh">ØªØ­Ø¯ÙŠØ«</a>
        </div>
      </div>
      <div class="px-3 py-2">
        <div class="btn-group btn-group-sm" role="group">
          <a class="btn btn-outline-light" id="btn-save-as">Ø­ÙØ¸ ÙƒÙ€</a>
          <a class="btn btn-outline-warning" id="btn-rename">Ø¥Ø¹Ø§Ø¯Ø© ØªØ³Ù…ÙŠØ©</a>
          <a class="btn btn-outline-danger" id="btn-delete">Ø­Ø°Ù</a>
        </div>
      </div>
        <div id="file-list" class="list-group list-group-flush" style="max-height: 60vh; overflow:auto"></div>
      </div>
    </div>
  </div>
  <div class="col-12 col-lg-9">
    <div class="card">
      <div class="card-header d-flex align-items-center justify-content-between">
        <div>
          <span class="badge text-bg-dark" id="current-file">ØºÙŠØ± Ù…Ø­ÙÙˆØ¸</span>
        </div>
        <div class="d-flex gap-2 align-items-center">
          <a class="btn btn-sm btn-primary" id="btn-run">ØªØ´ØºÙŠÙ„</a>
          <a class="btn btn-sm btn-secondary" id="btn-run-selection">ØªØ´ØºÙŠÙ„ Ø§Ù„ØªØ­Ø¯ÙŠØ¯</a>
          <a class="btn btn-sm btn-success" id="btn-save">Ø­ÙØ¸</a>
        </div>
      </div>
      <div class="px-3 py-2 d-flex flex-wrap align-items-center gap-2">
        <label class="form-label m-0 me-1">Ø£Ù…Ø«Ù„Ø©</label>
        <select id="sel-examples" class="form-select form-select-sm" style="width:auto; min-width: 220px"></select>
        <a class="btn btn-sm btn-outline-info" id="btn-load-example">ØªØ­Ù…ÙŠÙ„</a>
<input id="inp-example-filter" class="form-control form-control-sm" style="width: 160px" placeholder="Ø¨Ø­Ø«..." />
        <label class="form-label m-0 me-1">Ù…Ø¬Ø§Ù„ Ø§Ù„Ø£Ù…Ø«Ù„Ø©</label>
        <select id="sel-examples-domain" class="form-select form-select-sm" style="width:auto">
          <option value="all" selected>Ø§Ù„ÙƒÙ„</option>
          <option value="ai.ml">ai.ml</option>
          <option value="ai.nlp">ai.nlp</option>
          <option value="ai.data">ai.data</option>
          <option value="logic">logic</option>
          <option value="gfx">gfx</option>
          <option value="mixed">mixed</option>
          <option value="unknown">unknown</option>
        </select>
        <label class="form-label m-0 me-1">Ù„ØºØ© Ø§Ù„Ø¥ÙƒÙ…Ø§Ù„</label>
        <select id="sel-ac-lang" class="form-select form-select-sm" style="width:auto">
          <option value="all" selected>Ø§Ù„ÙƒÙ„</option>
          <option value="ar">Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©</option>
          <option value="en">English</option>
        </select>
        <label class="form-label m-0 me-1">Ù…Ø¬Ø§Ù„ Ø§Ù„Ø¥ÙƒÙ…Ø§Ù„</label>
        <select id="sel-ac-domain" class="form-select form-select-sm" style="width:auto">
          <option value="all" selected>Ø§Ù„ÙƒÙ„</option>
          <option value="ai.ml">ai.ml</option>
          <option value="ai.nlp">ai.nlp</option>
          <option value="ai.data">ai.data</option>
          <option value="logic">logic</option>
          <option value="gfx">gfx</option>
        </select>
        <div class="vr mx-2"></div>
        <label class="form-label m-0 me-1">Ø§Ù„Ø³Ù…Ø©</label>
        <select id="sel-theme" class="form-select form-select-sm" style="width:auto">
          <option value="ace/theme/monokai" selected>Monokai</option>
          <option value="ace/theme/chrome">Chrome</option>
          <option value="ace/theme/dracula">Dracula</option>
        </select>
        <label class="form-label m-0 ms-2 me-1">Ø­Ø¬Ù… Ø§Ù„Ø®Ø·</label>
        <select id="sel-fontsize" class="form-select form-select-sm" style="width:auto">
          <option>12</option>
          <option selected>14</option>
          <option>16</option>
          <option>18</option>
        </select>
      <div id="example-info" class="px-3 py-1 text-muted small"></div>
      <div id="ac-info" class="px-3 py-1 text-muted small"></div>

      </div>
      <div id="editor" style="height: 55vh; width: 100%"></div>
      <div class="card-body">
        <h6 class="mb-2">Ø§Ù„Ù…Ø®Ø±Ø¬Ø§Øª</h6>
        <pre id="output" class="p-3 rounded" style="background:#0b1220; border:1px solid #1f2a44; min-height: 18vh"></pre>
        <h6 class="mt-3 mb-2">Ù…Ø¹Ø§ÙŠÙ†Ø©</h6>
        <div id="preview-toolbar" class="d-flex align-items-center gap-2 mb-2" style="display:none">
          <span class="badge text-bg-light" id="preview-status">0/0</span>
          <div class="btn-group btn-group-sm" role="group">
            <button class="btn btn-outline-secondary" id="btn-prev-output">Ø³Ø§Ø¨Ù‚</button>
            <button class="btn btn-outline-secondary" id="btn-next-output">Ø§Ù„ØªØ§Ù„ÙŠ</button>
            <button class="btn btn-outline-primary" id="btn-toggle-play">ØªØ´ØºÙŠÙ„</button>
            <button class="btn btn-outline-info" id="btn-copy-output">Ù†Ø³Ø®</button>
            <button class="btn btn-outline-success" id="btn-download-output">ØªÙ†Ø²ÙŠÙ„</button>
          </div>
          <div class="d-flex align-items-center gap-2">
            <label class="form-label m-0 small">FPS</label>
            <select id="sel-play-fps" class="form-select form-select-sm" style="width:auto">
              <option value="2">2</option>
              <option value="6" selected>6</option>
              <option value="12">12</option>
              <option value="24">24</option>
            </select>
          </div>
        </div>

        <div id="preview" class="p-2 rounded" style="background:#ffffff; border:1px solid #1f2a44; min-height: 18vh"></div>
      </div>
    </div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.6/ace.js" integrity="sha512-ycHu2LvbZqBz7lR71QwFIfuA0S1YxC4+NpiJziG52iMm7W/gQ6I+ttcSzopwGtSDAm0F1RG8WzUuZ6s0OqYoYg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.6/ext-language_tools.min.js" integrity="sha512-uXK1r6n6mGm0mQ0qJx/fekxR6oT9vHBt4D9p6VQKQ9YJXw1S6Vboy3V3uFqg+Kc9pFfz9wV2mL4ZtbnJ0H1pLw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script>
  // Minimal Bayan mode (keywords + comments)
  ace.define('ace/mode/bayan', function(require, exports, module) {
    var oop = require("ace/lib/oop");
    var TextMode = require("ace/mode/text").Mode;
    var TextHighlightRules = require("ace/mode/text_highlight_rules").TextHighlightRules;

    var BayanHighlightRules = function() {
      var keywords = (
        'and|as|assert|async|await|break|class|continue|def|del|elif|else|except|'
        + 'False|finally|for|from|global|if|import|include|in|is|lambda|None|nonlocal|'
        + 'not|or|pass|raise|return|True|try|while|with|yield|hybrid|fact|rule|query|assertz|retract|entity|apply|'
        + 'Ø¥Ø°Ø§|ÙˆØ¥Ù„Ø§|Ù„ÙƒÙ„|Ø¨ÙŠÙ†Ù…Ø§|Ø­Ù‚ÙŠÙ‚Ø©|Ù‚Ø§Ø¹Ø¯Ø©|Ø§Ø³ØªØ¹Ù„Ø§Ù…|ÙƒÙŠØ§Ù†|Ø·Ø¨Ù‚|Ø¥Ø¯Ø±Ø§Ø¬|Ø§Ø³ØªÙŠØ±Ø§Ø¯|'
        + 'Ø¯Ø§Ù„Ø©|ØµÙ†Ù|Ø£Ø±Ø¬Ø¹|Ø§Ø·Ø¨Ø¹|Ù…ØªØºÙŠØ±|Ø«Ø§Ø¨Øª|ØµØ­ÙŠØ­|Ø®Ø·Ø£|Ù„Ø§Ø´ÙŠØ¡|Ùˆ|Ø£Ùˆ|Ù„ÙŠØ³|ÙÙŠ|Ù‡Ùˆ|'
        + 'Ø­Ø§ÙˆÙ„|Ø§Ù„ØªÙ‚Ø·|Ø£Ø®ÙŠØ±Ø§Ù‹|Ø§Ø±ÙØ¹|Ø£ÙƒØ¯|Ù…Ø¹|Ø£Ù†ØªØ¬|ØºÙŠØ±_Ù…ØªØ²Ø§Ù…Ù†|Ø§Ù†ØªØ¸Ø±|Ø¹Ø§Ù…|Ù…Ø­Ù„ÙŠ|'
        + 'Ù‚ÙŠÙ‘Ù…|Ù†ÙÙ‘Ø°|ØªØ±Ø¬Ù…|Ø£Ù†Ø´Ø¦_Ø¯Ø§Ù„Ø©|Ø¹Ø¯Ù‘Ù„_Ø¯Ø§Ù„Ø©|Ø§Ø­Ø°Ù_Ø¯Ø§Ù„Ø©|Ù…Ø¹Ù„ÙˆÙ…Ø§Øª_Ø¯Ø§Ù„Ø©|Ù‚Ø§Ø¦Ù…Ø©_Ø§Ù„Ø¯ÙˆØ§Ù„|ØªØ£Ù…Ù„|'
        + 'eval|exec|compile|create_function|modify_function|delete_function|get_function_info|list_functions|introspect'
      );
      var builtins = (
        'print|len|range|type|str|int|float|list|dict|set|tuple|bool|abs|max|min|sum|sorted|reversed|enumerate|zip|map|filter|'
        + 'Ø§Ø·Ø¨Ø¹|Ø·ÙˆÙ„|Ù…Ø¯Ù‰|Ù†ÙˆØ¹|Ù†Øµ|ØµØ­ÙŠØ­|Ø¹Ø´Ø±ÙŠ|Ù‚Ø§Ø¦Ù…Ø©|Ù‚Ø§Ù…ÙˆØ³|Ù…Ø¬Ù…ÙˆØ¹Ø©|ØµÙ|Ù…Ù†Ø·Ù‚ÙŠ|Ù…Ø·Ù„Ù‚|Ø£Ù‚ØµÙ‰|Ø£Ø¯Ù†Ù‰|Ù…Ø¬Ù…ÙˆØ¹|Ù…Ø±ØªØ¨|Ù…Ø¹ÙƒÙˆØ³|Ø¹Ø¯Ø¯|Ø¶Ù…|Ø®Ø±ÙŠØ·Ø©|Ø±Ø´Ø­'
      );
      this.$rules = { start: [
        { token: 'comment.line.number-sign.bayan', regex: '#.*$' },
        { token: 'string.quoted.single.bayan', regex: "'(?:[^'\\\\]|\\\\.)*'" },
        { token: 'string.quoted.double.bayan', regex: '"(?:[^"\\\\]|\\\\.)*"' },
        { token: 'constant.numeric.bayan', regex: /\b[0-9]+(?:\.[0-9]+)?\b/ },
        { token: 'keyword.control.bayan', regex: new RegExp('\\b(' + keywords + ')\\b') },
        { token: 'support.function.bayan', regex: new RegExp('\\b(' + builtins + ')\\b') }
      ]};
    };
    oop.inherits(BayanHighlightRules, TextHighlightRules);

    var Mode = function() { this.HighlightRules = BayanHighlightRules; };
    oop.inherits(Mode, TextMode);
    (function() { this.$id = 'ace/mode/bayan'; }).call(Mode.prototype);
    exports.Mode = Mode;
  });

  var editor = ace.edit('editor');
  editor.session.setMode('ace/mode/bayan');
  editor.setTheme('ace/theme/monokai');
  editor.setOptions({
    enableBasicAutocompletion: true,
    enableLiveAutocompletion: true,
    enableSnippets: true,
    fontSize: '14px',
    tabSize: 2,
    useSoftTabs: true,
    wrap: true,
    rtl: true
  });

  // Autocomplete: AI stdlib (English + Arabic) â€” curated popular entries
  const langTools = ace.require('ace/ext/language_tools');
  const aiCompletions = [
    // ML (supervised/unsupervised)
    {caption:'softmax_train', value:'softmax_train', meta:'ai.ml', score:90, docText:'Train softmax (multi-class logistic) classifier.'},
    {caption:'softmax_predict', value:'softmax_predict', meta:'ai.ml', score:90, docText:'Predict class labels using softmax model.'},
    {caption:'logistic_regression_train', value:'logistic_regression_train', meta:'ai.ml', docText:'Train binary logistic regression; returns [w,b].'},
    {caption:'logistic_regression_predict', value:'logistic_regression_predict', meta:'ai.ml', docText:'Predict 0/1 labels with threshold (default 0.5).'},
    {caption:'logistic_regression_predict_proba', value:'logistic_regression_predict_proba', meta:'ai.ml', docText:'Return probabilities for logistic regression.'},
    {caption:'k_nearest_neighbors_predict', value:'k_nearest_neighbors_predict', meta:'ai.ml', docText:'KNN classification for batch of samples.'},
    {caption:'k_means', value:'k_means', meta:'ai.ml', docText:'K-means clustering (deterministic init).'},
    {caption:'k_means_pp', value:'k_means_pp', meta:'ai.ml', docText:'K-means with k-means++ init (deterministic).'},
    {caption:'random_forest_train', value:'random_forest_train', meta:'ai.ml', docText:'Train simple random forest (educational).'},
    {caption:'random_forest_predict', value:'random_forest_predict', meta:'ai.ml', docText:'Predict with random forest model.'},
    {caption:'decision_tree_train', value:'decision_tree_train', meta:'ai.ml', docText:'Train decision tree classifier.'},
    {caption:'decision_tree_predict', value:'decision_tree_predict', meta:'ai.ml', docText:'Predict using decision tree.'},
    {caption:'accuracy_score', value:'accuracy_score', meta:'ai.ml', docText:'Classification accuracy.'},
    {caption:'precision_score', value:'precision_score', meta:'ai.ml', docText:'Precision for positive class.'},
    {caption:'recall_score', value:'recall_score', meta:'ai.ml', docText:'Recall for positive class.'},
    {caption:'f1_score', value:'f1_score', meta:'ai.ml', docText:'F1 = 2PR/(P+R).'},
    {caption:'confusion_matrix', value:'confusion_matrix', meta:'ai.ml', docText:'Binary confusion matrix [[tn,fp],[fn,tp]].'},
    {caption:'classification_report', value:'classification_report', meta:'ai.ml', docText:'Per-class precision/recall/F1 + averages.'},
    {caption:'pca_fit', value:'pca_fit', meta:'ai.ml', docText:'Compute PCA components.'},
    {caption:'pca_transform', value:'pca_transform', meta:'ai.ml', docText:'Project onto PCA components.'},
    {caption:'variance_threshold_fit', value:'variance_threshold_fit', meta:'ai.ml', docText:'Select features above variance threshold.'},
    {caption:'variance_threshold_transform', value:'variance_threshold_transform', meta:'ai.ml', docText:'Apply feature mask from fit.'},
    {caption:'train_test_split', value:'train_test_split', meta:'ai.ml', docText:'Deterministic split without shuffle.'},
    {caption:'train_test_split_stratified', value:'train_test_split_stratified', meta:'ai.ml', docText:'Label-stratified split; optional shuffle.'},
    {caption:'k_fold_indices', value:'k_fold_indices', meta:'ai.ml', docText:'K-fold indices generator.'},
    {caption:'stratified_k_fold_indices', value:'stratified_k_fold_indices', meta:'ai.ml', docText:'Stratified k-fold indices by labels.'},
    {caption:'grid_search_cv_softmax', value:'grid_search_cv_softmax', meta:'ai.ml', docText:'Grid search for softmax hyperparameters.'},
    {caption:'stacking_train', value:'stacking_train', meta:'ai.ml', docText:'Train simple stacking ensemble.'},
    {caption:'stacking_predict', value:'stacking_predict', meta:'ai.ml', docText:'Predict with stacking ensemble.'},
    {caption:'voting_classifier_predict', value:'voting_classifier_predict', meta:'ai.ml', docText:'Hard/soft voting across estimators.'},

    // NLP
    {caption:'preprocess_text', value:'preprocess_text', meta:'ai.nlp', docText:'Lowercase, remove punctuation, normalize spaces.'},
    {caption:'tokenize_text', value:'tokenize_text', meta:'ai.nlp', docText:'Naive whitespace tokenizer.'},
    {caption:'compute_tfidf', value:'compute_tfidf', meta:'ai.nlp', docText:'TF-IDF without logs (portable).'},
    {caption:'compute_tfidf_log', value:'compute_tfidf_log', meta:'ai.nlp', docText:'Log TF and smoothed IDF via binary-search ln.'},
    {caption:'compute_tfidf_log_norm', value:'compute_tfidf_log_norm', meta:'ai.nlp', docText:'TF-IDF (log) with L2 normalization.'},
    {caption:'compute_tfidf_options', value:'compute_tfidf_options', meta:'ai.nlp', docText:'TF-IDF with options: sublinear_tf, smooth_idf.'},
    {caption:'compute_tfidf_vocab_limit', value:'compute_tfidf_vocab_limit', meta:'ai.nlp', docText:'TF-IDF limited to top-k vocabulary.'},
    {caption:'soft_tfidf_build', value:'soft_tfidf_build', meta:'ai.nlp', docText:'Build Soft TF-IDF model with Jaroâ€“Winkler.'},
    {caption:'soft_tfidf_vector', value:'soft_tfidf_vector', meta:'ai.nlp', docText:'Compute soft TF-IDF vector for text.'},
    {caption:'soft_tfidf_cosine_similarity', value:'soft_tfidf_cosine_similarity', meta:'ai.nlp', docText:'Cosine similarity using soft TF-IDF.'},
    {caption:'bm25_build', value:'bm25_build', meta:'ai.nlp', docText:'Build BM25 data from docs.'},
    {caption:'bm25_score', value:'bm25_score', meta:'ai.nlp', docText:'BM25 scores for a query over docs.'},
    {caption:'bm25_top_k', value:'bm25_top_k', meta:'ai.nlp', docText:'Top-k docs by BM25 score.'},
    {caption:'bm25_score_with_term_weights', value:'bm25_score_with_term_weights', meta:'ai.nlp', docText:'BM25 with query-term weights.'},
    {caption:'tfidf_cosine_similarity', value:'tfidf_cosine_similarity', meta:'ai.nlp', docText:'Cosine similarity between two texts via TF-IDF.'},
    {caption:'cosine_similarity', value:'cosine_similarity', meta:'ai.nlp', docText:'Cosine over token lists (bag-of-words).'},
    {caption:'cosine_similarity_dicts', value:'cosine_similarity_dicts', meta:'ai.nlp', docText:'Cosine for term->weight dictionaries.'},
    {caption:'jaro_winkler_similarity', value:'jaro_winkler_similarity', meta:'ai.nlp', docText:'Jaroâ€“Winkler string similarity.'},
    {caption:'jaro_similarity', value:'jaro_similarity', meta:'ai.nlp', docText:'Jaro string similarity.'},
    {caption:'levenshtein_distance', value:'levenshtein_distance', meta:'ai.nlp', docText:'Edit distance (Levenshtein).'},
    {caption:'damerau_levenshtein_distance', value:'damerau_levenshtein_distance', meta:'ai.nlp', docText:'Edit distance with transposition.'},
    {caption:'lcs_length', value:'lcs_length', meta:'ai.nlp', docText:'Longest Common Subsequence length.'},
    {caption:'jaccard_char_ngrams', value:'jaccard_char_ngrams', meta:'ai.nlp', docText:'Jaccard over character n-grams.'},
    {caption:'dice_char_ngrams', value:'dice_char_ngrams', meta:'ai.nlp', docText:'SÃ¸rensenâ€“Dice over character n-grams.'},
    {caption:'normalize_arabic', value:'normalize_arabic', meta:'ai.nlp', docText:'Normalize Arabic forms and diacritics.'},
    {caption:'arabic_light_stem_tokens', value:'arabic_light_stem_tokens', meta:'ai.nlp', docText:'Light stemming for Arabic tokens.'},
    {caption:'remove_stopwords', value:'remove_stopwords', meta:'ai.nlp', docText:'Remove stopwords (auto language).'},
    {caption:'remove_stopwords_extended', value:'remove_stopwords_extended', meta:'ai.nlp', docText:'Remove stopwords with extended lists.'},

    // DATA
    {caption:'parse_csv_rows', value:'parse_csv_rows', meta:'ai.data', docText:'Parse CSV into list of fields per row.'},
    {caption:'read_csv_string', value:'read_csv_string', meta:'ai.data', docText:'Parse CSV from a single string.'},
    {caption:'write_csv_string', value:'write_csv_string', meta:'ai.data', docText:'Serialize rows to CSV string.'},
    {caption:'read_json_string', value:'read_json_string', meta:'ai.data', docText:'Parse simple JSON (educational).'},
    {caption:'write_json_array_string', value:'write_json_array_string', meta:'ai.data', docText:'Serialize string list to JSON array.'},
    {caption:'write_json_object_string', value:'write_json_object_string', meta:'ai.data', docText:'Serialize dict(str->str) to JSON object.'},
    {caption:'mean', value:'mean', meta:'ai.data', docText:'Arithmetic mean.'},
    {caption:'variance', value:'variance', meta:'ai.data', docText:'Population variance.'},
    {caption:'stddev', value:'stddev', meta:'ai.data', docText:'Standard deviation.'},
    {caption:'median', value:'median', meta:'ai.data', docText:'Median (selection sort based).'},
    {caption:'percentile', value:'percentile', meta:'ai.data', docText:'Linear interpolation percentile.'},
    {caption:'quantiles', value:'quantiles', meta:'ai.data', docText:'Multiple percentiles from [0,1] list.'},
    {caption:'iqr', value:'iqr', meta:'ai.data', docText:'Interquartile range (Tukey).'},
    {caption:'pearson_r', value:'pearson_r', meta:'ai.data', docText:'Pearson correlation coefficient.'},
    {caption:'minmax_normalize', value:'minmax_normalize', meta:'ai.data', docText:'Scale to [0,1].'},
    {caption:'zscore_normalize', value:'zscore_normalize', meta:'ai.data', docText:'Standardize array using mean/std.'},
    {caption:'standard_scaler_fit', value:'standard_scaler_fit', meta:'ai.data', docText:'Compute mean/std.'},
    {caption:'standard_scaler_transform', value:'standard_scaler_transform', meta:'ai.data', docText:'Apply standard scaling.'},
    {caption:'robust_scaler_fit', value:'robust_scaler_fit', meta:'ai.data', docText:'Compute median/IQR.'},
    {caption:'robust_scaler_transform', value:'robust_scaler_transform', meta:'ai.data', docText:'Apply robust scaling.'},
    {caption:'minmax_scaler_fit', value:'minmax_scaler_fit', meta:'ai.data', docText:'Compute min/max.'},
    {caption:'minmax_scaler_transform', value:'minmax_scaler_transform', meta:'ai.data', docText:'Apply min-max scaling.'},
    {caption:'bin_equal_width', value:'bin_equal_width', meta:'ai.data', docText:'Equal-width discretization to bin indices.'},
    {caption:'one_hot_encode', value:'one_hot_encode', meta:'ai.data', docText:'One-hot encode integer indices.'},
    {caption:'label_encoder_fit', value:'label_encoder_fit', meta:'ai.data', docText:'Build label vocabulary.'},
    {caption:'label_encoder_transform', value:'label_encoder_transform', meta:'ai.data', docText:'Map labels to indices.'},
    {caption:'frequency_encoder_fit', value:'frequency_encoder_fit', meta:'ai.data', docText:'Compute label frequencies.'},
    {caption:'frequency_encoder_transform', value:'frequency_encoder_transform', meta:'ai.data', docText:'Map labels to frequency.'},
    {caption:'target_encoder_fit', value:'target_encoder_fit', meta:'ai.data', docText:'Mean encoding per category.'},
    {caption:'target_encoder_transform', value:'target_encoder_transform', meta:'ai.data', docText:'Map by learned means (fallback global).'},
    {caption:'random_permutation', value:'random_permutation', meta:'ai.data', docText:'Deterministic Fisherâ€“Yates perm.'},
    {caption:'set_seed', value:'set_seed', meta:'ai.data', docText:'Set global PRNG seed.'},
    {caption:'rand', value:'rand', meta:'ai.data', docText:'Uniform random in [0,1).'},
    {caption:'randint', value:'randint', meta:'ai.data', docText:'Random integer in [a,b].'},
    {caption:'shuffle_list', value:'shuffle_list', meta:'ai.data', docText:'Shuffle copy using PRNG.'},
    {caption:'sample_list', value:'sample_list', meta:'ai.data', docText:'Sample k unique elements.'},
    {caption:'train_test_split_shuffle', value:'train_test_split_shuffle', meta:'ai.data', docText:'Shuffle split using PRNG.'},
    {caption:'pipeline_fit_transform', value:'pipeline_fit_transform', meta:'ai.data', docText:'Fit sequential steps; returns [X_out, models].'},
    {caption:'pipeline_transform', value:'pipeline_transform', meta:'ai.data', docText:'Transform using fitted models.'},

    // Arabic wrappers (selected)
    {caption:'ØªØ¯Ø±ÙŠØ¨_Ø§Ù†Ø­Ø¯Ø§Ø±_Ù„ÙˆØ¬Ø³ØªÙŠ', value:'ØªØ¯Ø±ÙŠØ¨_Ø§Ù†Ø­Ø¯Ø§Ø±_Ù„ÙˆØ¬Ø³ØªÙŠ', meta:'ai.ar', docText:'Arabic alias: logistic_regression_train.'},
    {caption:'ØªÙˆÙ‚Ø¹_Ø§Ù†Ø­Ø¯Ø§Ø±_Ù„ÙˆØ¬Ø³ØªÙŠ', value:'ØªÙˆÙ‚Ø¹_Ø§Ù†Ø­Ø¯Ø§Ø±_Ù„ÙˆØ¬Ø³ØªÙŠ', meta:'ai.ar', docText:'Arabic alias: logistic_regression_predict.'},
    {caption:'Ø§Ù†Ø­Ø¯Ø§Ø±_Ø®Ø·ÙŠ', value:'Ø§Ù†Ø­Ø¯Ø§Ø±_Ø®Ø·ÙŠ', meta:'ai.ar', docText:'Arabic alias: linear_regression.'},
    {caption:'ØªØ¬Ù…ÙŠØ¹_ÙƒÙŠ_Ù…ÙŠÙ†Ø²', value:'ØªØ¬Ù…ÙŠØ¹_ÙƒÙŠ_Ù…ÙŠÙ†Ø²', meta:'ai.ar', docText:'Arabic alias: k_means.'},
    {caption:'Ù…ØµÙÙˆÙØ©_Ø§Ù„Ø§Ù„ØªØ¨Ø§Ø³', value:'Ù…ØµÙÙˆÙØ©_Ø§Ù„Ø§Ù„ØªØ¨Ø§Ø³', meta:'ai.ar', docText:'Arabic alias: confusion_matrix.'},
    {caption:'ØªØ´Ø§Ø¨Ù‡_Ø¬ÙŠØ¨ÙŠ', value:'ØªØ´Ø§Ø¨Ù‡_Ø¬ÙŠØ¨ÙŠ', meta:'ai.ar', docText:'Arabic alias: cosine_similarity (lists).'},
    {caption:'Ø­Ø³Ø§Ø¨_tfidf', value:'Ø­Ø³Ø§Ø¨_tfidf', meta:'ai.ar', docText:'Arabic alias: compute_tfidf.'},
    {caption:'Ø­Ø³Ø§Ø¨_tfidf_Ù„ÙˆØº', value:'Ø­Ø³Ø§Ø¨_tfidf_Ù„ÙˆØº', meta:'ai.ar', docText:'Arabic alias: compute_tfidf_log.'},
    {caption:'Ø­Ø³Ø§Ø¨_tfidf_Ù„ÙˆØº_Ù…Ø·Ø¨Ø¹', value:'Ø­Ø³Ø§Ø¨_tfidf_Ù„ÙˆØº_Ù…Ø·Ø¨Ø¹', meta:'ai.ar', docText:'Arabic alias: compute_tfidf_log_norm.'},
    {caption:'Ù…Ù„Ø§Ø¡Ù…Ø©_ØªØ­ÙˆÙŠÙ„_Ø£Ù†Ø¨ÙˆØ¨', value:'Ù…Ù„Ø§Ø¡Ù…Ø©_ØªØ­ÙˆÙŠÙ„_Ø£Ù†Ø¨ÙˆØ¨', meta:'ai.ar', docText:'Arabic alias: pipeline_fit_transform.'},
    {caption:'ØªØ­ÙˆÙŠÙ„_Ø£Ù†Ø¨ÙˆØ¨', value:'ØªØ­ÙˆÙŠÙ„_Ø£Ù†Ø¨ÙˆØ¨', meta:'ai.ar', docText:'Arabic alias: pipeline_transform.'},
    {caption:'Ù‚Ø±Ø§Ø¡Ø©_CSV_Ù†Øµ', value:'Ù‚Ø±Ø§Ø¡Ø©_CSV_Ù†Øµ', meta:'ai.ar', docText:'Arabic alias: read_csv_string.'},
    {caption:'ÙƒØªØ§Ø¨Ø©_CSV_Ù†Øµ', value:'ÙƒØªØ§Ø¨Ø©_CSV_Ù†Øµ', meta:'ai.ar', docText:'Arabic alias: write_csv_string.'},
    {caption:'ØªØ·Ø¨ÙŠØ¹_Ø£Ø¯Ù†Ù‰_Ø£Ù‚ØµÙ‰', value:'ØªØ·Ø¨ÙŠØ¹_Ø£Ø¯Ù†Ù‰_Ø£Ù‚ØµÙ‰', meta:'ai.ar', docText:'Arabic alias: minmax_normalize.'},
    {caption:'ØªØ·Ø¨ÙŠØ¹_Z', value:'ØªØ·Ø¨ÙŠØ¹_Z', meta:'ai.ar', docText:'Arabic alias: zscore_normalize.'},
    {caption:'ØªØ±ØªÙŠØ¨_Ø¹Ø´ÙˆØ§Ø¦ÙŠ', value:'ØªØ±ØªÙŠØ¨_Ø¹Ø´ÙˆØ§Ø¦ÙŠ', meta:'ai.ar', docText:'Arabic alias: random_permutation.'},

    // LOGIC (language/hybrid helpers)
    {caption:'fact', value:'fact ', meta:'logic', score:70, docText:'Define a logic fact (ends with a dot).'},
    {caption:'rule', value:'rule ', meta:'logic', score:70, docText:'Define a logic rule: head :- body.'},
    {caption:'query', value:'query ', meta:'logic', score:70, docText:'Run a logic query; results shown in output.'},
    {caption:'assertz', value:'assertz(', meta:'logic', score:65, docText:'Dynamically add a fact at runtime.'},
    {caption:'retract', value:'retract(', meta:'logic', score:65, docText:'Dynamically remove a fact at runtime.'},
    {caption:'entity', value:'entity ', meta:'logic', score:60, docText:'Define an entity (states/properties/actions).'},
    {caption:'apply', value:'apply ', meta:'logic', score:60, docText:'Apply an action to a target entity.'},

    // Arabic aliases (logic)
    {caption:'Ø­Ù‚ÙŠÙ‚Ø©', value:'Ø­Ù‚ÙŠÙ‚Ø© ', meta:'logic', score:70, docText:'ØªØ¹Ø±ÙŠÙ Ø­Ù‚ÙŠÙ‚Ø© Ù…Ù†Ø·Ù‚ÙŠØ© ØªÙ†ØªÙ‡ÙŠ Ø¨Ù†Ù‚Ø·Ø©.', ar:true},
    {caption:'Ù‚Ø§Ø¹Ø¯Ø©', value:'Ù‚Ø§Ø¹Ø¯Ø© ', meta:'logic', score:70, docText:'ØªØ¹Ø±ÙŠÙ Ù‚Ø§Ø¹Ø¯Ø©: Ø§Ù„Ø±Ø£Ø³ :- Ø§Ù„Ø¬Ø³Ù….', ar:true},
    {caption:'Ø§Ø³ØªØ¹Ù„Ø§Ù…', value:'Ø§Ø³ØªØ¹Ù„Ø§Ù… ', meta:'logic', score:70, docText:'ØªÙ†ÙÙŠØ° Ø§Ø³ØªØ¹Ù„Ø§Ù… Ù…Ù†Ø·Ù‚ÙŠ ÙˆØ¹Ø±Ø¶ Ø§Ù„Ù†ØªØ§Ø¦Ø¬.', ar:true},
    {caption:'ÙƒÙŠØ§Ù†', value:'ÙƒÙŠØ§Ù† ', meta:'logic', score:60, docText:'ØªØ¹Ø±ÙŠÙ ÙƒÙŠØ§Ù† Ø¨Ø®ØµØ§Ø¦Øµ/Ø­Ø§Ù„Ø§Øª/Ø£ÙØ¹Ø§Ù„.', ar:true},
    {caption:'Ø·Ø¨Ù‚', value:'Ø·Ø¨Ù‚ ', meta:'logic', score:60, docText:'ØªØ·Ø¨ÙŠÙ‚ ÙØ¹Ù„ Ø¹Ù„Ù‰ ÙƒÙŠØ§Ù† Ù…Ø³ØªÙ‡Ø¯Ù.', ar:true},


    // GFX (SVG + waves + pen)
    {caption:'svg_wrap', value:'svg_wrap(', meta:'gfx', score:85, docText:'Wrap inner SVG content with width/height.'},
    {caption:'svg_rect', value:'svg_rect(', meta:'gfx', score:85, docText:'Rectangle element.'},
    {caption:'svg_circle', value:'svg_circle(', meta:'gfx', score:85, docText:'Circle element.'},
    {caption:'svg_line', value:'svg_line(', meta:'gfx', score:85, docText:'Line element.'},
    {caption:'svg_text', value:'svg_text(', meta:'gfx', score:85, docText:'Text element.'},
    {caption:'svg_triangle', value:'svg_triangle(', meta:'gfx', score:85, docText:'Triangle polygon (x1,y1,x2,y2,x3,y3).'},
    {caption:'svg_ellipse', value:'svg_ellipse(', meta:'gfx', score:85, docText:'Ellipse element.'},
    {caption:'svg_cylinder', value:'svg_cylinder(', meta:'gfx', score:85, docText:'2D cylinder (top ellipse + body + bottom ellipse).'},
    {caption:'svg_sphere', value:'svg_sphere(', meta:'gfx', score:85, docText:'2D sphere (circle with highlight).'},

    // GFX SVG animation (SMIL)
    {caption:'svg_animate', value:'svg_animate(', meta:'gfx', score:84, docText:'<animate> attr+values; e.g. svg_animate("opacity","0;1","2s","indefinite")'},
    {caption:'svg_animate_transform', value:'svg_animate_transform(', meta:'gfx', score:84, docText:'<animateTransform> e.g. rotate: svg_animate_transform("rotate","0 100 100","360 100 100","4s","indefinite")'},
    {caption:'svg_animate_motion', value:'svg_animate_motion(', meta:'gfx', score:84, docText:'<animateMotion> path_d + dur + repeat + rotate; e.g. "M 20,100 C 80,20 140,180 200,100"'},
    {caption:'svg_rotating_group', value:'svg_rotating_group(', meta:'gfx', score:83, docText:'Wrap inner in rotating <g>(inner,cx,cy,from,to,dur,repeat) â†’ simple spin'},

    {caption:'pen_new', value:'pen_new(', meta:'gfx', score:82, docText:'New free-draw pen (path builder).'},
    {caption:'pen_move', value:'pen_move(', meta:'gfx', score:82, docText:'Move pen to (x,y).'},
    {caption:'pen_line', value:'pen_line(', meta:'gfx', score:82, docText:'Line to (x,y).'},
    {caption:'pen_curve', value:'pen_curve(', meta:'gfx', score:82, docText:'Cubic Bezier curve.'},
    {caption:'pen_close', value:'pen_close(', meta:'gfx', score:82, docText:'Close path.'},
    {caption:'pen_to_path', value:'pen_to_path(', meta:'gfx', score:82, docText:'Convert pen to <path> element.'},
    {caption:'wave_sine', value:'wave_sine(', meta:'gfx', score:80, docText:'Generate sine wave points.'},
    {caption:'wave_square', value:'wave_square(', meta:'gfx', score:80, docText:'Generate square wave points.'},
    {caption:'wave_triangle', value:'wave_triangle(', meta:'gfx', score:80, docText:'Generate triangle wave points.'},
    {caption:'wave_plot_svg', value:'wave_plot_svg(', meta:'gfx', score:80, docText:'Render wave points to SVG path.'},

    {caption:'wave_sawtooth', value:'wave_sawtooth(', meta:'gfx', score:80, docText:'Generate sawtooth wave points.'},
    {caption:'wave_noise', value:'wave_noise(', meta:'gfx', score:80, docText:'Generate uniform noise points.'},
    {caption:'envelope_adsr', value:'envelope_adsr(', meta:'gfx', score:78, docText:'ADSR envelope over n samples (a,d,s,r).'},
    {caption:'apply_envelope', value:'apply_envelope(', meta:'gfx', score:78, docText:'Apply envelope array to points.'},
    {caption:'wave_am', value:'wave_am(', meta:'gfx', score:80, docText:'Amplitude modulation (AM).'},
    {caption:'wave_fm', value:'wave_fm(', meta:'gfx', score:80, docText:'Frequency modulation (FM).'},

    // Arabic aliases (gfx)
    {caption:'Ù„Ù_SVG', value:'Ù„Ù_SVG(', meta:'gfx', score:85, docText:'Ù„Ù Ù…Ø­ØªÙˆÙ‰ SVG Ø¨Ø¹Ø±Ø¶/Ø§Ø±ØªÙØ§Ø¹.' , ar:true},
    {caption:'Ù…Ø³ØªØ·ÙŠÙ„', value:'Ù…Ø³ØªØ·ÙŠÙ„(', meta:'gfx', score:85, docText:'Ø¹Ù†ØµØ± Ù…Ø³ØªØ·ÙŠÙ„.' , ar:true},
    {caption:'Ø¯Ø§Ø¦Ø±Ø©', value:'Ø¯Ø§Ø¦Ø±Ø©(', meta:'gfx', score:85, docText:'Ø¹Ù†ØµØ± Ø¯Ø§Ø¦Ø±Ø©.' , ar:true},
    {caption:'Ø®Ø·', value:'Ø®Ø·(', meta:'gfx', score:85, docText:'Ø¹Ù†ØµØ± Ø®Ø·.' , ar:true},
    {caption:'Ù†Øµ', value:'Ù†Øµ(', meta:'gfx', score:85, docText:'Ø¹Ù†ØµØ± Ù†Øµ.' , ar:true},
    {caption:'Ù…Ø«Ù„Ø«', value:'Ù…Ø«Ù„Ø«(', meta:'gfx', score:85, docText:'Ø¹Ù†ØµØ± Ù…Ø«Ù„Ø« (Ø«Ù„Ø§Ø« Ù†Ù‚Ø§Ø·).', ar:true},
    {caption:'Ø¨ÙŠØ¶ÙˆÙŠ', value:'Ø¨ÙŠØ¶ÙˆÙŠ(', meta:'gfx', score:85, docText:'Ø¹Ù†ØµØ± Ø¨ÙŠØ¶ÙˆÙŠ (Ø¥Ù‡Ù„ÙŠÙ„Ø¬ÙŠ).', ar:true},
    {caption:'Ø§Ø³Ø·ÙˆØ§Ù†Ø©', value:'Ø§Ø³Ø·ÙˆØ§Ù†Ø©(', meta:'gfx', score:85, docText:'Ø£Ø³Ø·ÙˆØ§Ù†Ø© Ø«Ù†Ø§Ø¦ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ (Ø¥Ù‡Ù„ÙŠÙ„Ø¬ Ø¹Ù„ÙˆÙŠ + Ø¬Ø³Ù… + Ø¥Ù‡Ù„ÙŠÙ„Ø¬ Ø³ÙÙ„ÙŠ).', ar:true},
    {caption:'ÙƒØ±Ø©', value:'ÙƒØ±Ø©(', meta:'gfx', score:85, docText:'ÙƒØ±Ø© Ø«Ù†Ø§Ø¦ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ (Ø¯Ø§Ø¦Ø±Ø© Ù…Ø¹ Ø¥Ø¶Ø§Ø¡Ø©).', ar:true},

    // ØªØ­Ø±ÙŠÙƒ SVG (SMIL) â€” Arabic wrappers
    {caption:'Ø­Ø±Ùƒ_SVG', value:'Ø­Ø±Ùƒ_SVG(', meta:'gfx', score:84, docText:'<animate> Ø®Ø§ØµÙŠØ© + Ù‚ÙŠÙ…Ø› Ù…Ø«Ø§Ù„: Ø­Ø±Ùƒ_SVG("opacity","0;1","2s","indefinite")', ar:true},
    {caption:'ØªØ­ÙˆÙŠÙ„_Ù…ØªØ­Ø±Ùƒ', value:'ØªØ­ÙˆÙŠÙ„_Ù…ØªØ­Ø±Ùƒ(', meta:'gfx', score:84, docText:'<animateTransform> Ù…Ø«Ø§Ù„ Ø¯ÙˆØ±Ø§Ù†: ØªØ­ÙˆÙŠÙ„_Ù…ØªØ­Ø±Ùƒ("rotate","0 100 100","360 100 100","4s","indefinite")', ar:true},
    {caption:'ØªØ­Ø±ÙŠÙƒ_Ù…Ø³Ø§Ø±', value:'ØªØ­Ø±ÙŠÙƒ_Ù…Ø³Ø§Ø±(', meta:'gfx', score:84, docText:'<animateMotion> Ù…Ø³Ø§Ø± + Ù…Ø¯Ø© + ØªÙƒØ±Ø§Ø± + ØªØ¯ÙˆÙŠØ±Ø› Ù…Ø«Ø§Ù„ Ù…Ø³Ø§Ø± Bezier.', ar:true},
    {caption:'Ù…Ø¬Ù…ÙˆØ¹Ø©_Ø¯ÙˆØ±Ø§Ù†', value:'Ù…Ø¬Ù…ÙˆØ¹Ø©_Ø¯ÙˆØ±Ø§Ù†(', meta:'gfx', score:83, docText:'Ù…Ø¬Ù…ÙˆØ¹Ø© <g> ØªØ¯ÙˆØ±: (Ø¯Ø§Ø®Ù„ØŒ Ù…Ø±ÙƒØ²_Ø³ØŒ Ù…Ø±ÙƒØ²_ØµØŒ Ù…Ù†ØŒ Ø¥Ù„Ù‰ØŒ Ù…Ø¯Ø©ØŒ ØªÙƒØ±Ø§Ø±).', ar:true},

    // GFX raster (Pillow)
    {caption:'img_canvas', value:'img_canvas(', meta:'gfx', score:84, docText:'Create a new RGBA canvas (requires Pillow).'},
    {caption:'img_rect', value:'img_rect(', meta:'gfx', score:84, docText:'Draw rectangle on image.'},
    {caption:'img_circle', value:'img_circle(', meta:'gfx', score:84, docText:'Draw circle on image.'},
    {caption:'img_line', value:'img_line(', meta:'gfx', score:84, docText:'Draw line on image.'},
    {caption:'img_text', value:'img_text(', meta:'gfx', score:84, docText:'Draw text on image.'},
    {caption:'img_to_data_uri', value:'img_to_data_uri(', meta:'gfx', score:84, docText:'Export image as data URI (PNG/JPEG).'},

    // Arabic aliases (raster)
    {caption:'Ù„ÙˆØ­Ø©', value:'Ù„ÙˆØ­Ø©(', meta:'gfx', score:84, docText:'Ø¥Ù†Ø´Ø§Ø¡ Ù„ÙˆØ­Ø© RGBA (ØªØªØ·Ù„Ø¨ Pillow).', ar:true},
    {caption:'Ù…Ø³ØªØ·ÙŠÙ„_ØµÙˆØ±Ø©', value:'Ù…Ø³ØªØ·ÙŠÙ„_ØµÙˆØ±Ø©(', meta:'gfx', score:84, docText:'Ø±Ø³Ù… Ù…Ø³ØªØ·ÙŠÙ„ Ø¹Ù„Ù‰ Ø§Ù„ØµÙˆØ±Ø©.', ar:true},
    {caption:'Ø¯Ø§Ø¦Ø±Ø©_ØµÙˆØ±Ø©', value:'Ø¯Ø§Ø¦Ø±Ø©_ØµÙˆØ±Ø©(', meta:'gfx', score:84, docText:'Ø±Ø³Ù… Ø¯Ø§Ø¦Ø±Ø© Ø¹Ù„Ù‰ Ø§Ù„ØµÙˆØ±Ø©.', ar:true},
    {caption:'Ø®Ø·_ØµÙˆØ±Ø©', value:'Ø®Ø·_ØµÙˆØ±Ø©(', meta:'gfx', score:84, docText:'Ø±Ø³Ù… Ø®Ø· Ø¹Ù„Ù‰ Ø§Ù„ØµÙˆØ±Ø©.', ar:true},
    {caption:'Ù†Øµ_ØµÙˆØ±Ø©', value:'Ù†Øµ_ØµÙˆØ±Ø©(', meta:'gfx', score:84, docText:'Ø±Ø³Ù… Ù†Øµ Ø¹Ù„Ù‰ Ø§Ù„ØµÙˆØ±Ø©.', ar:true},
    {caption:'ØµÙˆØ±Ø©_Ø¥Ù„Ù‰_URI', value:'ØµÙˆØ±Ø©_Ø¥Ù„Ù‰_URI(', meta:'gfx', score:84, docText:'ØªØµØ¯ÙŠØ± Ø§Ù„ØµÙˆØ±Ø© ÙƒØ³Ù„Ø³Ù„Ø© data URI.', ar:true},
    // Raster GIF export
    {caption:'img_gif_from_frames', value:'img_gif_from_frames(', meta:'gfx', score:83, docText:'Animated GIF (data URI) from frames[list of PIL Images]; duration_ms per frame.'},
    {caption:'ØµÙˆØ±Ø©_Ù…ØªØ­Ø±ÙƒØ©_Ù…Ù†_Ø¥Ø·Ø§Ø±Ø§Øª', value:'ØµÙˆØ±Ø©_Ù…ØªØ­Ø±ÙƒØ©_Ù…Ù†_Ø¥Ø·Ø§Ø±Ø§Øª(', meta:'gfx', score:83, docText:'GIF Ù…ØªØ­Ø±Ùƒ (data URI) Ù…Ù† Ù‚Ø§Ø¦Ù…Ø© ØµÙˆØ±Ø› Ø§Ù„Ù…Ø¯Ø© Ø¨Ø§Ù„Ù…Ù„Ù„ÙŠ Ø«Ø§Ù†ÙŠØ© Ù„ÙƒÙ„ Ø¥Ø·Ø§Ø±.', ar:true},

    {caption:'Ù‚Ù„Ù…_Ø¬Ø¯ÙŠØ¯', value:'Ù‚Ù„Ù…_Ø¬Ø¯ÙŠØ¯(', meta:'gfx', score:82, docText:'Ù‚Ù„Ù… Ø±Ø³Ù… Ø­Ø± (Ù…Ø³Ø§Ø±).' , ar:true},
    {caption:'Ù‚Ù„Ù…_ØªØ­Ø±Ùƒ', value:'Ù‚Ù„Ù…_ØªØ­Ø±Ùƒ(', meta:'gfx', score:82, docText:'ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ù‚Ù„Ù… Ø¥Ù„Ù‰ (x,y).' , ar:true},
    {caption:'Ù‚Ù„Ù…_Ø®Ø·', value:'Ù‚Ù„Ù…_Ø®Ø·(', meta:'gfx', score:82, docText:'Ø®Ø· Ø¥Ù„Ù‰ (x,y).' , ar:true},
    {caption:'Ù…ÙˆØ¬Ø©_Ø³Ù†_Ù…Ù†Ø´Ø§Ø±', value:'Ù…ÙˆØ¬Ø©_Ø³Ù†_Ù…Ù†Ø´Ø§Ø±(', meta:'gfx', score:80, docText:'ØªÙˆÙ„ÙŠØ¯ Ù…ÙˆØ¬Ø© Ø³Ù† Ù…Ù†Ø´Ø§Ø±.', ar:true},
    {caption:'Ù…ÙˆØ¬Ø©_Ø¶ÙˆØ¶Ø§Ø¡', value:'Ù…ÙˆØ¬Ø©_Ø¶ÙˆØ¶Ø§Ø¡(', meta:'gfx', score:80, docText:'ØªÙˆÙ„ÙŠØ¯ Ø¶ÙˆØ¶Ø§Ø¡ Ù…ÙˆØ­Ø¯Ø©.', ar:true},
    {caption:'Ù…ØºÙ„Ù_ADSR', value:'Ù…ØºÙ„Ù_ADSR(', meta:'gfx', score:78, docText:'Ù…ØºÙ„Ù Ù‡Ø¬ÙˆÙ…/Ø§Ø¶Ù…Ø­Ù„Ø§Ù„/Ø«Ø¨Ø§Øª/ØªØ­Ø±ÙŠØ±.', ar:true},
    {caption:'ØªØ·Ø¨ÙŠÙ‚_Ù…ØºÙ„Ù', value:'ØªØ·Ø¨ÙŠÙ‚_Ù…ØºÙ„Ù(', meta:'gfx', score:78, docText:'ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù…ØºÙ„Ù Ø¹Ù„Ù‰ Ø§Ù„Ù†Ù‚Ø§Ø·.', ar:true},
    {caption:'Ù…ÙˆØ¬Ø©_AM', value:'Ù…ÙˆØ¬Ø©_AM(', meta:'gfx', score:80, docText:'ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø³Ø¹Ø© (AM).', ar:true},
    {caption:'Ù…ÙˆØ¬Ø©_FM', value:'Ù…ÙˆØ¬Ø©_FM(', meta:'gfx', score:80, docText:'ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ØªØ±Ø¯Ø¯ (FM).', ar:true},

    {caption:'Ù‚Ù„Ù…_Ù…Ù†Ø­Ù†Ù‰', value:'Ù‚Ù„Ù…_Ù…Ù†Ø­Ù†Ù‰(', meta:'gfx', score:82, docText:'Ù…Ù†Ø­Ù†Ù‰ Ø¨ÙŠØ²ÙŠÙ‡ Ù…ÙƒØ¹Ø¨.' , ar:true},
    {caption:'Ù‚Ù„Ù…_Ø¥ØºÙ„Ø§Ù‚', value:'Ù‚Ù„Ù…_Ø¥ØºÙ„Ø§Ù‚(', meta:'gfx', score:82, docText:'Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ù…Ø³Ø§Ø±.' , ar:true},
    {caption:'Ù‚Ù„Ù…_Ø¥Ù„Ù‰_Ù…Ø³Ø§Ø±', value:'Ù‚Ù„Ù…_Ø¥Ù„Ù‰_Ù…Ø³Ø§Ø±(', meta:'gfx', score:82, docText:'ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù‚Ù„Ù… Ø¥Ù„Ù‰ Ø¹Ù†ØµØ± <path>.' , ar:true},
    {caption:'Ù…ÙˆØ¬Ø©_Ø¬ÙŠØ¨', value:'Ù…ÙˆØ¬Ø©_Ø¬ÙŠØ¨(', meta:'gfx', score:80, docText:'ØªÙˆÙ„ÙŠØ¯ Ù†Ù‚Ø§Ø· Ù…ÙˆØ¬Ø© Ø¬ÙŠØ¨ÙŠØ©.' , ar:true},
    {caption:'Ù…ÙˆØ¬Ø©_Ù…Ø±Ø¨Ø¹Ø©', value:'Ù…ÙˆØ¬Ø©_Ù…Ø±Ø¨Ø¹Ø©(', meta:'gfx', score:80, docText:'ØªÙˆÙ„ÙŠØ¯ Ù†Ù‚Ø§Ø· Ù…ÙˆØ¬Ø© Ù…Ø±Ø¨Ø¹Ø©.' , ar:true},
    {caption:'Ù…ÙˆØ¬Ø©_Ù…Ø«Ù„Ø«ÙŠØ©', value:'Ù…ÙˆØ¬Ø©_Ù…Ø«Ù„Ø«ÙŠØ©(', meta:'gfx', score:80, docText:'ØªÙˆÙ„ÙŠØ¯ Ù†Ù‚Ø§Ø· Ù…ÙˆØ¬Ø© Ù…Ø«Ù„Ø«ÙŠØ©.' , ar:true},
    {caption:'Ø±Ø³Ù…_Ù…ÙˆØ¬Ø©_SVG', value:'Ø±Ø³Ù…_Ù…ÙˆØ¬Ø©_SVG(', meta:'gfx', score:80, docText:'Ø±Ø³Ù… Ù†Ù‚Ø§Ø· Ø§Ù„Ù…ÙˆØ¬Ø© Ø¥Ù„Ù‰ SVG.' , ar:true},

    {caption:'ØªÙ‚Ø³ÙŠÙ…_Ø¹Ø´ÙˆØ§Ø¦ÙŠ_ØªØ¯Ø±ÙŠØ¨_Ø§Ø®ØªØ¨Ø§Ø±', value:'ØªÙ‚Ø³ÙŠÙ…_Ø¹Ø´ÙˆØ§Ø¦ÙŠ_ØªØ¯Ø±ÙŠØ¨_Ø§Ø®ØªØ¨Ø§Ø±', meta:'ai.ar', docText:'Arabic alias: train_test_split_shuffle.'}
  ];
  const isArabicName = (s) => /[^\x00-\x7F]/.test(s || '');
  let completionLangMode = 'all';
  let completionDomainMode = 'all';
  const aiCompleter = {
    getCompletions: function(editor, session, pos, prefix, callback) {
      const compsRaw = aiCompletions.map(it => ({
        caption: it.caption,
        value: it.value,
        meta: it.meta,
        score: it.score || 80,
        docText: it.docText,
        ar: (typeof it.ar === 'boolean' ? it.ar : isArabicName(it.caption))
      }));
      let comps = compsRaw;
      if (completionLangMode === 'ar') comps = comps.filter(c => c.ar);
      else if (completionLangMode === 'en') comps = comps.filter(c => !c.ar);
      if (completionDomainMode !== 'all') comps = comps.filter(c => (c.meta || '') === completionDomainMode);
      callback(null, comps);
    }
  };
  langTools.addCompleter(aiCompleter);


  // Dynamic: load all AI functions (English + Arabic) from backend and merge
  try {
    fetch('/api/ide/ai_functions').then(r => r.json()).then(items => {
      const seen = new Set(aiCompletions.map(c => c.caption));
      items.forEach(fn => {
        if (!seen.has(fn.name)) {
          aiCompletions.push({
            caption: fn.name,
            value: fn.name,
            meta: fn.meta || 'ai',
            score: fn.ar ? 92 : 85,
            docText: fn.doc || '',
            ar: !!fn.ar
          });
          seen.add(fn.name);
        } else {
          const i = aiCompletions.findIndex(c => c.caption === fn.name);
          if (i >= 0) {
            if (fn.meta) aiCompletions[i].meta = fn.meta;
            if (!aiCompletions[i].docText && fn.doc) aiCompletions[i].docText = fn.doc;
            if (typeof aiCompletions[i].ar !== 'boolean') aiCompletions[i].ar = !!fn.ar;
          }

        }
      });
    }).catch(() => {});
  } catch (e) {}

  editor.setValue(`# Ù…Ø«Ø§Ù„ Ø³Ø±ÙŠØ¹\n\nprint("Hello Bayan!\n")\n\nclass A:{\n  def who():{ print("A") }\n}\n\nb = A()\nb.who()\n\n# Ù…Ù†Ø·Ù‚\nhybrid{\n  fact edge(a,b).\n  fact edge(b,c).\n  rule reachable(X,Y) :- edge(X,Y).\n  rule reachable(X,Y) :- edge(X,Z), reachable(Z,Y).\n  print("reachable(a, ?Y):")\n  query reachable(a, ?Y).\n}\n`, 1);

  const outputPre = document.getElementById('output');
  const previewDiv = document.getElementById('preview');
  const currentFileBadge = document.getElementById('current-file');
  let currentFile = null;

  editor.session.getUndoManager().markClean();
  const updateDirty = () => {
    const clean = editor.session.getUndoManager().isClean();
    window.onbeforeunload = clean ? null : function(e){ e.preventDefault(); e.returnValue=''; };
  };
  updateDirty();

  const previewToolbar = document.getElementById('preview-toolbar');
  const previewStatus = document.getElementById('preview-status');
  const btnPrevOutput = document.getElementById('btn-prev-output');
  const btnNextOutput = document.getElementById('btn-next-output');
  const btnCopyOutput = document.getElementById('btn-copy-output');
  const btnDownloadOutput = document.getElementById('btn-download-output');
  const btnTogglePlay = document.getElementById('btn-toggle-play');
  const selPlayFps = document.getElementById('sel-play-fps');
  let previewItems = [];
  let previewIndex = 0;
  let playTimer = null;
  let playFps = 6;
  if (btnPrevOutput) btnPrevOutput.addEventListener('click', () => { if (previewIndex > 0) { previewIndex--; renderPreview(); } });
  if (btnNextOutput) btnNextOutput.addEventListener('click', () => { if (previewIndex < (previewItems.length - 1)) { previewIndex++; renderPreview(); } });
  if (btnCopyOutput) btnCopyOutput.addEventListener('click', () => copyCurrentOutput());
  if (btnDownloadOutput) btnDownloadOutput.addEventListener('click', () => downloadCurrentOutput());
  if (btnTogglePlay) btnTogglePlay.addEventListener('click', () => togglePlayback());
  if (selPlayFps) selPlayFps.addEventListener('change', () => { try{ playFps = Math.max(1, parseInt(selPlayFps.value, 10) || 6); if (playTimer){ stopPlayback(); startPlayback(); } }catch(_){}});


  // Static keyword completer
  const keywords = [
    'class','def','return','if','elif','else','while','for','break','continue','try','except','finally','raise','assert','with','yield','async','await','import','from','as','pass','True','False','None','hybrid','fact','rule','query','print','super'
  ];
  const staticCompleter = {
    getCompletions: function(editor, session, pos, prefix, callback) {
      const completions = keywords.map(k => ({
        caption: k, value: k, meta: 'kw', score: 50
      }));
      callback(null, completions);
    }
  };
  langTools.addCompleter(staticCompleter);

  async function refreshFiles() {
    const res = await fetch('/api/ide/files');
    const files = await res.json();
    const list = document.getElementById('file-list');
    list.innerHTML = '';
    files.forEach(f => {
      const a = document.createElement('a');
      a.href = '#';
      a.className = 'list-group-item list-group-item-action d-flex justify-content-between align-items-center';
      a.textContent = f.name;
      a.onclick = async (e) => {
        e.preventDefault();

        const r = await fetch(`/api/ide/file?name=${encodeURIComponent(f.name)}`);
        if (r.ok) {
          const data = await r.json();
          editor.setValue(data.content, 1);
          currentFile = data.name;
          currentFileBadge.textContent = currentFile;
              editor.session.getUndoManager().markClean();
              updateDirty();

        }
      };
      list.appendChild(a);
    });
  }

  async function saveFile(asNew=false) {
    let name = currentFile;
    if (!name || asNew) {
      name = prompt('Ø§Ø³Ù… Ø§Ù„Ù…Ù„Ù (ÙŠÙ†ØªÙ‡ÙŠ Ø¨Ù€ .bayan Ø£Ùˆ .by):', name || 'program.bayan');
      if (!name) return;
    }
    const res = await fetch('/api/ide/file', {
      method: 'POST', headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name, content: editor.getValue() })
    });
    if (res.ok) {
      currentFile = name; currentFileBadge.textContent = name; refreshFiles();
      editor.session.getUndoManager().markClean();
      updateDirty();
    } else {
      alert('ÙØ´Ù„ Ø§Ù„Ø­ÙØ¸');
    }
  }

  function extractSvg(s) {
    try {
      if (!s) return '';
      const m = s.match(/<svg[\s\S]*?<\/svg>/i);
      return m ? m[0] : '';
    } catch (_) { return ''; }
  }
  function extractDataUri(s) {
    try {
      if (!s) return '';
      const m = s.match(/data:image\/(png|jpeg);base64,[A-Za-z0-9+/=]+/i);
      return m ? m[0] : '';
    } catch (_) { return ''; }
  }
  function setToolbarVisible(v){
    try{
      if (previewToolbar) previewToolbar.style.display = v ? '' : 'none';
      if (!v){ if (typeof stopPlayback === 'function') stopPlayback(); }
      if (typeof updatePlayButton === 'function') updatePlayButton();
    }catch(_){}
  }
  function collectOutputs(s){
    const items = [];
    try{
      if (!s) return items;
      const svgRe = /<svg[\s\S]*?<\/svg>/ig;
      let m;
      while ((m = svgRe.exec(s))){ items.push({ type:'svg', content:m[0], pos:m.index }); }
      const dataRe = /data:image\/[a-zA-Z0-9.+-]+;base64,[A-Za-z0-9+/=]+/ig;
      while ((m = dataRe.exec(s))){ items.push({ type:'data', content:m[0], pos:m.index }); }
      items.sort((a,b)=>a.pos-b.pos);
    }catch(_){ }
    return items;
  }
  function renderPreview(){
    if (!previewDiv){ setToolbarVisible(false); return; }
    previewDiv.innerHTML = '';
    if (!previewItems || previewItems.length === 0){ setToolbarVisible(false); return; }
    if (previewIndex < 0) previewIndex = 0;
    if (previewIndex >= previewItems.length) previewIndex = previewItems.length - 1;
    const it = previewItems[previewIndex];
    try{
      if (previewStatus) previewStatus.textContent = `${previewIndex+1}/${previewItems.length}`;
      if (btnPrevOutput) btnPrevOutput.disabled = (previewIndex <= 0);
      if (btnNextOutput) btnNextOutput.disabled = (previewIndex >= previewItems.length-1);
      if (typeof updatePlayButton === 'function') updatePlayButton();
    }catch(_){ }
    setToolbarVisible(true);
    if (it.type === 'svg'){
      previewDiv.innerHTML = it.content;
    } else {
      const img = document.createElement('img');
      img.src = it.content;
      img.style.maxWidth = '100%'; img.style.height='auto'; img.style.border='0';
      previewDiv.appendChild(img);
    }
  }
  function dataUriToBlob(uri){
    try{
      const m = uri.match(/^data:(image\/[a-zA-Z0-9.+-]+);base64,([A-Za-z0-9+/=]+)/i);
      if (!m) return null;
      const mime = m[1]; const b64 = m[2];
      const bin = atob(b64); const len = bin.length; const arr = new Uint8Array(len);
      for (let i=0;i<len;i++) arr[i] = bin.charCodeAt(i);
      return new Blob([arr], {type:mime});
    }catch(_){ return null; }
  }
  function svgTextToBlob(txt){ try{ return new Blob([txt], {type:'image/svg+xml'}); }catch(_){ return null; } }
  function suggestFilename(it, idx){
    try{
      let ext = (it.type === 'svg') ? 'svg' : (it.content.match(/^data:image\/([a-zA-Z0-9.+-]+)/i)?.[1] || 'img');
      ext = ext.replace('svg+xml','svg');
      return `output_${idx+1}.${ext}`;
    }catch(_){ return `output_${idx+1}.img`; }
  }
  function copyCurrentOutput(){
    try{
      const it = previewItems && previewItems[previewIndex]; if (!it) return;
      if (navigator.clipboard && window.isSecureContext){
        navigator.clipboard.writeText(it.content).catch(()=>{});
      } else {
        const ta = document.createElement('textarea');
        ta.value = it.content; document.body.appendChild(ta); ta.select();
        try{ document.execCommand('copy'); }catch(_){ }
        document.body.removeChild(ta);
      }
    }catch(_){ }
  }
  function updatePlayButton(){
    try{
      if (!btnTogglePlay) return;
      const canPlay = (previewItems && previewItems.length > 1);
      btnTogglePlay.disabled = !canPlay;
      btnTogglePlay.textContent = playTimer ? 'Ø¥ÙŠÙ‚Ø§Ù' : 'ØªØ´ØºÙŠÙ„';
    }catch(_){ }
  }
  function startPlayback(){
    try{
      if (playTimer) return;
      if (!previewItems || previewItems.length < 2) return;
      const interval = Math.max(16, Math.floor(1000 / (playFps || 6)));
      playTimer = setInterval(() => {
        try{
          previewIndex = (previewIndex + 1) % previewItems.length;
          renderPreview();
        }catch(_){ }
      }, interval);
      updatePlayButton();
    }catch(_){ }
  }
  function stopPlayback(){
    try{
      if (playTimer){ clearInterval(playTimer); playTimer = null; }
      updatePlayButton();
    }catch(_){ }
  }
  function togglePlayback(){ try{ if (playTimer) stopPlayback(); else startPlayback(); }catch(_){ } }
  function downloadCurrentOutput(){
    try{
      const it = previewItems && previewItems[previewIndex]; if (!it) return;
      const blob = (it.type === 'svg') ? svgTextToBlob(it.content) : dataUriToBlob(it.content);
      if (!blob) return;
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = suggestFilename(it, previewIndex);
      document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    }catch(_){ }
  }



  async function run(code) {
    outputPre.textContent = '...';
    if (previewDiv) { previewDiv.innerHTML = ''; }
    if (typeof stopPlayback === 'function') stopPlayback();
    previewItems = [];
    previewIndex = 0;
    setToolbarVisible(false);
    const res = await fetch('/api/ide/run', {
      method: 'POST', headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ code })
    });
    const data = await res.json();
    if (data.success) {
      editor.session.clearAnnotations();
      let out = '';
      if (data.stdout) out += data.stdout;
      if (data.result !== null && data.result !== undefined) {
        out += `\n[Result(JSON)]: ${JSON.stringify(data.result)}`;
      } else if (data.result_repr) {
        out += `\n[Result]: ${data.result_repr}`;
      }
      outputPre.textContent = out;
      // Build multi-output preview items (SVG and data:image/*) and render
      if (previewDiv) {
        previewItems = collectOutputs(out);
        previewIndex = 0;
        renderPreview();
      }
    } else {
      annotateError(data.error, data.traceback);
      outputPre.textContent = `Error: ${data.error_type}: ${data.error}\n${data.traceback || ''}`;
      if (previewDiv) { previewDiv.innerHTML = ''; }
      previewItems = [];
      previewIndex = 0;
      setToolbarVisible(false);
    }
  }

  function annotateError(errorText, traceback) {
    try {
      const text = (traceback || '') + '\n' + (errorText || '');
      const m = text.match(/line\s+(\d+)/i);
      if (m) {
        const row = Math.max(0, parseInt(m[1], 10) - 1);
        editor.session.setAnnotations([{ row, column: 0, text: errorText || 'Error', type: 'error' }]);
        editor.scrollToLine(row, true, true, function(){});
        editor.gotoLine(row + 1, 0, true);
      }
    } catch (e) {}
  }

  let examplesMaster = [];
  async function refreshExamples() {
    try {
      const res = await fetch('/api/ide/examples');
      examplesMaster = await res.json();
      applyExamplesFilter();
    } catch (e) {}
  }
  function domainEmoji(d){
    switch(d){
      case 'ai.ml': return 'ğŸŸ©';
      case 'ai.nlp': return 'ğŸŸ¦';
      case 'ai.data': return 'ğŸŸ¨';
      case 'logic': return 'ğŸŸª';
      case 'gfx': return 'ğŸŸ¥';
      case 'mixed': return 'ğŸŸ§';
      default: return 'âšª';
    }
  }


  function renderExamples(list) {
    const sel = document.getElementById('sel-examples');
    sel.innerHTML = '';
    list.forEach(it => {
      const opt = document.createElement('option');
      opt.value = it.name;
      const domLabel = (it.domain || 'unknown');
      const badge = domainEmoji(domLabel);
      opt.textContent = `${badge} [${domLabel}] ${it.name}`;
      if (it.desc) opt.title = it.desc;
      else opt.title = it.name;
      sel.appendChild(opt);
    });
  }

  function applyExamplesFilter() {
    const q = (document.getElementById('inp-example-filter').value || '').toLowerCase();
    const dom = (document.getElementById('sel-examples-domain').value || 'all');
    let list = examplesMaster || [];
    if (dom !== 'all') list = list.filter(it => (it.domain || 'unknown') === dom);
    if (q) list = list.filter(it => (it.name || '').toLowerCase().includes(q));
    renderExamples(list);
    updateExampleInfo();
  }

  function updateExampleInfo() {
    try {
      const el = document.getElementById('example-info');
      const sel = document.getElementById('sel-examples');
      if (!el || !sel) return;
      const name = sel.value;
      const it = (examplesMaster || []).find(x => x.name === name);
      if (it) {
        const domLabel = (it.domain || 'unknown');
        const badge = domainEmoji(domLabel);
        el.textContent = `Ù…Ø«Ø§Ù„: ${badge} [${domLabel}] ${it.name} â€” ${it.desc || ''}`;
      } else el.textContent = '';
    } catch (e) {}
  }

  function setAcInfo(t) {
    const el = document.getElementById('ac-info');
    if (el) el.textContent = t ? ('ÙˆØµÙ Ø§Ù„Ø¥ÙƒÙ…Ø§Ù„: ' + t) : '';
  }

  function setupAutocompleteInfo() {
    try {
      editor.commands.on('afterExec', function(e) {
        if (e && e.command && e.command.name === 'startAutocomplete') {
          const compl = editor.completer;
          const popup = compl && compl.popup;
          if (popup && !popup._descHook) {
            popup._descHook = true;
            popup.on('changeSelection', function() {
              try {
                const row = popup.getRow();
                const data = popup.data;
                const it = data && data[row];
                const t = (it && (it.docText || it.caption || '')) || '';
                setAcInfo(t);
              } catch (_) {}
            });
          }
        }
      });
    } catch (e) {}
  }

  function setupShortcuts() {
    editor.commands.addCommand({
      name: 'save', bindKey: { win: 'Ctrl-S', mac: 'Command-S' },
      exec: () => saveFile(false)
    });
    editor.commands.addCommand({
      name: 'run', bindKey: { win: 'Ctrl-Enter', mac: 'Command-Enter' },
      exec: () => run(editor.getValue())
    });
    editor.commands.addCommand({
      name: 'runSelection', bindKey: { win: 'Shift-Ctrl-Enter', mac: 'Shift-Command-Enter' },
      exec: () => {
        const sel = editor.session.getTextRange(editor.getSelectionRange());

        run(sel || editor.getValue());
      }
    });
    editor.session.on('change', updateDirty);
  }


  // Buttons
  document.getElementById('btn-refresh').onclick = refreshFiles;
  document.getElementById('btn-new').onclick = () => { currentFile = null; currentFileBadge.textContent = 'ØºÙŠØ± Ù…Ø­ÙÙˆØ¸'; editor.setValue('',1); updateDirty(); };
  document.getElementById('btn-save').onclick = () => saveFile(false);
  document.getElementById('btn-save-as').onclick = () => saveFile(true);
  document.getElementById('btn-rename').onclick = async () => {
    if (!currentFile) return alert('Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ù„Ù Ù…ÙØªÙˆØ­');
    const name = prompt('Ø§Ø³Ù… Ø¬Ø¯ÙŠØ¯:', currentFile);
    if (!name || name === currentFile) return;
    const res = await fetch('/api/ide/rename', {
      method: 'POST', headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ old_name: currentFile, new_name: name })
    });
    if (res.ok) { currentFile = name; currentFileBadge.textContent = name; refreshFiles(); }
  };
  document.getElementById('btn-delete').onclick = async () => {
    if (!currentFile) return alert('Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ù„Ù Ù…ÙØªÙˆØ­');
    if (!confirm('Ø­Ø°Ù Ø§Ù„Ù…Ù„ÙØŸ')) return;
    const res = await fetch(`/api/ide/file?name=${encodeURIComponent(currentFile)}`, { method: 'DELETE' });
    if (res.ok) { currentFile = null; currentFileBadge.textContent = 'ØºÙŠØ± Ù…Ø­ÙÙˆØ¸'; editor.setValue('',1); refreshFiles(); }
  };
  document.getElementById('btn-run').onclick = () => run(editor.getValue());
  document.getElementById('btn-run-selection').onclick = () => {
    const sel = editor.session.getTextRange(editor.getSelectionRange());
    run(sel || editor.getValue());
  };

  // Toolbar handlers
  document.getElementById('btn-load-example').onclick = async () => {
    const sel = document.getElementById('sel-examples');
    const name = sel.value;
    if (!name) return;
    const r = await fetch(`/api/ide/example?name=${encodeURIComponent(name)}`);
    if (r.ok) {

      const data = await r.json();
      editor.setValue(data.code, 1);
      currentFile = null;
      currentFileBadge.textContent = 'ØºÙŠØ± Ù…Ø­ÙÙˆØ¸';
      editor.session.getUndoManager().markClean();
      updateDirty();
    }
  };
  document.getElementById('sel-theme').onchange = (e) => editor.setTheme(e.target.value);
  document.getElementById('sel-fontsize').onchange = (e) => editor.setFontSize(parseInt(e.target.value, 10) || 14);

  document.getElementById('sel-ac-domain').onchange = (e) => { completionDomainMode = e.target.value; };
  document.getElementById('sel-ac-lang').onchange = (e) => { completionLangMode = e.target.value; };
  document.getElementById('sel-examples-domain').onchange = applyExamplesFilter;
  document.getElementById('inp-example-filter').oninput = applyExamplesFilter;
  document.getElementById('sel-examples').onchange = updateExampleInfo;
  setupAutocompleteInfo();


  // init
  refreshFiles();
  refreshExamples();
  setupShortcuts();

</script>
{% endblock %}

