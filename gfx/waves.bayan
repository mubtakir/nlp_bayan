# Waves generation and SVG plotting

include "gfx/svg.bayan"
import math
import random


# Generate N points of a sine wave over t in [0, 1]
# amplitude in pixels, frequency in cycles over the length, phase in radians

def wave_sine(n, amplitude, frequency, phase=0.0):
{
    pts = []
    for i in (range(n)) {
        t = i / (n - 1)
        y = amplitude * math.sin(2 * math.pi * frequency * t + phase)
        pts.append([t, y])
    }
    return pts
}

# Square wave: values +/- amplitude

def wave_square(n, amplitude, frequency, phase=0.0):
{
    pts = []
    for i in (range(n)) {
        t = i / (n - 1)
        s = math.sin(2 * math.pi * frequency * t + phase)
        y = amplitude if s >= 0 else -amplitude
        pts.append([t, y])
    }
    return pts
}

# Triangle wave

def wave_triangle(n, amplitude, frequency, phase=0.0):
{
    pts = []
    for i in (range(n)) {
        t = i / (n - 1)
        # Triangle via arcsin(sin()) approximation
        s = math.sin(2 * math.pi * frequency * t + phase)
        y = (2 / math.pi) * amplitude * math.asin(s)
        pts.append([t, y])
    }
    return pts
}
# Sawtooth wave

def wave_sawtooth(n, amplitude, frequency, phase=0.0):
{
    pts = []
    phi = phase / (2 * math.pi)
    for i in (range(n)) {
        t = i / (n - 1)
        u = frequency * t + phi
        u = u - math.floor(u)
        y = amplitude * (2 * u - 1)
        pts.append([t, y])
    }
    return pts
}

# Noise wave (uniform in [-A, A])

def wave_noise(n, amplitude):
{
    pts = []
    for i in (range(n)) {
        t = i / (n - 1)
        y = amplitude * (random.random() * 2 - 1)
        pts.append([t, y])
    }
    return pts
}

# ADSR envelope (fractions over [0,1])

def envelope_adsr(n, a=0.1, d=0.1, s=0.7, r=0.1):
{
    e = []
    for i in (range(n)) {
        t = 0 if n <= 1 else i / (n - 1)
        val = 0
        if (t <= a) {
            if (a <= 0) { val = 1 }
            else { val = t / a }
        }
        elif (t <= a + d) {
            if (d <= 0) { val = s }
            else {
            
                td = (t - a) / d
                val = 1 - (1 - s) * td
            }
        }
        elif (t <= 1 - r) {
            val = s
        }
        else {
        
            if (r <= 0) { val = 0 }
            else {
            
                tr = (t - (1 - r)) / r
                val = s * (1 - tr)
                if (val < 0) { val = 0 }
            }
        }
        e.append(val)
    }
    return e
}

# Apply envelope list to wave points (scale y)

def apply_envelope(points, env):
{
    n = len(points)
    m = len(env)
    out = []
    for i in (range(n)) {
        t = points[i][0]
        y = points[i][1]
        scale = 1
        if (m > 0) {
            if (i < m) { scale = env[i] }
            else { scale = env[m - 1] }
        }
        out.append([t, y * scale])
    }
    return out
}

# Amplitude modulation

def wave_am(n, amplitude, carrier_freq, mod_freq, depth=0.5, phase=0.0):
{
    pts = []
    for i in (range(n)) {
        t = i / (n - 1)
        mod = 1 + depth * math.sin(2 * math.pi * mod_freq * t)
        y = amplitude * mod * math.sin(2 * math.pi * carrier_freq * t + phase)
        pts.append([t, y])
    }
    return pts
}

# Frequency modulation (beta = modulation index)

def wave_fm(n, amplitude, carrier_freq, mod_freq, beta=1.0, phase=0.0):
{
    pts = []
    for i in (range(n)) {
        t = i / (n - 1)
        y = amplitude * math.sin(2 * math.pi * carrier_freq * t + beta * math.sin(2 * math.pi * mod_freq * t) + phase)
        pts.append([t, y])
    }
    return pts
}


# Map [0,1]x[-A,A] to SVG coordinates (0..w, 0..h) with top-left origin

def _map_point(t, y, w, h, amplitude, margin):
{
    x_px = margin + t * (w - 2 * margin)
    # y: +up in math; SVG +down, center at h/2
    y_px = (h / 2) - (y * ( (h/2 - margin) / amplitude ))
    return [x_px, y_px]
}

# Render wave points to SVG path and axes

def wave_plot_svg(points, w, h, stroke="#e11", stroke_width=2, margin=10, amplitude_guess=None, show_axes=True, fill_area=False, area_fill=None, area_opacity=0.25):
{
    n = len(points)
    if (n == 0) { return svg_wrap(w, h, "") }
    # Estimate amplitude from data if not provided
    if (amplitude_guess is None) {
        amax = 0
        for i in (range(n)) {
            v = abs(points[i][1])
            if (v > amax) { amax = v }
        }
        amplitude_guess = amax if amax > 0 else 1
    }
    pen = pen_new()
    # Build line path
    for i in (range(n)) {
        t = points[i][0]
        y = points[i][1]
        mp = _map_point(t, y, w, h, amplitude_guess, margin)
        if (i == 0) {
            pen_move(pen, mp[0], mp[1])
            x0 = mp[0]
        }
        else {
        
            pen_line(pen, mp[0], mp[1])
        }
        xl = mp[0]
    }
    path = pen_to_path(pen, "none", stroke, stroke_width)

    # Optional area fill under curve to baseline (y=0)
    area_svg = ""
    if (fill_area) {
        apen = pen_new()
        for i in (range(n)) {
            t = points[i][0]
            y = points[i][1]
            mp = _map_point(t, y, w, h, amplitude_guess, margin)
            if (i == 0) {
                pen_move(apen, mp[0], mp[1])
                ax0 = mp[0]
            }
            else {
            
                pen_line(apen, mp[0], mp[1])
            }
            axl = mp[0]
        }
        y_center = h / 2
        pen_line(apen, axl, y_center)
        pen_line(apen, ax0, y_center)
        pen_close(apen)
        afill = area_fill if area_fill is not None else stroke
        apath = pen_to_path(apen, afill, "none", 0)
        area_svg = apath.replace("/>", "" + " fill-opacity='" + str(area_opacity) + "'/")
    }

    # Axes
    axes = ""
    if (show_axes) {
        cx = svg_line(margin, h/2, w - margin, h/2, "#999", 1)
        cy = svg_line(margin, margin, margin, h - margin, "#999", 1)
        axes = cx + cy
    }

    return svg_wrap(w, h, axes + area_svg + path)
}

# Arabic wrappers

def موجة_جيب(نقاط, سعة, تردد, طور=0.0): { return wave_sine(نقاط, سعة, تردد, طور) }

def موجة_مربعة(نقاط, سعة, تردد, طور=0.0): { return wave_square(نقاط, سعة, تردد, طور) }

def موجة_مثلثية(نقاط, سعة, تردد, طور=0.0): { return wave_triangle(نقاط, سعة, تردد, طور) }

def موجة_سن_منشار(نقاط, سعة, تردد, طور=0.0): { return wave_sawtooth(نقاط, سعة, تردد, طور) }

def موجة_ضوضاء(نقاط, سعة): { return wave_noise(نقاط, سعة) }

def مغلف_ADSR(نقاط, هجوم=0.1, اضمحلال=0.1, ثبات=0.7, تحرير=0.1): { return envelope_adsr(نقاط, هجوم, اضمحلال, ثبات, تحرير) }

def تطبيق_مغلف(نقاط, مغلف): { return apply_envelope(نقاط, مغلف) }

def موجة_AM(نقاط, سعة, تردد_حامل, تردد_معدل, عمق=0.5, طور=0.0): { return wave_am(نقاط, سعة, تردد_حامل, تردد_معدل, عمق, طور) }

def موجة_FM(نقاط, سعة, تردد_حامل, تردد_معدل, معامل=1.0, طور=0.0): { return wave_fm(نقاط, سعة, تردد_حامل, تردد_معدل, معامل, طور) }

def رسم_موجة_SVG(نقاط, عرض, ارتفاع, لون="#e11", سماكة=2, هامش=10, سعة_تخمين=None, محاور=True, تعبئة_مساحة=False, لون_مساحة=None, شفافية=0.25): { return wave_plot_svg(نقاط, عرض, ارتفاع, لون, سماكة, هامش, سعة_تخمين, محاور, تعبئة_مساحة, لون_مساحة, شفافية) }

