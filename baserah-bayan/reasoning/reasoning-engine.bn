/**
 * محرك الاستدلال الذكي - Reasoning Engine
 * 
 * نظام استدلال ذكي يعتمد على المعادلات الرياضية
 * بدون شبكات عصبية - Pure Mathematical AI
 * 
 * المطور: باسل يحيى عبدالله
 * جميع الأفكار والنظريات من إبداع باسل يحيى عبدالله
 */

import { MotherEquation } from '../core/mother-equation.bn';

// ============================================
// التعدادات - Enumerations
// ============================================

enum ReasoningType {
    DEDUCTIVE = "deductive",           // استدلال استنتاجي
    INDUCTIVE = "inductive",           // استدلال استقرائي
    ABDUCTIVE = "abductive",           // استدلال اختطافي
    ANALOGICAL = "analogical",         // استدلال تشبيهي
    CAUSAL = "causal",                 // استدلال سببي
    STATISTICAL = "statistical",       // استدلال إحصائي
    TEMPORAL = "temporal",             // استدلال زمني
    SPATIAL = "spatial"                // استدلال مكاني
}

enum ReasoningConfidence {
    VERY_LOW = "very_low",       // 0-0.2
    LOW = "low",                 // 0.2-0.4
    MEDIUM = "medium",           // 0.4-0.6
    HIGH = "high",               // 0.6-0.8
    VERY_HIGH = "very_high"      // 0.8-1.0
}

enum InferenceMethod {
    FORWARD_CHAINING = "forward_chaining",     // التسلسل الأمامي
    BACKWARD_CHAINING = "backward_chaining",   // التسلسل الخلفي
    RESOLUTION = "resolution",                 // الحل
    UNIFICATION = "unification",               // التوحيد
    MODUS_PONENS = "modus_ponens",            // القياس المنطقي
    MODUS_TOLLENS = "modus_tollens",          // النفي بالنفي
    HYPOTHETICAL = "hypothetical",             // الافتراضي
    DISJUNCTIVE = "disjunctive"               // الفصلي
}

enum ReasoningStrategy {
    DEPTH_FIRST = "depth_first",       // العمق أولاً
    BREADTH_FIRST = "breadth_first",   // العرض أولاً
    BEST_FIRST = "best_first",         // الأفضل أولاً
    HEURISTIC = "heuristic",           // الاستدلالي
    PROBABILISTIC = "probabilistic",   // الاحتمالي
    FUZZY = "fuzzy",                   // الضبابي
    HYBRID = "hybrid"                  // الهجين
}

// ============================================
// الفئات الأساسية - Core Classes
// ============================================

/**
 * فئة الحقيقة - Fact
 * تمثل حقيقة في نظام الاستدلال
 */
class Fact extends MotherEquation {
    public factId: string;
    public predicate: string;           // المحمول
    public subject: string;             // الموضوع
    public object: any;                 // المفعول
    public confidence: number;          // الثقة (0-1)
    public timestamp: Date;
    public source: string;
    public metadata: object;
    
    constructor(factId: string, predicate: string, subject: string, object: any, confidence: number = 1.0) {
        super(`fact_${factId}`);
        this.factId = factId;
        this.predicate = predicate;
        this.subject = subject;
        this.object = object;
        this.confidence = confidence;
        this.timestamp = new Date();
        this.source = "user_input";
        this.metadata = {};
        
        // Φ: الخصائص الثابتة
        this.fixedProperties = {
            factId: this.factId,
            predicate: this.predicate,
            subject: this.subject,
            object: this.object
        };
        
        // Ψ: الحالات الديناميكية
        this.dynamicStates = {
            confidence: this.confidence,
            timestamp: this.timestamp,
            source: this.source
        };
    }
    
    public toString(): string {
        return `${this.subject} ${this.predicate} ${this.object}`;
    }
    
    public updateConfidence(newConfidence: number): void {
        this.confidence = Math.max(0, Math.min(1, newConfidence));
        this.dynamicStates.confidence = this.confidence;
    }
}

/**
 * فئة القاعدة - Rule
 * تمثل قاعدة استدلال
 */
class Rule extends MotherEquation {
    public ruleId: string;
    public name: string;
    public conditions: array<object>;   // الشروط
    public conclusions: array<object>;  // الاستنتاجات
    public confidence: number;
    public priority: number;
    public applicationsCount: number;
    
    constructor(ruleId: string, name: string, conditions: array<object>, conclusions: array<object>) {
        super(`rule_${ruleId}`);
        this.ruleId = ruleId;
        this.name = name;
        this.conditions = conditions;
        this.conclusions = conclusions;
        this.confidence = 1.0;
        this.priority = 1;
        this.applicationsCount = 0;
        
        // Φ: الخصائص الثابتة
        this.fixedProperties = {
            ruleId: this.ruleId,
            name: this.name,
            conditions: this.conditions,
            conclusions: this.conclusions
        };
        
        // Ψ: الحالات الديناميكية
        this.dynamicStates = {
            confidence: this.confidence,
            priority: this.priority,
            applicationsCount: this.applicationsCount
        };
    }
    
    public canApply(facts: array<Fact>): boolean {
        // التحقق من إمكانية تطبيق القاعدة
        for (let condition of this.conditions) {
            let found = false;
            for (let fact of facts) {
                if (this.matchCondition(fact, condition)) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                return false;
            }
        }
        return true;
    }
    
    private matchCondition(fact: Fact, condition: object): boolean {
        // مطابقة الحقيقة مع الشرط
        if (condition.predicate && fact.predicate !== condition.predicate) {
            return false;
        }
        if (condition.subject && fact.subject !== condition.subject) {
            return false;
        }
        if (condition.object && fact.object !== condition.object) {
            return false;
        }
        return true;
    }
    
    public apply(facts: array<Fact>): array<Fact> {
        // تطبيق القاعدة وإنتاج حقائق جديدة
        let newFacts = [];
        
        if (this.canApply(facts)) {
            for (let conclusion of this.conclusions) {
                let newFact = new Fact(
                    `inferred_${Date.now()}_${Math.random()}`,
                    conclusion.predicate,
                    conclusion.subject,
                    conclusion.object,
                    this.confidence
                );
                newFact.source = `rule_${this.ruleId}`;
                newFacts.push(newFact);
            }
            
            this.applicationsCount++;
            this.dynamicStates.applicationsCount = this.applicationsCount;
        }
        
        return newFacts;
    }
}

/**
 * فئة الاستنتاج - Inference
 * تمثل عملية استنتاج
 */
class Inference extends MotherEquation {
    public inferenceId: string;
    public type: ReasoningType;
    public method: InferenceMethod;
    public premises: array<Fact>;       // المقدمات
    public conclusion: Fact;            // الاستنتاج
    public confidence: number;
    public steps: array<object>;        // خطوات الاستنتاج
    public timestamp: Date;
    
    constructor(inferenceId: string, type: ReasoningType, method: InferenceMethod) {
        super(`inference_${inferenceId}`);
        this.inferenceId = inferenceId;
        this.type = type;
        this.method = method;
        this.premises = [];
        this.conclusion = null;
        this.confidence = 0;
        this.steps = [];
        this.timestamp = new Date();
        
        // Φ: الخصائص الثابتة
        this.fixedProperties = {
            inferenceId: this.inferenceId,
            type: this.type,
            method: this.method
        };
        
        // Ψ: الحالات الديناميكية
        this.dynamicStates = {
            premises: this.premises,
            conclusion: this.conclusion,
            confidence: this.confidence,
            steps: this.steps
        };
    }
    
    public addPremise(fact: Fact): void {
        this.premises.push(fact);
        this.dynamicStates.premises = this.premises;
    }
    
    public setConclusion(fact: Fact): void {
        this.conclusion = fact;
        this.dynamicStates.conclusion = this.conclusion;
        
        // حساب الثقة بناءً على المقدمات
        this.calculateConfidence();
    }
    
    private calculateConfidence(): void {
        if (this.premises.length === 0) {
            this.confidence = 0;
            return;
        }
        
        // حساب الثقة كمتوسط ثقة المقدمات
        let sum = 0;
        for (let premise of this.premises) {
            sum += premise.confidence;
        }
        this.confidence = sum / this.premises.length;
        this.dynamicStates.confidence = this.confidence;
    }
    
    public addStep(description: string, data: object): void {
        this.steps.push({
            stepNumber: this.steps.length + 1,
            description: description,
            data: data,
            timestamp: new Date()
        });
        this.dynamicStates.steps = this.steps;
    }
}

/**
 * فئة محرك الاستدلال - Reasoning Engine
 * المحرك الرئيسي للاستدلال
 */
class ReasoningEngine extends MotherEquation {
    public facts: array<Fact>;
    public rules: array<Rule>;
    public inferences: array<Inference>;
    public strategy: ReasoningStrategy;
    public maxIterations: number;
    public currentIteration: number;
    
    constructor() {
        super("reasoning_engine_main");
        this.facts = [];
        this.rules = [];
        this.inferences = [];
        this.strategy = ReasoningStrategy.FORWARD_CHAINING;
        this.maxIterations = 100;
        this.currentIteration = 0;
        
        // Φ: الخصائص الثابتة
        this.fixedProperties = {
            engineType: "mathematical_reasoning",
            version: "1.0.0"
        };
        
        // Ψ: الحالات الديناميكية
        this.dynamicStates = {
            factsCount: 0,
            rulesCount: 0,
            inferencesCount: 0,
            strategy: this.strategy,
            currentIteration: 0
        };
    }

    // ============================================
    // إدارة الحقائق - Facts Management
    // ============================================

    public addFact(fact: Fact): void {
        this.facts.push(fact);
        this.dynamicStates.factsCount = this.facts.length;
    }

    public addFactFromData(predicate: string, subject: string, object: any, confidence: number = 1.0): Fact {
        let fact = new Fact(`fact_${Date.now()}_${this.facts.length}`, predicate, subject, object, confidence);
        this.addFact(fact);
        return fact;
    }

    public getFacts(predicate: string = null): array<Fact> {
        if (predicate === null) {
            return this.facts;
        }

        let filtered = [];
        for (let fact of this.facts) {
            if (fact.predicate === predicate) {
                filtered.push(fact);
            }
        }
        return filtered;
    }

    public findFact(subject: string, predicate: string): Fact {
        for (let fact of this.facts) {
            if (fact.subject === subject && fact.predicate === predicate) {
                return fact;
            }
        }
        return null;
    }

    // ============================================
    // إدارة القواعد - Rules Management
    // ============================================

    public addRule(rule: Rule): void {
        this.rules.push(rule);
        this.dynamicStates.rulesCount = this.rules.length;
    }

    public createRule(name: string, conditions: array<object>, conclusions: array<object>): Rule {
        let rule = new Rule(`rule_${Date.now()}_${this.rules.length}`, name, conditions, conclusions);
        this.addRule(rule);
        return rule;
    }

    // ============================================
    // محركات الاستدلال - Reasoning Engines
    // ============================================

    /**
     * التسلسل الأمامي - Forward Chaining
     * يبدأ من الحقائق ويطبق القواعد للوصول إلى استنتاجات
     */
    public forwardChaining(): array<Fact> {
        let newFacts = [];
        let iteration = 0;
        let changed = true;

        while (changed && iteration < this.maxIterations) {
            changed = false;
            iteration++;
            this.currentIteration = iteration;

            for (let rule of this.rules) {
                if (rule.canApply(this.facts)) {
                    let inferred = rule.apply(this.facts);

                    for (let fact of inferred) {
                        // التحقق من عدم وجود الحقيقة مسبقاً
                        if (!this.factExists(fact)) {
                            this.addFact(fact);
                            newFacts.push(fact);
                            changed = true;

                            // تسجيل الاستنتاج
                            let inference = new Inference(
                                `inf_${Date.now()}_${this.inferences.length}`,
                                ReasoningType.DEDUCTIVE,
                                InferenceMethod.FORWARD_CHAINING
                            );
                            inference.setConclusion(fact);
                            inference.addStep("Applied rule", { ruleId: rule.ruleId, ruleName: rule.name });
                            this.inferences.push(inference);
                        }
                    }
                }
            }
        }

        this.dynamicStates.currentIteration = this.currentIteration;
        this.dynamicStates.inferencesCount = this.inferences.length;

        return newFacts;
    }

    /**
     * التسلسل الخلفي - Backward Chaining
     * يبدأ من الهدف ويبحث عن الحقائق والقواعد التي تدعمه
     */
    public backwardChaining(goal: object): boolean {
        // التحقق من وجود الهدف في الحقائق
        for (let fact of this.facts) {
            if (this.matchGoal(fact, goal)) {
                return true;
            }
        }

        // البحث عن قاعدة تنتج الهدف
        for (let rule of this.rules) {
            for (let conclusion of rule.conclusions) {
                if (this.matchGoal(conclusion, goal)) {
                    // التحقق من شروط القاعدة
                    let allConditionsMet = true;
                    for (let condition of rule.conditions) {
                        if (!this.backwardChaining(condition)) {
                            allConditionsMet = false;
                            break;
                        }
                    }

                    if (allConditionsMet) {
                        return true;
                    }
                }
            }
        }

        return false;
    }

    private matchGoal(fact: any, goal: object): boolean {
        if (goal.predicate && fact.predicate !== goal.predicate) {
            return false;
        }
        if (goal.subject && fact.subject !== goal.subject) {
            return false;
        }
        if (goal.object && fact.object !== goal.object) {
            return false;
        }
        return true;
    }

    private factExists(newFact: Fact): boolean {
        for (let fact of this.facts) {
            if (fact.predicate === newFact.predicate &&
                fact.subject === newFact.subject &&
                fact.object === newFact.object) {
                return true;
            }
        }
        return false;
    }

    // ============================================
    // الاستدلال الاستقرائي - Inductive Reasoning
    // ============================================

    public inductiveReasoning(observations: array<Fact>): Fact {
        // استخراج نمط من الملاحظات
        if (observations.length < 2) {
            return null;
        }

        // البحث عن نمط مشترك
        let commonPredicate = observations[0].predicate;
        let allSame = true;

        for (let obs of observations) {
            if (obs.predicate !== commonPredicate) {
                allSame = false;
                break;
            }
        }

        if (allSame) {
            // إنشاء قاعدة عامة
            let generalFact = new Fact(
                `induced_${Date.now()}`,
                commonPredicate,
                "all",
                observations[0].object,
                0.7  // ثقة متوسطة للاستدلال الاستقرائي
            );
            generalFact.source = "inductive_reasoning";

            // تسجيل الاستنتاج
            let inference = new Inference(
                `inf_${Date.now()}_${this.inferences.length}`,
                ReasoningType.INDUCTIVE,
                InferenceMethod.HYPOTHETICAL
            );

            for (let obs of observations) {
                inference.addPremise(obs);
            }
            inference.setConclusion(generalFact);
            inference.addStep("Generalized pattern", { observationsCount: observations.length });
            this.inferences.push(inference);

            return generalFact;
        }

        return null;
    }

    // ============================================
    // الاستدلال التشبيهي - Analogical Reasoning
    // ============================================

    public analogicalReasoning(source: object, target: object): Fact {
        // الاستدلال بالتشبيه بين مصدر وهدف
        let sourceFacts = this.getFacts(source.predicate);

        if (sourceFacts.length > 0) {
            // إنشاء حقيقة جديدة بالتشبيه
            let analogyFact = new Fact(
                `analogy_${Date.now()}`,
                target.predicate || source.predicate,
                target.subject,
                sourceFacts[0].object,
                0.6  // ثقة متوسطة للاستدلال التشبيهي
            );
            analogyFact.source = "analogical_reasoning";

            // تسجيل الاستنتاج
            let inference = new Inference(
                `inf_${Date.now()}_${this.inferences.length}`,
                ReasoningType.ANALOGICAL,
                InferenceMethod.HYPOTHETICAL
            );
            inference.addPremise(sourceFacts[0]);
            inference.setConclusion(analogyFact);
            inference.addStep("Applied analogy", { source: source, target: target });
            this.inferences.push(inference);

            return analogyFact;
        }

        return null;
    }

    // ============================================
    // الإحصائيات - Statistics
    // ============================================

    public getStatistics(): object {
        return {
            factsCount: this.facts.length,
            rulesCount: this.rules.length,
            inferencesCount: this.inferences.length,
            currentIteration: this.currentIteration,
            strategy: this.strategy,
            averageConfidence: this.calculateAverageConfidence(),
            inferencesByType: this.getInferencesByType()
        };
    }

    private calculateAverageConfidence(): number {
        if (this.facts.length === 0) {
            return 0;
        }

        let sum = 0;
        for (let fact of this.facts) {
            sum += fact.confidence;
        }
        return sum / this.facts.length;
    }

    private getInferencesByType(): object {
        let counts = {};
        for (let inference of this.inferences) {
            let type = inference.type;
            if (!counts[type]) {
                counts[type] = 0;
            }
            counts[type]++;
        }
        return counts;
    }

    public reset(): void {
        this.facts = [];
        this.rules = [];
        this.inferences = [];
        this.currentIteration = 0;
        this.dynamicStates.factsCount = 0;
        this.dynamicStates.rulesCount = 0;
        this.dynamicStates.inferencesCount = 0;
        this.dynamicStates.currentIteration = 0;
    }
}

// ============================================
// التصدير - Exports
// ============================================

export {
    ReasoningType,
    ReasoningConfidence,
    InferenceMethod,
    ReasoningStrategy,
    Fact,
    Rule,
    Inference,
    ReasoningEngine
};

