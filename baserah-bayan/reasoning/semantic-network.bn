/**
 * الشبكة الدلالية - Semantic Network
 * 
 * نظام شبكة دلالية لتمثيل المعرفة والعلاقات
 * بدون شبكات عصبية - Pure Mathematical AI
 * 
 * المطور: باسل يحيى عبدالله
 * جميع الأفكار والنظريات من إبداع باسل يحيى عبدالله
 */

import { MotherEquation } from '../core/mother-equation.bn';

// ============================================
// التعدادات - Enumerations
// ============================================

enum NodeType {
    CONCEPT = "concept",           // مفهوم
    ENTITY = "entity",             // كيان
    EVENT = "event",               // حدث
    PROPERTY = "property",         // خاصية
    ACTION = "action",             // فعل
    STATE = "state",               // حالة
    RELATION = "relation",         // علاقة
    CATEGORY = "category"          // فئة
}

enum RelationType {
    IS_A = "is_a",                     // هو نوع من
    PART_OF = "part_of",               // جزء من
    HAS_PROPERTY = "has_property",     // له خاصية
    CAUSES = "causes",                 // يسبب
    REQUIRES = "requires",             // يتطلب
    SIMILAR_TO = "similar_to",         // مشابه لـ
    OPPOSITE_OF = "opposite_of",       // عكس
    ASSOCIATED_WITH = "associated_with", // مرتبط بـ
    LOCATED_IN = "located_in",         // موجود في
    USED_FOR = "used_for",             // يستخدم لـ
    CREATED_BY = "created_by",         // أنشئ بواسطة
    TEMPORAL = "temporal"              // زمني
}

enum TraversalMethod {
    DEPTH_FIRST = "depth_first",       // العمق أولاً
    BREADTH_FIRST = "breadth_first",   // العرض أولاً
    SHORTEST_PATH = "shortest_path",   // أقصر مسار
    ALL_PATHS = "all_paths"            // جميع المسارات
}

enum ActivationSpread {
    LINEAR = "linear",                 // خطي
    EXPONENTIAL = "exponential",       // أسي
    SIGMOID = "sigmoid",               // سيغمويد
    THRESHOLD = "threshold"            // عتبة
}

// ============================================
// الفئات الأساسية - Core Classes
// ============================================

/**
 * فئة العقدة - Node
 * تمثل عقدة في الشبكة الدلالية
 */
class SemanticNode extends MotherEquation {
    public nodeId: string;
    public label: string;
    public type: NodeType;
    public properties: object;
    public activation: number;          // مستوى التنشيط (0-1)
    public importance: number;          // الأهمية (0-1)
    public metadata: object;
    
    constructor(nodeId: string, label: string, type: NodeType) {
        super(`node_${nodeId}`);
        this.nodeId = nodeId;
        this.label = label;
        this.type = type;
        this.properties = {};
        this.activation = 0;
        this.importance = 0.5;
        this.metadata = {};
        
        // Φ: الخصائص الثابتة
        this.fixedProperties = {
            nodeId: this.nodeId,
            label: this.label,
            type: this.type
        };
        
        // Ψ: الحالات الديناميكية
        this.dynamicStates = {
            activation: this.activation,
            importance: this.importance,
            properties: this.properties
        };
    }
    
    public setProperty(key: string, value: any): void {
        this.properties[key] = value;
        this.dynamicStates.properties = this.properties;
    }
    
    public activate(level: number): void {
        this.activation = Math.max(0, Math.min(1, level));
        this.dynamicStates.activation = this.activation;
    }
    
    public decay(rate: number = 0.1): void {
        this.activation = Math.max(0, this.activation - rate);
        this.dynamicStates.activation = this.activation;
    }
}

/**
 * فئة الحافة - Edge
 * تمثل علاقة بين عقدتين
 */
class SemanticEdge extends MotherEquation {
    public edgeId: string;
    public sourceId: string;
    public targetId: string;
    public relationType: RelationType;
    public weight: number;              // وزن العلاقة (0-1)
    public bidirectional: boolean;
    public properties: object;
    
    constructor(edgeId: string, sourceId: string, targetId: string, relationType: RelationType, weight: number = 1.0) {
        super(`edge_${edgeId}`);
        this.edgeId = edgeId;
        this.sourceId = sourceId;
        this.targetId = targetId;
        this.relationType = relationType;
        this.weight = weight;
        this.bidirectional = false;
        this.properties = {};
        
        // Φ: الخصائص الثابتة
        this.fixedProperties = {
            edgeId: this.edgeId,
            sourceId: this.sourceId,
            targetId: this.targetId,
            relationType: this.relationType
        };
        
        // Ψ: الحالات الديناميكية
        this.dynamicStates = {
            weight: this.weight,
            bidirectional: this.bidirectional
        };
    }
    
    public setWeight(weight: number): void {
        this.weight = Math.max(0, Math.min(1, weight));
        this.dynamicStates.weight = this.weight;
    }
}

/**
 * فئة الشبكة الدلالية - Semantic Network
 * الشبكة الرئيسية
 */
class SemanticNetwork extends MotherEquation {
    public nodes: object;               // خريطة العقد
    public edges: array<SemanticEdge>;
    public adjacencyList: object;       // قائمة الجوار
    public activationHistory: array<object>;
    
    constructor() {
        super("semantic_network_main");
        this.nodes = {};
        this.edges = [];
        this.adjacencyList = {};
        this.activationHistory = [];
        
        // Φ: الخصائص الثابتة
        this.fixedProperties = {
            networkType: "semantic",
            version: "1.0.0"
        };
        
        // Ψ: الحالات الديناميكية
        this.dynamicStates = {
            nodesCount: 0,
            edgesCount: 0,
            averageActivation: 0
        };
    }
    
    // ============================================
    // إدارة العقد - Nodes Management
    // ============================================
    
    public addNode(node: SemanticNode): void {
        this.nodes[node.nodeId] = node;
        this.adjacencyList[node.nodeId] = [];
        this.dynamicStates.nodesCount = Object.keys(this.nodes).length;
    }
    
    public createNode(label: string, type: NodeType): SemanticNode {
        let nodeId = `node_${Date.now()}_${Object.keys(this.nodes).length}`;
        let node = new SemanticNode(nodeId, label, type);
        this.addNode(node);
        return node;
    }
    
    public getNode(nodeId: string): SemanticNode {
        return this.nodes[nodeId];
    }
    
    public findNodeByLabel(label: string): SemanticNode {
        for (let nodeId in this.nodes) {
            if (this.nodes[nodeId].label === label) {
                return this.nodes[nodeId];
            }
        }
        return null;
    }
    
    public getNodesByType(type: NodeType): array<SemanticNode> {
        let result = [];
        for (let nodeId in this.nodes) {
            if (this.nodes[nodeId].type === type) {
                result.push(this.nodes[nodeId]);
            }
        }
        return result;
    }
    
    // ============================================
    // إدارة الحواف - Edges Management
    // ============================================
    
    public addEdge(edge: SemanticEdge): void {
        this.edges.push(edge);
        
        // تحديث قائمة الجوار
        if (!this.adjacencyList[edge.sourceId]) {
            this.adjacencyList[edge.sourceId] = [];
        }
        this.adjacencyList[edge.sourceId].push({
            targetId: edge.targetId,
            edge: edge
        });
        
        // إذا كانت العلاقة ثنائية الاتجاه
        if (edge.bidirectional) {
            if (!this.adjacencyList[edge.targetId]) {
                this.adjacencyList[edge.targetId] = [];
            }
            this.adjacencyList[edge.targetId].push({
                targetId: edge.sourceId,
                edge: edge
            });
        }
        
        this.dynamicStates.edgesCount = this.edges.length;
    }
    
    public createEdge(sourceId: string, targetId: string, relationType: RelationType, weight: number = 1.0): SemanticEdge {
        let edgeId = `edge_${Date.now()}_${this.edges.length}`;
        let edge = new SemanticEdge(edgeId, sourceId, targetId, relationType, weight);
        this.addEdge(edge);
        return edge;
    }
    
    public getEdgesBetween(sourceId: string, targetId: string): array<SemanticEdge> {
        let result = [];
        for (let edge of this.edges) {
            if (edge.sourceId === sourceId && edge.targetId === targetId) {
                result.push(edge);
            }
        }
        return result;
    }
    
    public getEdgesByType(relationType: RelationType): array<SemanticEdge> {
        let result = [];
        for (let edge of this.edges) {
            if (edge.relationType === relationType) {
                result.push(edge);
            }
        }
        return result;
    }

    // ============================================
    // البحث والاستعلام - Search and Query
    // ============================================

    /**
     * البحث عن مسار بين عقدتين
     */
    public findPath(sourceId: string, targetId: string, method: TraversalMethod = TraversalMethod.BREADTH_FIRST): array<string> {
        if (method === TraversalMethod.BREADTH_FIRST) {
            return this.breadthFirstSearch(sourceId, targetId);
        } else if (method === TraversalMethod.DEPTH_FIRST) {
            return this.depthFirstSearch(sourceId, targetId);
        }
        return [];
    }

    private breadthFirstSearch(sourceId: string, targetId: string): array<string> {
        let queue = [{ nodeId: sourceId, path: [sourceId] }];
        let visited = {};
        visited[sourceId] = true;

        while (queue.length > 0) {
            let current = queue.shift();

            if (current.nodeId === targetId) {
                return current.path;
            }

            let neighbors = this.adjacencyList[current.nodeId] || [];
            for (let neighbor of neighbors) {
                if (!visited[neighbor.targetId]) {
                    visited[neighbor.targetId] = true;
                    let newPath = [...current.path, neighbor.targetId];
                    queue.push({ nodeId: neighbor.targetId, path: newPath });
                }
            }
        }

        return [];
    }

    private depthFirstSearch(sourceId: string, targetId: string): array<string> {
        let visited = {};
        let path = [];

        let dfs = (nodeId: string): boolean => {
            visited[nodeId] = true;
            path.push(nodeId);

            if (nodeId === targetId) {
                return true;
            }

            let neighbors = this.adjacencyList[nodeId] || [];
            for (let neighbor of neighbors) {
                if (!visited[neighbor.targetId]) {
                    if (dfs(neighbor.targetId)) {
                        return true;
                    }
                }
            }

            path.pop();
            return false;
        };

        if (dfs(sourceId)) {
            return path;
        }
        return [];
    }

    /**
     * البحث عن جميع الجيران
     */
    public getNeighbors(nodeId: string, relationType: RelationType = null): array<SemanticNode> {
        let neighbors = [];
        let adjacentNodes = this.adjacencyList[nodeId] || [];

        for (let adj of adjacentNodes) {
            if (relationType === null || adj.edge.relationType === relationType) {
                let node = this.getNode(adj.targetId);
                if (node) {
                    neighbors.push(node);
                }
            }
        }

        return neighbors;
    }

    /**
     * البحث عن العقد المرتبطة بعلاقة معينة
     */
    public getRelatedNodes(nodeId: string, relationType: RelationType, depth: number = 1): array<SemanticNode> {
        let result = [];
        let visited = {};

        let explore = (currentId: string, currentDepth: number): void => {
            if (currentDepth > depth || visited[currentId]) {
                return;
            }

            visited[currentId] = true;
            let neighbors = this.getNeighbors(currentId, relationType);

            for (let neighbor of neighbors) {
                if (!visited[neighbor.nodeId]) {
                    result.push(neighbor);
                    explore(neighbor.nodeId, currentDepth + 1);
                }
            }
        };

        explore(nodeId, 0);
        return result;
    }

    // ============================================
    // انتشار التنشيط - Activation Spreading
    // ============================================

    /**
     * تنشيط عقدة ونشر التنشيط للعقد المجاورة
     */
    public activateNode(nodeId: string, initialActivation: number = 1.0, spreadMethod: ActivationSpread = ActivationSpread.LINEAR): void {
        let node = this.getNode(nodeId);
        if (!node) {
            return;
        }

        // تنشيط العقدة الأولية
        node.activate(initialActivation);

        // نشر التنشيط
        this.spreadActivation(nodeId, initialActivation, spreadMethod, 0, 3);

        // حفظ في السجل
        this.activationHistory.push({
            nodeId: nodeId,
            activation: initialActivation,
            timestamp: new Date(),
            method: spreadMethod
        });

        this.updateAverageActivation();
    }

    private spreadActivation(nodeId: string, activation: number, method: ActivationSpread, depth: number, maxDepth: number): void {
        if (depth >= maxDepth || activation < 0.01) {
            return;
        }

        let neighbors = this.adjacencyList[nodeId] || [];

        for (let neighbor of neighbors) {
            let edge = neighbor.edge;
            let targetNode = this.getNode(neighbor.targetId);

            if (targetNode) {
                // حساب التنشيط الجديد بناءً على الطريقة
                let newActivation = this.calculateSpreadActivation(activation, edge.weight, depth, method);

                // تنشيط العقدة المجاورة
                let currentActivation = targetNode.activation;
                targetNode.activate(Math.min(1, currentActivation + newActivation));

                // الاستمرار في النشر
                this.spreadActivation(neighbor.targetId, newActivation, method, depth + 1, maxDepth);
            }
        }
    }

    private calculateSpreadActivation(activation: number, weight: number, depth: number, method: ActivationSpread): number {
        let baseActivation = activation * weight;

        if (method === ActivationSpread.LINEAR) {
            return baseActivation * (1 - depth * 0.2);
        } else if (method === ActivationSpread.EXPONENTIAL) {
            return baseActivation * Math.exp(-depth * 0.5);
        } else if (method === ActivationSpread.SIGMOID) {
            return baseActivation / (1 + Math.exp(depth - 2));
        } else if (method === ActivationSpread.THRESHOLD) {
            return baseActivation > 0.3 ? baseActivation * 0.8 : 0;
        }

        return baseActivation;
    }

    /**
     * تقليل التنشيط لجميع العقد (الاضمحلال)
     */
    public decayAllActivations(rate: number = 0.1): void {
        for (let nodeId in this.nodes) {
            this.nodes[nodeId].decay(rate);
        }
        this.updateAverageActivation();
    }

    /**
     * إعادة تعيين جميع التنشيطات
     */
    public resetActivations(): void {
        for (let nodeId in this.nodes) {
            this.nodes[nodeId].activate(0);
        }
        this.activationHistory = [];
        this.dynamicStates.averageActivation = 0;
    }

    private updateAverageActivation(): void {
        let sum = 0;
        let count = 0;

        for (let nodeId in this.nodes) {
            sum += this.nodes[nodeId].activation;
            count++;
        }

        this.dynamicStates.averageActivation = count > 0 ? sum / count : 0;
    }

    // ============================================
    // الاستدلال الدلالي - Semantic Reasoning
    // ============================================

    /**
     * الاستدلال بالتشابه
     */
    public findSimilarConcepts(nodeId: string, threshold: number = 0.5): array<SemanticNode> {
        let similar = [];
        let sourceNode = this.getNode(nodeId);

        if (!sourceNode) {
            return similar;
        }

        // البحث عن العقد المرتبطة بعلاقة "مشابه لـ"
        let directlySimilar = this.getNeighbors(nodeId, RelationType.SIMILAR_TO);
        similar = similar.concat(directlySimilar);

        // البحث عن العقد التي تشترك في نفس الفئة
        let sameCategory = this.getNeighbors(nodeId, RelationType.IS_A);
        for (let categoryNode of sameCategory) {
            let siblings = this.getRelatedNodes(categoryNode.nodeId, RelationType.IS_A, 1);
            similar = similar.concat(siblings);
        }

        return similar;
    }

    /**
     * الاستدلال السببي
     */
    public findCausalChain(effectNodeId: string): array<SemanticNode> {
        let chain = [];
        let current = effectNodeId;
        let visited = {};

        while (current && !visited[current]) {
            visited[current] = true;
            let node = this.getNode(current);
            if (node) {
                chain.unshift(node);
            }

            // البحث عن السبب
            let causes = this.getNeighbors(current, RelationType.CAUSES);
            if (causes.length > 0) {
                current = causes[0].nodeId;
            } else {
                break;
            }
        }

        return chain;
    }

    // ============================================
    // الإحصائيات - Statistics
    // ============================================

    public getStatistics(): object {
        return {
            nodesCount: Object.keys(this.nodes).length,
            edgesCount: this.edges.length,
            averageActivation: this.dynamicStates.averageActivation,
            nodesByType: this.getNodeCountsByType(),
            edgesByType: this.getEdgeCountsByType(),
            averageDegree: this.calculateAverageDegree(),
            activationHistoryLength: this.activationHistory.length
        };
    }

    private getNodeCountsByType(): object {
        let counts = {};
        for (let nodeId in this.nodes) {
            let type = this.nodes[nodeId].type;
            if (!counts[type]) {
                counts[type] = 0;
            }
            counts[type]++;
        }
        return counts;
    }

    private getEdgeCountsByType(): object {
        let counts = {};
        for (let edge of this.edges) {
            let type = edge.relationType;
            if (!counts[type]) {
                counts[type] = 0;
            }
            counts[type]++;
        }
        return counts;
    }

    private calculateAverageDegree(): number {
        let totalDegree = 0;
        for (let nodeId in this.adjacencyList) {
            totalDegree += this.adjacencyList[nodeId].length;
        }
        let nodesCount = Object.keys(this.nodes).length;
        return nodesCount > 0 ? totalDegree / nodesCount : 0;
    }

    public reset(): void {
        this.nodes = {};
        this.edges = [];
        this.adjacencyList = {};
        this.activationHistory = [];
        this.dynamicStates.nodesCount = 0;
        this.dynamicStates.edgesCount = 0;
        this.dynamicStates.averageActivation = 0;
    }
}

// ============================================
// التصدير - Exports
// ============================================

export {
    NodeType,
    RelationType,
    TraversalMethod,
    ActivationSpread,
    SemanticNode,
    SemanticEdge,
    SemanticNetwork
};

