/**
 * Ø°Ø§ÙƒØ±Ø© Ø§Ù„Ø£Ø­Ø¯Ø§Ø« - Episodic Memory System
 * 
 * ØªØ­ÙØ¸ ÙˆØªØ³ØªØ±Ø¬Ø¹ Ø§Ù„Ø£Ø­Ø¯Ø§Ø« ÙˆØ§Ù„ØªØ¬Ø§Ø±Ø¨ Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©:
 * - Ø§Ù„Ø­ÙˆØ§Ø±Ø§Øª Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©
 * - Ø§Ù„ØªØ¬Ø§Ø±Ø¨ Ø§Ù„Ù…Ù‡Ù…Ø©
 * - Ø§Ù„Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ø²Ù…Ù†ÙŠØ©
 * - Ø§Ù„Ø³ÙŠØ§Ù‚Ø§Øª Ø§Ù„ØªØ§Ø±ÙŠØ®ÙŠØ©
 * 
 * @author Ø¨Ø§Ø³Ù„ ÙŠØ­ÙŠÙ‰ Ø¹Ø¨Ø¯Ø§Ù„Ù„Ù‡
 * @version 1.0.0
 * @date 2025-10-27
 */

import { MotherEquation } from "../core/mother-equation.bn";

/**
 * Ù†ÙˆØ¹ Ø§Ù„Ø­Ø¯Ø«
 */
enum EpisodeType {
    DIALOGUE = "dialogue",
    EVENT = "event",
    EXPERIENCE = "experience",
    LEARNING = "learning",
    INTERACTION = "interaction"
}

/**
 * ÙØ¦Ø© Ø§Ù„Ø­Ø¯Ø« - Episode
 * 
 * ØªÙ…Ø«Ù„ Ø­Ø¯Ø«Ø§Ù‹ Ø£Ùˆ ØªØ¬Ø±Ø¨Ø© ÙˆØ§Ø­Ø¯Ø©
 */
class Episode extends MotherEquation {
    // Ø§Ù„Ù…Ø¹Ø±Ù ÙˆØ§Ù„ÙˆÙ‚Øª
    public episodeId: string;
    public timestamp: Date;
    public episodeType: EpisodeType;
    
    // Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø­Ø¯Ø«
    public content: object;
    
    // Ø§Ù„Ø³ÙŠØ§Ù‚
    public context: object;
    public participants: array<string>;
    public location: string | null;
    
    // Ø§Ù„Ø£Ù‡Ù…ÙŠØ©
    public importance: number;  // 0.0 - 1.0
    public emotionalValence: number;  // -1.0 (Ø³Ù„Ø¨ÙŠ) Ø¥Ù„Ù‰ 1.0 (Ø¥ÙŠØ¬Ø§Ø¨ÙŠ)
    
    // Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª
    public relatedEpisodes: array<string>;
    public tags: array<string>;
    
    // Ø§Ù„Ø§Ø³ØªØ±Ø¬Ø§Ø¹
    public accessCount: number;
    public lastAccessed: Date | null;
    
    /**
     * Ø§Ù„Ù…ÙÙ†Ø´Ø¦
     */
    constructor(
        episodeType: EpisodeType,
        content: object,
        context: object = {},
        participants: array<string> = [],
        importance: number = 0.5
    ) {
        super(`episode_${Date.now()}_${Math.random()}`, {}, {}, null);
        
        this.episodeId = this.id;
        this.timestamp = new Date();
        this.episodeType = episodeType;
        this.content = content;
        this.context = context;
        this.participants = participants;
        this.location = null;
        this.importance = importance;
        this.emotionalValence = 0.0;
        this.relatedEpisodes = [];
        this.tags = [];
        this.accessCount = 0;
        this.lastAccessed = null;
    }
    
    /**
     * ØªØ­Ø¯ÙŠØ« Ø¹Ø¯Ø§Ø¯ Ø§Ù„ÙˆØµÙˆÙ„
     */
    public updateAccess(): void {
        this.accessCount += 1;
        this.lastAccessed = new Date();
    }
    
    /**
     * Ø¥Ø¶Ø§ÙØ© ÙˆØ³Ù…
     */
    public addTag(tag: string): void {
        if (!this.tags.includes(tag)) {
            this.tags.push(tag);
        }
    }
    
    /**
     * Ø±Ø¨Ø· Ø¨Ø­Ø¯Ø« Ø¢Ø®Ø±
     */
    public linkToEpisode(episodeId: string): void {
        if (!this.relatedEpisodes.includes(episodeId)) {
            this.relatedEpisodes.push(episodeId);
        }
    }
    
    /**
     * ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ JSON
     */
    public toJSON(): object {
        return {
            episodeId: this.episodeId,
            timestamp: this.timestamp,
            episodeType: this.episodeType,
            content: this.content,
            context: this.context,
            participants: this.participants,
            location: this.location,
            importance: this.importance,
            emotionalValence: this.emotionalValence,
            relatedEpisodes: this.relatedEpisodes,
            tags: this.tags,
            accessCount: this.accessCount,
            lastAccessed: this.lastAccessed
        };
    }
}

/**
 * ÙØ¦Ø© Ø­Ø¯Ø« Ø§Ù„Ø­ÙˆØ§Ø± - DialogueEpisode
 * 
 * ØªÙ…Ø«Ù„ Ø­Ø¯Ø« Ø­ÙˆØ§Ø± Ø¨ÙŠÙ† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙˆØ§Ù„Ù†Ø¸Ø§Ù…
 */
class DialogueEpisode extends Episode {
    public userInput: string;
    public botResponse: string;
    public intent: string;
    public entities: array<string>;
    public topics: array<string>;
    public success: boolean;
    
    /**
     * Ø§Ù„Ù…ÙÙ†Ø´Ø¦
     */
    constructor(
        userInput: string,
        botResponse: string,
        intent: string = "unknown",
        entities: array<string> = [],
        topics: array<string> = [],
        context: object = {},
        success: boolean = true
    ) {
        let content = {
            userInput: userInput,
            botResponse: botResponse,
            intent: intent,
            entities: entities,
            topics: topics,
            success: success
        };
        
        super(EpisodeType.DIALOGUE, content, context, ["user", "bot"], success ? 0.7 : 0.3);
        
        this.userInput = userInput;
        this.botResponse = botResponse;
        this.intent = intent;
        this.entities = entities;
        this.topics = topics;
        this.success = success;
        
        // Ø¥Ø¶Ø§ÙØ© ÙˆØ³ÙˆÙ…
        for (let topic of topics) {
            this.addTag(topic);
        }
        if (intent !== "unknown") {
            this.addTag(`intent:${intent}`);
        }
    }
}

/**
 * ÙØ¦Ø© Ø°Ø§ÙƒØ±Ø© Ø§Ù„Ø£Ø­Ø¯Ø§Ø« - EpisodicMemory
 * 
 * ØªØ­ÙØ¸ ÙˆØªØ³ØªØ±Ø¬Ø¹ Ø§Ù„Ø£Ø­Ø¯Ø§Ø« ÙˆØ§Ù„ØªØ¬Ø§Ø±Ø¨ Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©
 */
class EpisodicMemory {
    // Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
    private maxEpisodes: number;
    private consolidationThreshold: number;
    
    // Ø§Ù„Ø£Ø­Ø¯Ø§Ø«
    private episodes: Map<string, Episode>;
    private episodeTimeline: array<string>;  // Ù…Ø±ØªØ¨Ø© Ø²Ù…Ù†ÙŠØ§Ù‹
    
    // Ø§Ù„ÙÙ‡Ø§Ø±Ø³ Ù„Ù„Ø¨Ø­Ø« Ø§Ù„Ø³Ø±ÙŠØ¹
    private episodesByType: Map<string, array<string>>;
    private episodesByTag: Map<string, array<string>>;
    private episodesByParticipant: Map<string, array<string>>;
    
    /**
     * Ø§Ù„Ù…ÙÙ†Ø´Ø¦
     */
    constructor(maxEpisodes: number = 1000, consolidationThreshold: number = 100) {
        this.maxEpisodes = maxEpisodes;
        this.consolidationThreshold = consolidationThreshold;
        
        this.episodes = new Map();
        this.episodeTimeline = [];
        
        this.episodesByType = new Map();
        this.episodesByTag = new Map();
        this.episodesByParticipant = new Map();
        
        console.log("âœ… ØªÙ… ØªÙ‡ÙŠØ¦Ø© Ø°Ø§ÙƒØ±Ø© Ø§Ù„Ø£Ø­Ø¯Ø§Ø«");
    }
    
    /**
     * Ø­ÙØ¸ Ø­Ø¯Ø« Ø¬Ø¯ÙŠØ¯
     */
    public storeEpisode(episode: Episode): string {
        // Ø­ÙØ¸ Ø§Ù„Ø­Ø¯Ø«
        this.episodes.set(episode.episodeId, episode);
        this.episodeTimeline.push(episode.episodeId);
        
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙÙ‡Ø§Ø±Ø³
        this.updateIndices(episode);
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø§Ø¬Ø© Ù„Ù„Ø¯Ù…Ø¬
        if (this.episodes.size > this.consolidationThreshold) {
            this.consolidateMemories();
        }
        
        return episode.episodeId;
    }
    
    /**
     * Ø­ÙØ¸ Ø­Ø¯Ø« Ø­ÙˆØ§Ø±
     */
    public storeDialogue(
        userInput: string,
        botResponse: string,
        intent: string = "unknown",
        entities: array<string> = [],
        topics: array<string> = [],
        context: object = {},
        success: boolean = true
    ): string {
        let episode = new DialogueEpisode(
            userInput,
            botResponse,
            intent,
            entities,
            topics,
            context,
            success
        );
        
        return this.storeEpisode(episode);
    }
    
    /**
     * Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø§Ù„Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ø£Ø®ÙŠØ±Ø©
     */
    public retrieveRecent(count: number = 10, episodeType: EpisodeType | null = null): array<Episode> {
        // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ø£Ø®ÙŠØ±Ø©
        let recentIds = this.episodeTimeline.slice(-count);
        let episodes: array<Episode> = [];
        
        for (let eid of recentIds) {
            if (this.episodes.has(eid)) {
                let ep = this.episodes.get(eid);
                
                // ØªØµÙÙŠØ© Ø­Ø³Ø¨ Ø§Ù„Ù†ÙˆØ¹ Ø¥Ø°Ø§ Ø·ÙÙ„Ø¨
                if (episodeType === null || ep.episodeType === episodeType) {
                    ep.updateAccess();
                    episodes.push(ep);
                }
            }
        }
        
        return episodes;
    }
    
    /**
     * Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø§Ù„Ø£Ø­Ø¯Ø§Ø« Ø­Ø³Ø¨ Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹
     */
    public retrieveByTopic(topic: string, maxCount: number = 10): array<Episode> {
        if (!this.episodesByTag.has(topic)) {
            return [];
        }

        let episodeIds = this.episodesByTag.get(topic).slice(-maxCount);
        let episodes: array<Episode> = [];

        for (let eid of episodeIds) {
            if (this.episodes.has(eid)) {
                let ep = this.episodes.get(eid);
                ep.updateAccess();
                episodes.push(ep);
            }
        }

        return episodes;
    }

    /**
     * Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø£Ø­Ø¯Ø§Ø« Ù…Ø´Ø§Ø¨Ù‡Ø©
     */
    public retrieveSimilar(referenceEpisode: Episode, maxCount: number = 5): array<Episode> {
        let similarEpisodes: array<{episode: Episode, similarity: number}> = [];

        for (let [eid, episode] of this.episodes) {
            if (episode.episodeId === referenceEpisode.episodeId) {
                continue;
            }

            // Ø­Ø³Ø§Ø¨ Ø§Ù„ØªØ´Ø§Ø¨Ù‡
            let similarity = this.calculateSimilarity(referenceEpisode, episode);

            if (similarity > 0.3) {  // Ø¹ØªØ¨Ø© Ø§Ù„ØªØ´Ø§Ø¨Ù‡
                similarEpisodes.push({episode: episode, similarity: similarity});
            }
        }

        // ØªØ±ØªÙŠØ¨ Ø­Ø³Ø¨ Ø§Ù„ØªØ´Ø§Ø¨Ù‡
        similarEpisodes.sort((a, b) => b.similarity - a.similarity);

        // Ø¥Ø±Ø¬Ø§Ø¹ Ø§Ù„Ø£Ø­Ø¯Ø§Ø« ÙÙ‚Ø· (Ø¨Ø¯ÙˆÙ† Ø¯Ø±Ø¬Ø© Ø§Ù„ØªØ´Ø§Ø¨Ù‡)
        let result: array<Episode> = [];
        for (let i = 0; i < Math.min(maxCount, similarEpisodes.length); i++) {
            result.push(similarEpisodes[i].episode);
        }

        return result;
    }

    /**
     * Ø­Ø³Ø§Ø¨ Ø§Ù„ØªØ´Ø§Ø¨Ù‡ Ø¨ÙŠÙ† Ø­Ø¯Ø«ÙŠÙ†
     */
    private calculateSimilarity(ep1: Episode, ep2: Episode): number {
        let similarity = 0.0;

        // ØªØ´Ø§Ø¨Ù‡ Ø§Ù„Ù†ÙˆØ¹
        if (ep1.episodeType === ep2.episodeType) {
            similarity += 0.3;
        }

        // ØªØ´Ø§Ø¨Ù‡ Ø§Ù„ÙˆØ³ÙˆÙ…
        let commonTags = ep1.tags.filter(tag => ep2.tags.includes(tag));
        if (ep1.tags.length > 0 && ep2.tags.length > 0) {
            let tagSimilarity = commonTags.length / Math.max(ep1.tags.length, ep2.tags.length);
            similarity += 0.4 * tagSimilarity;
        }

        // ØªØ´Ø§Ø¨Ù‡ Ø§Ù„Ù…Ø´Ø§Ø±ÙƒÙŠÙ†
        let commonParticipants = ep1.participants.filter(p => ep2.participants.includes(p));
        if (ep1.participants.length > 0 && ep2.participants.length > 0) {
            let participantSimilarity = commonParticipants.length / Math.max(ep1.participants.length, ep2.participants.length);
            similarity += 0.3 * participantSimilarity;
        }

        return similarity;
    }

    /**
     * ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙÙ‡Ø§Ø±Ø³
     */
    private updateIndices(episode: Episode): void {
        // ÙÙ‡Ø±Ø³ Ø§Ù„Ù†ÙˆØ¹
        if (!this.episodesByType.has(episode.episodeType)) {
            this.episodesByType.set(episode.episodeType, []);
        }
        this.episodesByType.get(episode.episodeType).push(episode.episodeId);

        // ÙÙ‡Ø±Ø³ Ø§Ù„ÙˆØ³ÙˆÙ…
        for (let tag of episode.tags) {
            if (!this.episodesByTag.has(tag)) {
                this.episodesByTag.set(tag, []);
            }
            this.episodesByTag.get(tag).push(episode.episodeId);
        }

        // ÙÙ‡Ø±Ø³ Ø§Ù„Ù…Ø´Ø§Ø±ÙƒÙŠÙ†
        for (let participant of episode.participants) {
            if (!this.episodesByParticipant.has(participant)) {
                this.episodesByParticipant.set(participant, []);
            }
            this.episodesByParticipant.get(participant).push(episode.episodeId);
        }
    }

    /**
     * Ø¯Ù…Ø¬ Ø§Ù„Ø°ÙƒØ±ÙŠØ§Øª (Ø­Ø°Ù Ø§Ù„Ø£Ù‚Ù„ Ø£Ù‡Ù…ÙŠØ©)
     */
    private consolidateMemories(): void {
        if (this.episodes.size <= this.maxEpisodes) {
            return;
        }

        // ØªØ±ØªÙŠØ¨ Ø§Ù„Ø£Ø­Ø¯Ø§Ø« Ø­Ø³Ø¨ Ø§Ù„Ø£Ù‡Ù…ÙŠØ© ÙˆØ¹Ø¯Ø¯ Ø§Ù„ÙˆØµÙˆÙ„
        let sortedEpisodes: array<{id: string, episode: Episode}> = [];
        for (let [id, episode] of this.episodes) {
            sortedEpisodes.push({id: id, episode: episode});
        }

        sortedEpisodes.sort((a, b) => {
            let scoreA = a.episode.importance + (a.episode.accessCount * 0.1);
            let scoreB = b.episode.importance + (b.episode.accessCount * 0.1);
            return scoreB - scoreA;
        });

        // Ø§Ù„Ø§Ø­ØªÙØ§Ø¸ Ø¨Ø§Ù„Ø£Ù‡Ù… ÙÙ‚Ø·
        let episodesToKeep = new Set<string>();
        for (let i = 0; i < this.maxEpisodes; i++) {
            episodesToKeep.add(sortedEpisodes[i].id);
        }

        // Ø­Ø°Ù Ø§Ù„Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ø£Ù‚Ù„ Ø£Ù‡Ù…ÙŠØ©
        let removedCount = 0;
        for (let [id, episode] of this.episodes) {
            if (!episodesToKeep.has(id)) {
                this.removeEpisode(id);
                removedCount++;
            }
        }

        console.log(`ğŸ§¹ ØªÙ… Ø¯Ù…Ø¬ Ø§Ù„Ø°ÙƒØ±ÙŠØ§Øª: Ø­ÙØ°Ù ${removedCount} Ø­Ø¯Ø«`);
    }

    /**
     * Ø­Ø°Ù Ø­Ø¯Ø«
     */
    private removeEpisode(episodeId: string): void {
        if (!this.episodes.has(episodeId)) {
            return;
        }

        let episode = this.episodes.get(episodeId);

        // Ø­Ø°Ù Ù…Ù† Ø§Ù„ÙÙ‡Ø§Ø±Ø³
        if (this.episodesByType.has(episode.episodeType)) {
            let typeList = this.episodesByType.get(episode.episodeType);
            let index = typeList.indexOf(episodeId);
            if (index > -1) {
                typeList.splice(index, 1);
            }
        }

        for (let tag of episode.tags) {
            if (this.episodesByTag.has(tag)) {
                let tagList = this.episodesByTag.get(tag);
                let index = tagList.indexOf(episodeId);
                if (index > -1) {
                    tagList.splice(index, 1);
                }
            }
        }

        for (let participant of episode.participants) {
            if (this.episodesByParticipant.has(participant)) {
                let participantList = this.episodesByParticipant.get(participant);
                let index = participantList.indexOf(episodeId);
                if (index > -1) {
                    participantList.splice(index, 1);
                }
            }
        }

        // Ø­Ø°Ù Ù…Ù† Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø²Ù…Ù†ÙŠ
        let timelineIndex = this.episodeTimeline.indexOf(episodeId);
        if (timelineIndex > -1) {
            this.episodeTimeline.splice(timelineIndex, 1);
        }

        // Ø­Ø°Ù Ø§Ù„Ø­Ø¯Ø«
        this.episodes.delete(episodeId);
    }

    /**
     * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø°Ø§ÙƒØ±Ø©
     */
    public getStatistics(): object {
        let episodesByType: object = {};
        for (let [type, episodes] of this.episodesByType) {
            episodesByType[type] = episodes.length;
        }

        // Ø§Ù„Ø£ÙƒØ«Ø± ÙˆØµÙˆÙ„Ø§Ù‹
        let allEpisodes: array<Episode> = [];
        for (let [id, episode] of this.episodes) {
            allEpisodes.push(episode);
        }
        allEpisodes.sort((a, b) => b.accessCount - a.accessCount);
        let mostAccessed = allEpisodes.slice(0, 5);

        return {
            totalEpisodes: this.episodes.size,
            episodesByType: episodesByType,
            mostAccessed: mostAccessed.map(ep => ep.toJSON()),
            timelineLength: this.episodeTimeline.length
        };
    }
}

// ØªØµØ¯ÙŠØ± Ø§Ù„ÙØ¦Ø§Øª
export { Episode, DialogueEpisode, EpisodicMemory, EpisodeType };

