/**
 * Ù†Ø¸Ø§Ù… Ø§Ù„ÙˆØ¹ÙŠ Ø§Ù„Ø¢Ù„ÙŠ - Machine Consciousness System
 * ================================================
 * 
 * Ù†Ø¸Ø§Ù… ÙˆØ¹ÙŠ Ø¢Ù„ÙŠ ÙŠØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø§Ù„Ù„ØºÙˆÙŠØ©
 * ÙŠÙÙ‡Ù… Ø§Ù„Ø¬Ù…Ù„ ÙˆÙŠØ­ÙˆÙ„Ù‡Ø§ Ø¥Ù„Ù‰ Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø±ÙŠØ§Ø¶ÙŠØ© ÙˆÙŠØªØªØ¨Ø¹ Ø­Ø§Ù„Ø§Øª Ø§Ù„Ø¹Ø§Ù„Ù…
 * 
 * Ø§Ù„Ù…ÙÙ‡ÙˆÙ…:
 * - Ø§Ù„ÙˆØ¹ÙŠ = Ø§Ù„Ù‚Ø¯Ø±Ø© Ø¹Ù„Ù‰ ØªØªØ¨Ø¹ Ø­Ø§Ù„Ø§Øª Ø§Ù„Ø£Ø´ÙŠØ§Ø¡
 * - Ø§Ù„ÙÙ‡Ù… = Ø§Ù„Ù‚Ø¯Ø±Ø© Ø¹Ù„Ù‰ ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù„ØºØ© Ø¥Ù„Ù‰ Ù…Ø¹Ø§Ø¯Ù„Ø§Øª
 * - Ø§Ù„ØªÙÙƒÙŠØ± = Ø§Ù„Ù‚Ø¯Ø±Ø© Ø¹Ù„Ù‰ Ø§Ø³ØªÙ†ØªØ§Ø¬ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ù…Ù† Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø§Øª
 * 
 * @version 1.0
 * @author Ø¨Ø§Ø³Ù„ ÙŠØ­ÙŠÙ‰ Ø¹Ø¨Ø¯Ø§Ù„Ù„Ù‡
 */

import { MotherEquation } from '../core/mother-equation.bn';
import {
    PropertyDomain,
    ChangeType,
    PropertyState,
    Thing,
    Event,
    Effect,
    LinguisticEquation
} from './linguistic-equations-core.bn';
import { SentenceParser } from './sentence-parser.bn';

/**
 * Ø­Ø§Ù„Ø© Ø§Ù„ÙˆØ¹ÙŠ
 */
enum ConsciousnessState {
    AWAKE = "Ù…Ø³ØªÙŠÙ‚Ø¸",
    PROCESSING = "ÙŠØ¹Ø§Ù„Ø¬",
    THINKING = "ÙŠÙÙƒØ±",
    LEARNING = "ÙŠØªØ¹Ù„Ù…",
    IDLE = "Ø®Ø§Ù…Ù„"
}

/**
 * Ù†ÙˆØ¹ Ø§Ù„Ø°Ø§ÙƒØ±Ø©
 */
enum MemoryType {
    SHORT_TERM = "Ù‚ØµÙŠØ±Ø©_Ø§Ù„Ù…Ø¯Ù‰",
    LONG_TERM = "Ø·ÙˆÙŠÙ„Ø©_Ø§Ù„Ù…Ø¯Ù‰",
    WORKING = "Ø¹Ø§Ù…Ù„Ø©"
}

/**
 * Ø°Ø§ÙƒØ±Ø© Ø§Ù„ÙˆØ¹ÙŠ
 */
class ConsciousnessMemory extends MotherEquation {
    public equations: Array<LinguisticEquation>;        // Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø©
    public worldState: Map<string, Thing>;              // Ø­Ø§Ù„Ø© Ø§Ù„Ø¹Ø§Ù„Ù… Ø§Ù„Ø­Ø§Ù„ÙŠØ©
    public history: Array<any>;                         // ØªØ§Ø±ÙŠØ® Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª
    public maxShortTermSize: number;                    // Ø­Ø¬Ù… Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ù‚ØµÙŠØ±Ø© Ø§Ù„Ù…Ø¯Ù‰
    
    constructor(maxShortTermSize: number = 10) {
        super("consciousness_memory");
        
        this.equations = [];
        this.worldState = new Map();
        this.history = [];
        this.maxShortTermSize = maxShortTermSize;
        
        // Î¦: Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø«Ø§Ø¨ØªØ©
        this.fixedProperties = {
            maxShortTermSize: maxShortTermSize
        };
        
        // Î¨: Ø§Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©
        this.dynamicStates = {
            equationsCount: 0,
            thingsCount: 0,
            historySize: 0
        };
    }
    
    /**
     * Ø¥Ø¶Ø§ÙØ© Ù…Ø¹Ø§Ø¯Ù„Ø© Ù„Ù„Ø°Ø§ÙƒØ±Ø©
     */
    public addEquation(equation: LinguisticEquation): void {
        this.equations.push(equation);
        
        // Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ù‚ØµÙŠØ±Ø© Ø§Ù„Ù…Ø¯Ù‰
        if (this.equations.length > this.maxShortTermSize) {
            this.equations.shift();  // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø£Ù‚Ø¯Ù…
        }
        
        this.dynamicStates.equationsCount = this.equations.length;
    }
    
    /**
     * ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ø¹Ø§Ù„Ù…
     */
    public updateWorldState(equation: LinguisticEquation): void {
        equation.things.forEach((thing, name) => {
            // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø´ÙŠØ¡ Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹ØŒ Ù†Ø­Ø¯Ø« Ø®ØµØ§Ø¦ØµÙ‡
            if (this.worldState.has(name)) {
                let existingThing = this.worldState.get(name)!;
                thing.properties.forEach((property, propName) => {
                    let existingProp = existingThing.getProperty(propName);
                    if (existingProp) {
                        existingProp.value = property.value;
                    } else {
                        existingThing.addProperty(property);
                    }
                });
            } else {
                // Ø´ÙŠØ¡ Ø¬Ø¯ÙŠØ¯
                this.worldState.set(name, thing.clone());
            }
        });
        
        this.dynamicStates.thingsCount = this.worldState.size;
    }
    
    /**
     * Ø¥Ø¶Ø§ÙØ© Ù„Ù„ØªØ§Ø±ÙŠØ®
     */
    public addToHistory(entry: any): void {
        this.history.push({
            timestamp: Date.now(),
            ...entry
        });
        
        this.dynamicStates.historySize = this.history.length;
    }
    
    /**
     * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø´ÙŠØ¡ Ù…Ù† Ø­Ø§Ù„Ø© Ø§Ù„Ø¹Ø§Ù„Ù…
     */
    public getThing(name: string): Thing | null {
        return this.worldState.get(name) || null;
    }
    
    /**
     * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¢Ø®Ø± N Ù…Ø¹Ø§Ø¯Ù„Ø©
     */
    public getRecentEquations(n: number): Array<LinguisticEquation> {
        return this.equations.slice(-n);
    }
}

/**
 * Ù†Ø¸Ø§Ù… Ø§Ù„ÙˆØ¹ÙŠ Ø§Ù„Ø¢Ù„ÙŠ
 */
class MachineConsciousness extends MotherEquation {
    public state: ConsciousnessState;
    public parser: SentenceParser;
    public memory: ConsciousnessMemory;
    public awarenessLevel: number;                      // Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ÙˆØ¹ÙŠ (0-1)
    public understandingLevel: number;                  // Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ÙÙ‡Ù… (0-1)
    public creationTime: number;
    
    constructor() {
        super("machine_consciousness");
        
        this.state = ConsciousnessState.AWAKE;
        this.parser = new SentenceParser();
        this.memory = new ConsciousnessMemory(20);
        this.awarenessLevel = 1.0;
        this.understandingLevel = 0.5;
        this.creationTime = Date.now();
        
        // Î¦: Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø«Ø§Ø¨ØªØ©
        this.fixedProperties = {
            creationTime: this.creationTime,
            type: "linguistic_consciousness"
        };
        
        // Î¨: Ø§Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©
        this.dynamicStates = {
            state: this.state,
            awarenessLevel: this.awarenessLevel,
            understandingLevel: this.understandingLevel,
            processedSentences: 0
        };
    }
    
    /**
     * Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¬Ù…Ù„Ø©
     */
    public processSentence(sentence: string): any {
        console.log(`\n${"=".repeat(60)}`);
        console.log(`ğŸ§  Ø§Ù„ÙˆØ¹ÙŠ Ø§Ù„Ø¢Ù„ÙŠ ÙŠØ¹Ø§Ù„Ø¬: "${sentence}"`);
        console.log(`${"=".repeat(60)}\n`);
        
        this.state = ConsciousnessState.PROCESSING;
        this.dynamicStates.state = this.state;
        
        // 1. ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¬Ù…Ù„Ø©
        let equation = this.parser.parseSentence(sentence);
        
        if (!equation) {
            console.log("âŒ ÙØ´Ù„ Ø§Ù„ØªØ­Ù„ÙŠÙ„\n");
            this.state = ConsciousnessState.IDLE;
            return {
                success: false,
                message: "ÙØ´Ù„ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¬Ù…Ù„Ø©"
            };
        }
        
        // 2. ØªÙ†ÙÙŠØ° Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø©
        this.state = ConsciousnessState.THINKING;
        this.dynamicStates.state = this.state;
        
        let results = equation.execute();
        
        // 3. ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø°Ø§ÙƒØ±Ø©
        this.state = ConsciousnessState.LEARNING;
        this.dynamicStates.state = this.state;
        
        this.memory.addEquation(equation);
        this.memory.updateWorldState(equation);
        
        // 4. ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª
        let changes = equation.getChanges();
        
        // 5. Ø¥Ø¶Ø§ÙØ© Ù„Ù„ØªØ§Ø±ÙŠØ®
        this.memory.addToHistory({
            sentence: sentence,
            changes: changes,
            results: results
        });
        
        // 6. ØªØ­Ø¯ÙŠØ« Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ÙÙ‡Ù…
        this._updateUnderstanding(equation);
        
        this.dynamicStates.processedSentences++;
        this.state = ConsciousnessState.AWAKE;
        this.dynamicStates.state = this.state;
        
        // 7. Ø¹Ø±Ø¶ Ø§Ù„Ù†ØªØ§Ø¦Ø¬
        this._displayResults(equation, results, changes);
        
        return {
            success: true,
            equation: equation,
            results: results,
            changes: changes,
            worldState: this._getWorldStateSummary()
        };
    }
    
    /**
     * ØªØ­Ø¯ÙŠØ« Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ÙÙ‡Ù…
     */
    private _updateUnderstanding(equation: LinguisticEquation): void {
        // ÙƒÙ„Ù…Ø§ Ø²Ø§Ø¯Øª Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©ØŒ Ø²Ø§Ø¯ Ø§Ù„ÙÙ‡Ù…
        let processedCount = this.dynamicStates.processedSentences as number;
        this.understandingLevel = Math.min(1.0, 0.5 + (processedCount * 0.05));
        this.dynamicStates.understandingLevel = this.understandingLevel;
    }
    
    /**
     * Ø¹Ø±Ø¶ Ø§Ù„Ù†ØªØ§Ø¦Ø¬
     */
    private _displayResults(
        equation: LinguisticEquation,
        results: Array<string>,
        changes: Array<any>
    ): void {
        console.log("\n" + "â”€".repeat(60));
        console.log("ğŸ“Š Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©:");
        console.log("â”€".repeat(60) + "\n");
        
        console.log("âœ… Ø§Ù„ØªØ£Ø«ÙŠØ±Ø§Øª Ø§Ù„Ù…Ø·Ø¨Ù‚Ø©:");
        results.forEach(result => {
            console.log(`   ${result}`);
        });
        
        console.log("\nğŸ“ˆ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„Ø¹Ø§Ù„Ù…:");
        if (changes.length === 0) {
            console.log("   Ù„Ø§ ØªÙˆØ¬Ø¯ ØªØºÙŠÙŠØ±Ø§Øª");
        } else {
            changes.forEach(change => {
                if (change.type === "property") {
                    let arrow = change.delta > 0 ? "â†‘" : "â†“";
                    let color = change.delta > 0 ? "+" : "";
                    console.log(`   ${arrow} ${change.thing}.${change.property}: ${change.from.toFixed(1)} â†’ ${change.to.toFixed(1)} (${color}${change.delta.toFixed(1)})`);
                } else if (change.type === "existence") {
                    console.log(`   ${change.description}: ${change.thing}`);
                }
            });
        }
        
        console.log("\nğŸŒ Ø­Ø§Ù„Ø© Ø§Ù„Ø¹Ø§Ù„Ù… Ø§Ù„Ø­Ø§Ù„ÙŠØ©:");
        this.memory.worldState.forEach((thing, name) => {
            console.log(`   ğŸ“¦ ${name} (${thing.type}):`);
            thing.properties.forEach((property, propName) => {
                let bar = this._createProgressBar(property.getNormalizedValue(), 10);
                console.log(`      â€¢ ${propName}: ${property.value.toFixed(1)}${property.unit} ${bar}`);
            });
        });
        
        console.log("\n" + "â”€".repeat(60));
        console.log(`ğŸ§  Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ÙˆØ¹ÙŠ: ${(this.awarenessLevel * 100).toFixed(0)}%`);
        console.log(`ğŸ’¡ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ÙÙ‡Ù…: ${(this.understandingLevel * 100).toFixed(0)}%`);
        console.log(`ğŸ“š Ù…Ø¹Ø§Ø¯Ù„Ø§Øª ÙÙŠ Ø§Ù„Ø°Ø§ÙƒØ±Ø©: ${this.memory.equations.length}`);
        console.log(`ğŸŒ Ø£Ø´ÙŠØ§Ø¡ ÙÙŠ Ø§Ù„Ø¹Ø§Ù„Ù…: ${this.memory.worldState.size}`);
        console.log("â”€".repeat(60) + "\n");
    }
    
    /**
     * Ø¥Ù†Ø´Ø§Ø¡ Ø´Ø±ÙŠØ· ØªÙ‚Ø¯Ù…
     */
    private _createProgressBar(value: number, length: number = 10): string {
        let filled = Math.round(value * length);
        let empty = length - filled;
        return "[" + "â–ˆ".repeat(filled) + "â–‘".repeat(empty) + "]";
    }
    
    /**
     * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ù„Ø®Øµ Ø­Ø§Ù„Ø© Ø§Ù„Ø¹Ø§Ù„Ù…
     */
    private _getWorldStateSummary(): any {
        let summary: any = {};
        
        this.memory.worldState.forEach((thing, name) => {
            summary[name] = {
                type: thing.type,
                exists: thing.exists,
                properties: {}
            };
            
            thing.properties.forEach((property, propName) => {
                summary[name].properties[propName] = property.value;
            });
        });
        
        return summary;
    }
    
    /**
     * Ù…Ø¹Ø§Ù„Ø¬Ø© Ù‚ØµØ© (Ø¹Ø¯Ø© Ø¬Ù…Ù„)
     */
    public processStory(sentences: Array<string>): void {
        console.log("\n" + "=".repeat(60));
        console.log("ğŸ“– Ù…Ø¹Ø§Ù„Ø¬Ø© Ù‚ØµØ©");
        console.log("=".repeat(60));
        
        for (let i = 0; i < sentences.length; i++) {
            console.log(`\n[${i + 1}/${sentences.length}] ${sentences[i]}`);
            this.processSentence(sentences[i]);
        }
        
        console.log("\n" + "=".repeat(60));
        console.log("âœ… Ø§ÙƒØªÙ…Ù„Øª Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù‚ØµØ©");
        console.log("=".repeat(60) + "\n");
    }
    
    /**
     * Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø¹Ù† Ø´ÙŠØ¡
     */
    public queryThing(name: string): any {
        let thing = this.memory.getThing(name);
        
        if (!thing) {
            return {
                exists: false,
                message: `Ø§Ù„Ø´ÙŠØ¡ "${name}" ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„Ø¹Ø§Ù„Ù…`
            };
        }
        
        let properties: any = {};
        thing.properties.forEach((property, propName) => {
            properties[propName] = {
                value: property.value,
                unit: property.unit,
                domain: property.domain,
                normalized: property.getNormalizedValue()
            };
        });
        
        return {
            exists: true,
            name: name,
            type: thing.type,
            properties: properties
        };
    }
    
    /**
     * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„ØªØ§Ø±ÙŠØ®
     */
    public getHistory(limit: number = 10): Array<any> {
        return this.memory.history.slice(-limit);
    }
    
    /**
     * Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„ÙˆØ¹ÙŠ
     */
    public reset(): void {
        this.memory = new ConsciousnessMemory(20);
        this.state = ConsciousnessState.AWAKE;
        this.awarenessLevel = 1.0;
        this.understandingLevel = 0.5;
        this.dynamicStates.processedSentences = 0;
        
        console.log("ğŸ”„ ØªÙ… Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„ÙˆØ¹ÙŠ Ø§Ù„Ø¢Ù„ÙŠ\n");
    }
}

export {
    ConsciousnessState,
    MemoryType,
    ConsciousnessMemory,
    MachineConsciousness
};
