/**
 * واجهة مترجم البيان - Bayan Compiler Interface
 * يسمح لبصيرة AI بالتفاعل مع مترجم لغة البيان
 * 
 * المطور: نظام بصيرة AI
 * التاريخ: 2024
 */

import { MotherEquation } from "../core/mother-equation.bn";

// استيراد أنواع إضافية
export enum ErrorSeverity {
    ERROR = "ERROR",               // خطأ فادح
    WARNING = "WARNING",           // تحذير
    INFO = "INFO",                 // معلومة
    HINT = "HINT"                  // تلميح
}

// ============================================================================
// التعدادات - Enums
// ============================================================================

/**
 * أنواع الأخطاء البرمجية
 */
export enum ErrorType {
    LEXICAL = "LEXICAL",           // خطأ معجمي
    SYNTAX = "SYNTAX",             // خطأ نحوي
    SEMANTIC = "SEMANTIC",         // خطأ دلالي
    RUNTIME = "RUNTIME",           // خطأ تنفيذي
    TYPE = "TYPE",                 // خطأ في الأنواع
    LOGIC = "LOGIC"                // خطأ منطقي
}



/**
 * أنواع الكود المولد
 */
export enum CodeGenerationType {
    FUNCTION = "FUNCTION",         // دالة
    CLASS = "CLASS",               // فئة
    MODULE = "MODULE",             // وحدة
    SNIPPET = "SNIPPET",           // مقتطف
    FULL_PROGRAM = "FULL_PROGRAM"  // برنامج كامل
}

/**
 * مستويات التحسين
 */
export enum OptimizationLevel {
    NONE = "NONE",                 // بدون تحسين
    BASIC = "BASIC",               // تحسين أساسي
    ADVANCED = "ADVANCED",         // تحسين متقدم
    AGGRESSIVE = "AGGRESSIVE"      // تحسين عدواني
}

// ============================================================================
// الفئات - Classes
// ============================================================================

/**
 * خطأ برمجي - Programming Error
 * يمثل خطأ في الكود
 */
export class ProgrammingError extends MotherEquation {
    public errorType: ErrorType;
    public severity: ErrorSeverity;
    public message: string;
    public line: number;
    public column: number;
    public code: string;
    public suggestion: string;
    public timestamp: number;

    constructor(
        errorType: ErrorType,
        severity: ErrorSeverity,
        message: string,
        line: number,
        column: number,
        code: string = ""
    ) {
        super();
        this.errorType = errorType;
        this.severity = severity;
        this.message = message;
        this.line = line;
        this.column = column;
        this.code = code;
        this.suggestion = "";
        this.timestamp = Date.now();

        // المعادلة الأم
        this.fixedProperties.set("errorType", errorType);
        this.fixedProperties.set("severity", severity);
        this.dynamicStates.set("message", message);
        this.dynamicStates.set("line", line);
        this.dynamicStates.set("column", column);
    }

    /**
     * إضافة اقتراح لحل الخطأ
     */
    public addSuggestion(suggestion: string): void {
        this.suggestion = suggestion;
        this.dynamicStates.set("suggestion", suggestion);
    }

    /**
     * الحصول على وصف الخطأ
     */
    public getDescription(): string {
        let desc = `[${this.severity}] ${this.errorType} في السطر ${this.line}، العمود ${this.column}:\n`;
        desc += `  ${this.message}\n`;
        if (this.code) {
            desc += `  الكود: ${this.code}\n`;
        }
        if (this.suggestion) {
            desc += `  الاقتراح: ${this.suggestion}`;
        }
        return desc;
    }

    /**
     * هل الخطأ فادح؟
     */
    public isCritical(): boolean {
        return this.severity === ErrorSeverity.ERROR;
    }
}

/**
 * نتيجة الترجمة - Compilation Result
 * نتيجة ترجمة كود البيان
 */
export class CompilationResult extends MotherEquation {
    public success: boolean;
    public sourceCode: string;
    public compiledCode: string;
    public errors: Array<ProgrammingError>;
    public warnings: Array<ProgrammingError>;
    public compilationTime: number;
    public target: string;
    public module: string;

    constructor(sourceCode: string) {
        super();
        this.success = false;
        this.sourceCode = sourceCode;
        this.compiledCode = "";
        this.errors = [];
        this.warnings = [];
        this.compilationTime = 0;
        this.target = "es2020";
        this.module = "esm";

        // المعادلة الأم
        this.fixedProperties.set("sourceCode", sourceCode);
        this.dynamicStates.set("success", false);
    }

    /**
     * إضافة خطأ
     */
    public addError(error: ProgrammingError): void {
        this.errors.push(error);
        this.success = false;
        this.dynamicStates.set("errorCount", this.errors.length);
    }

    /**
     * إضافة تحذير
     */
    public addWarning(warning: ProgrammingError): void {
        this.warnings.push(warning);
        this.dynamicStates.set("warningCount", this.warnings.length);
    }

    /**
     * تعيين الكود المترجم
     */
    public setCompiledCode(code: string, time: number): void {
        this.compiledCode = code;
        this.compilationTime = time;
        this.success = this.errors.length === 0;
        this.dynamicStates.set("success", this.success);
        this.dynamicStates.set("compilationTime", time);
    }

    /**
     * الحصول على تقرير الترجمة
     */
    public getReport(): string {
        let report = `=== تقرير الترجمة ===\n`;
        report += `الحالة: ${this.success ? "✅ نجح" : "❌ فشل"}\n`;
        report += `الأخطاء: ${this.errors.length}\n`;
        report += `التحذيرات: ${this.warnings.length}\n`;
        report += `وقت الترجمة: ${this.compilationTime.toFixed(2)} ms\n`;
        report += `الهدف: ${this.target}\n`;
        report += `الوحدة: ${this.module}\n\n`;

        if (this.errors.length > 0) {
            report += `الأخطاء:\n`;
            this.errors.forEach((err, i) => {
                report += `${i + 1}. ${err.getDescription()}\n`;
            });
        }

        if (this.warnings.length > 0) {
            report += `\nالتحذيرات:\n`;
            this.warnings.forEach((warn, i) => {
                report += `${i + 1}. ${warn.getDescription()}\n`;
            });
        }

        return report;
    }
}

/**
 * واجهة مترجم البيان - Bayan Compiler Interface
 * الواجهة الرئيسية للتفاعل مع مترجم لغة البيان
 */
export class BayanCompilerInterface extends MotherEquation {
    public compiledFiles: Map<string, CompilationResult>;
    public errorHistory: Array<ProgrammingError>;
    public successRate: number;
    public totalCompilations: number;
    public successfulCompilations: number;

    constructor() {
        super();
        this.compiledFiles = new Map();
        this.errorHistory = [];
        this.successRate = 0.0;
        this.totalCompilations = 0;
        this.successfulCompilations = 0;

        // المعادلة الأم
        this.fixedProperties.set("compilerVersion", "1.0.0");
        this.fixedProperties.set("language", "bayan");
        this.dynamicStates.set("totalCompilations", 0);
        this.dynamicStates.set("successRate", 0.0);
    }

    /**
     * ترجمة كود البيان إلى JavaScript
     * هذه دالة محاكاة - في التطبيق الفعلي ستستدعي المترجم الحقيقي
     */
    public compile(
        sourceCode: string,
        fileName: string = "untitled.bn",
        target: string = "es2020",
        module: string = "esm"
    ): CompilationResult {
        const startTime = Date.now();
        const result = new CompilationResult(sourceCode);
        result.target = target;
        result.module = module;

        try {
            // محاكاة عملية الترجمة
            // في التطبيق الفعلي، سنستدعي:
            // const { Lexer, Parser, Compiler } = require('bayan-compiler');
            
            // 1. التحليل المعجمي (Lexical Analysis)
            const lexicalErrors = this.performLexicalAnalysis(sourceCode);
            lexicalErrors.forEach(err => result.addError(err));

            if (lexicalErrors.length > 0) {
                result.setCompiledCode("", Date.now() - startTime);
                this.recordCompilation(result);
                return result;
            }

            // 2. التحليل النحوي (Syntax Analysis)
            const syntaxErrors = this.performSyntaxAnalysis(sourceCode);
            syntaxErrors.forEach(err => result.addError(err));

            if (syntaxErrors.length > 0) {
                result.setCompiledCode("", Date.now() - startTime);
                this.recordCompilation(result);
                return result;
            }

            // 3. التحليل الدلالي (Semantic Analysis)
            const semanticWarnings = this.performSemanticAnalysis(sourceCode);
            semanticWarnings.forEach(warn => result.addWarning(warn));

            // 4. توليد الكود
            const jsCode = this.generateJavaScript(sourceCode, target, module);
            result.setCompiledCode(jsCode, Date.now() - startTime);

            this.recordCompilation(result);
            this.compiledFiles.set(fileName, result);

        } catch (error: any) {
            const err = new ProgrammingError(
                ErrorType.RUNTIME,
                ErrorSeverity.ERROR,
                error.message || "خطأ غير متوقع",
                0,
                0
            );
            result.addError(err);
            result.setCompiledCode("", Date.now() - startTime);
            this.recordCompilation(result);
        }

        return result;
    }

    /**
     * التحليل المعجمي - محاكاة
     */
    private performLexicalAnalysis(code: string): Array<ProgrammingError> {
        const errors: Array<ProgrammingError> = [];
        
        // فحص بسيط للأحرف غير المدعومة
        const lines = code.split('\n');
        lines.forEach((line, lineNum) => {
            // فحص الأقواس المتطابقة
            const openBraces = (line.match(/{/g) || []).length;
            const closeBraces = (line.match(/}/g) || []).length;
            
            if (openBraces !== closeBraces) {
                // هذا تحذير فقط لأن الأقواس قد تكون في أسطر أخرى
            }
        });

        return errors;
    }

    /**
     * التحليل النحوي - محاكاة
     */
    private performSyntaxAnalysis(code: string): Array<ProgrammingError> {
        const errors: Array<ProgrammingError> = [];
        
        // فحوصات نحوية بسيطة
        const lines = code.split('\n');
        lines.forEach((line, lineNum) => {
            const trimmed = line.trim();
            
            // فحص الكلمات المفتاحية
            if (trimmed.startsWith('class') || trimmed.startsWith('فئة')) {
                if (!trimmed.includes('{') && !lines[lineNum + 1]?.includes('{')) {
                    const err = new ProgrammingError(
                        ErrorType.SYNTAX,
                        ErrorSeverity.WARNING,
                        "تعريف الفئة يجب أن يتبعه قوس فتح {",
                        lineNum + 1,
                        0,
                        trimmed
                    );
                    err.addSuggestion("أضف { بعد اسم الفئة");
                    errors.push(err);
                }
            }
        });

        return errors;
    }

    /**
     * التحليل الدلالي - محاكاة
     */
    private performSemanticAnalysis(code: string): Array<ProgrammingError> {
        const warnings: Array<ProgrammingError> = [];
        
        // فحوصات دلالية بسيطة
        // مثل: متغيرات غير مستخدمة، دوال غير مستدعاة، إلخ
        
        return warnings;
    }

    /**
     * توليد كود JavaScript - محاكاة
     */
    private generateJavaScript(code: string, target: string, module: string): string {
        // في التطبيق الفعلي، سيتم استدعاء المترجم الحقيقي
        // هنا نقوم بمحاكاة بسيطة
        
        let jsCode = `// Generated by Bayan Compiler\n`;
        jsCode += `// Target: ${target}, Module: ${module}\n\n`;
        jsCode += code; // في الواقع، سيتم ترجمة الكود
        
        return jsCode;
    }

    /**
     * تسجيل عملية الترجمة
     */
    private recordCompilation(result: CompilationResult): void {
        this.totalCompilations++;
        if (result.success) {
            this.successfulCompilations++;
        }

        // تحديث معدل النجاح
        this.successRate = this.successfulCompilations / this.totalCompilations;
        this.dynamicStates.set("totalCompilations", this.totalCompilations);
        this.dynamicStates.set("successRate", this.successRate);

        // حفظ الأخطاء في السجل
        result.errors.forEach(err => this.errorHistory.push(err));
    }

    /**
     * الحصول على إحصائيات الترجمة
     */
    public getStatistics(): any {
        return {
            totalCompilations: this.totalCompilations,
            successfulCompilations: this.successfulCompilations,
            failedCompilations: this.totalCompilations - this.successfulCompilations,
            successRate: (this.successRate * 100).toFixed(2) + "%",
            totalErrors: this.errorHistory.length,
            compiledFiles: this.compiledFiles.size
        };
    }

    /**
     * الحصول على الأخطاء الشائعة
     */
    public getCommonErrors(limit: number = 5): Array<{errorType: string, count: number}> {
        const errorCounts = new Map<string, number>();
        
        this.errorHistory.forEach(err => {
            const key = `${err.errorType}: ${err.message}`;
            errorCounts.set(key, (errorCounts.get(key) || 0) + 1);
        });

        const sorted = Array.from(errorCounts.entries())
            .sort((a, b) => b[1] - a[1])
            .slice(0, limit);

        return sorted.map(([errorType, count]) => ({ errorType, count }));
    }
}

