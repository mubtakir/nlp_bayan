/**
 * Ø§Ù„Ù„ØºØ© Ø°Ø§ØªÙŠØ© Ø§Ù„ØªØ¹Ù„Ù… - Self-Learning Language
 * ØªÙ…ÙƒÙ† Ù„ØºØ© Ø§Ù„Ø¨ÙŠØ§Ù† Ù…Ù† ØªØ¹Ù„Ù… Ù†ÙØ³Ù‡Ø§ ÙˆØªØ·ÙˆÙŠØ± Ù†ÙØ³Ù‡Ø§
 * 
 * Ø§Ù„Ù…Ø·ÙˆØ±: Ù†Ø¸Ø§Ù… Ø¨ØµÙŠØ±Ø© AI
 * Ø§Ù„ØªØ§Ø±ÙŠØ®: 2024
 */

import { MotherEquation } from "../core/mother-equation.bn";
import { BayanCompilerInterface, ProgrammingError, ErrorType } from "./bayan-compiler-interface.bn";
import { IntelligentCodeGenerator, CodeSpecification, CodeGenerationType } from "./intelligent-code-generator.bn";

// ============================================================================
// Ø§Ù„ØªØ¹Ø¯Ø§Ø¯Ø§Øª - Enums
// ============================================================================

/**
 * Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„ØªØ¹Ù„Ù…
 */
export enum LearningType {
    FROM_ERRORS = "FROM_ERRORS",           // Ø§Ù„ØªØ¹Ù„Ù… Ù…Ù† Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
    FROM_PATTERNS = "FROM_PATTERNS",       // Ø§Ù„ØªØ¹Ù„Ù… Ù…Ù† Ø§Ù„Ø£Ù†Ù…Ø§Ø·
    FROM_EXAMPLES = "FROM_EXAMPLES",       // Ø§Ù„ØªØ¹Ù„Ù… Ù…Ù† Ø§Ù„Ø£Ù…Ø«Ù„Ø©
    FROM_FEEDBACK = "FROM_FEEDBACK",       // Ø§Ù„ØªØ¹Ù„Ù… Ù…Ù† Ø§Ù„ØªØºØ°ÙŠØ© Ø§Ù„Ø±Ø§Ø¬Ø¹Ø©
    SELF_IMPROVEMENT = "SELF_IMPROVEMENT"  // Ø§Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø°Ø§ØªÙŠ
}

/**
 * Ù…Ø³ØªÙˆÙŠØ§Øª Ø§Ù„Ø«Ù‚Ø©
 */
export enum ConfidenceLevel {
    VERY_LOW = "VERY_LOW",       // Ù…Ù†Ø®ÙØ¶Ø© Ø¬Ø¯Ø§Ù‹
    LOW = "LOW",                 // Ù…Ù†Ø®ÙØ¶Ø©
    MEDIUM = "MEDIUM",           // Ù…ØªÙˆØ³Ø·Ø©
    HIGH = "HIGH",               // Ø¹Ø§Ù„ÙŠØ©
    VERY_HIGH = "VERY_HIGH"      // Ø¹Ø§Ù„ÙŠØ© Ø¬Ø¯Ø§Ù‹
}

/**
 * Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ø­Ù„ÙˆÙ„
 */
export enum SolutionType {
    FIX = "FIX",                 // Ø¥ØµÙ„Ø§Ø­
    REFACTOR = "REFACTOR",       // Ø¥Ø¹Ø§Ø¯Ø© Ù‡ÙŠÙƒÙ„Ø©
    OPTIMIZE = "OPTIMIZE",       // ØªØ­Ø³ÙŠÙ†
    ALTERNATIVE = "ALTERNATIVE"  // Ø¨Ø¯ÙŠÙ„
}

// ============================================================================
// Ø§Ù„ÙØ¦Ø§Øª - Classes
// ============================================================================

/**
 * Ø¯Ø±Ø³ Ù…Ø³ØªÙØ§Ø¯ - Learned Lesson
 * ÙŠÙ…Ø«Ù„ Ø¯Ø±Ø³Ø§Ù‹ ØªØ¹Ù„Ù…ØªÙ‡ Ø§Ù„Ù„ØºØ©
 */
export class LearnedLesson extends MotherEquation {
    public lessonId: string;
    public learningType: LearningType;
    public problem: string;
    public solution: string;
    public confidence: ConfidenceLevel;
    public successCount: number;
    public failureCount: number;
    public timestamp: number;

    constructor(learningType: LearningType, problem: string, solution: string) {
        super();
        this.lessonId = `lesson_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        this.learningType = learningType;
        this.problem = problem;
        this.solution = solution;
        this.confidence = ConfidenceLevel.MEDIUM;
        this.successCount = 0;
        this.failureCount = 0;
        this.timestamp = Date.now();

        // Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„Ø£Ù…
        this.fixedProperties.set("lessonId", this.lessonId);
        this.fixedProperties.set("learningType", learningType);
        this.dynamicStates.set("confidence", this.confidence);
    }

    /**
     * ØªØ³Ø¬ÙŠÙ„ Ù†Ø¬Ø§Ø­
     */
    public recordSuccess(): void {
        this.successCount++;
        this.updateConfidence();
        this.dynamicStates.set("successCount", this.successCount);
    }

    /**
     * ØªØ³Ø¬ÙŠÙ„ ÙØ´Ù„
     */
    public recordFailure(): void {
        this.failureCount++;
        this.updateConfidence();
        this.dynamicStates.set("failureCount", this.failureCount);
    }

    /**
     * ØªØ­Ø¯ÙŠØ« Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø«Ù‚Ø©
     */
    private updateConfidence(): void {
        const total = this.successCount + this.failureCount;
        if (total === 0) {
            this.confidence = ConfidenceLevel.MEDIUM;
            return;
        }

        const successRate = this.successCount / total;

        if (successRate >= 0.9) {
            this.confidence = ConfidenceLevel.VERY_HIGH;
        } else if (successRate >= 0.7) {
            this.confidence = ConfidenceLevel.HIGH;
        } else if (successRate >= 0.5) {
            this.confidence = ConfidenceLevel.MEDIUM;
        } else if (successRate >= 0.3) {
            this.confidence = ConfidenceLevel.LOW;
        } else {
            this.confidence = ConfidenceLevel.VERY_LOW;
        }

        this.dynamicStates.set("confidence", this.confidence);
    }

    /**
     * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ø¯Ù„ Ø§Ù„Ù†Ø¬Ø§Ø­
     */
    public getSuccessRate(): number {
        const total = this.successCount + this.failureCount;
        return total === 0 ? 0 : this.successCount / total;
    }
}

/**
 * Ø­Ù„ Ù…Ù‚ØªØ±Ø­ - Proposed Solution
 * Ø­Ù„ Ù…Ù‚ØªØ±Ø­ Ù„Ù…Ø´ÙƒÙ„Ø© Ø¨Ø±Ù…Ø¬ÙŠØ©
 */
export class ProposedSolution extends MotherEquation {
    public solutionId: string;
    public error: ProgrammingError;
    public solutionType: SolutionType;
    public originalCode: string;
    public fixedCode: string;
    public explanation: string;
    public confidence: number;
    public basedOnLesson: LearnedLesson | null;

    constructor(error: ProgrammingError, solutionType: SolutionType) {
        super();
        this.solutionId = `solution_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        this.error = error;
        this.solutionType = solutionType;
        this.originalCode = error.code;
        this.fixedCode = "";
        this.explanation = "";
        this.confidence = 0.5;
        this.basedOnLesson = null;

        // Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„Ø£Ù…
        this.fixedProperties.set("solutionId", this.solutionId);
        this.fixedProperties.set("solutionType", solutionType);
        this.dynamicStates.set("confidence", this.confidence);
    }

    /**
     * ØªØ¹ÙŠÙŠÙ† Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ù…ØµÙ„Ø­
     */
    public setFixedCode(code: string, explanation: string): void {
        this.fixedCode = code;
        this.explanation = explanation;
        this.dynamicStates.set("hasFixedCode", true);
    }

    /**
     * Ø±Ø¨Ø· Ø¨Ø¯Ø±Ø³ Ù…Ø³ØªÙØ§Ø¯
     */
    public linkToLesson(lesson: LearnedLesson): void {
        this.basedOnLesson = lesson;
        this.confidence = lesson.getSuccessRate();
        this.dynamicStates.set("confidence", this.confidence);
    }

    /**
     * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ ØªÙ‚Ø±ÙŠØ±
     */
    public getReport(): string {
        let report = `=== Ø­Ù„ Ù…Ù‚ØªØ±Ø­ ===\n`;
        report += `Ø§Ù„Ù†ÙˆØ¹: ${this.solutionType}\n`;
        report += `Ø§Ù„Ø«Ù‚Ø©: ${(this.confidence * 100).toFixed(0)}%\n`;
        report += `Ø§Ù„Ø®Ø·Ø£: ${this.error.message}\n`;
        report += `Ø§Ù„Ø´Ø±Ø­: ${this.explanation}\n\n`;
        report += `Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø£ØµÙ„ÙŠ:\n${this.originalCode}\n\n`;
        report += `Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ù…ØµÙ„Ø­:\n${this.fixedCode}\n`;
        return report;
    }
}

/**
 * Ø§Ù„Ù„ØºØ© Ø°Ø§ØªÙŠØ© Ø§Ù„ØªØ¹Ù„Ù… - Self-Learning Language
 * Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ Ù„Ù„ØªØ¹Ù„Ù… Ø§Ù„Ø°Ø§ØªÙŠ
 */
export class SelfLearningLanguage extends MotherEquation {
    public compiler: BayanCompilerInterface;
    public codeGenerator: IntelligentCodeGenerator;
    public learnedLessons: Map<string, LearnedLesson>;
    public errorPatterns: Map<string, number>;
    public solutionHistory: Array<ProposedSolution>;
    public totalLearningCycles: number;
    public improvementRate: number;

    constructor() {
        super();
        this.compiler = new BayanCompilerInterface();
        this.codeGenerator = new IntelligentCodeGenerator();
        this.learnedLessons = new Map();
        this.errorPatterns = new Map();
        this.solutionHistory = [];
        this.totalLearningCycles = 0;
        this.improvementRate = 0.0;

        // Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„Ø£Ù…
        this.fixedProperties.set("systemVersion", "1.0.0");
        this.dynamicStates.set("totalLearningCycles", 0);
        this.dynamicStates.set("improvementRate", 0.0);
    }

    /**
     * Ø§Ù„ØªØ¹Ù„Ù… Ù…Ù† Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
     */
    public learnFromErrors(errors: Array<ProgrammingError>): Array<LearnedLesson> {
        const newLessons: Array<LearnedLesson> = [];

        errors.forEach(error => {
            // ØªØ³Ø¬ÙŠÙ„ Ù†Ù…Ø· Ø§Ù„Ø®Ø·Ø£
            const pattern = `${error.errorType}:${error.message}`;
            this.errorPatterns.set(pattern, (this.errorPatterns.get(pattern) || 0) + 1);

            // Ù…Ø­Ø§ÙˆÙ„Ø© Ø¥ÙŠØ¬Ø§Ø¯ Ø¯Ø±Ø³ Ù…Ø´Ø§Ø¨Ù‡
            const existingLesson = this.findSimilarLesson(error);

            if (existingLesson) {
                // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¯Ø±Ø³ Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯
                console.log(`ÙˆØ¬Ø¯Øª Ø¯Ø±Ø³Ø§Ù‹ Ù…Ø´Ø§Ø¨Ù‡Ø§Ù‹: ${existingLesson.lessonId}`);
            } else {
                // Ø¥Ù†Ø´Ø§Ø¡ Ø¯Ø±Ø³ Ø¬Ø¯ÙŠØ¯
                const solution = this.generateSolution(error);
                const lesson = new LearnedLesson(
                    LearningType.FROM_ERRORS,
                    error.message,
                    solution
                );
                
                this.learnedLessons.set(lesson.lessonId, lesson);
                newLessons.push(lesson);
            }
        });

        this.totalLearningCycles++;
        this.dynamicStates.set("totalLearningCycles", this.totalLearningCycles);

        return newLessons;
    }

    /**
     * Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø¯Ø±Ø³ Ù…Ø´Ø§Ø¨Ù‡
     */
    private findSimilarLesson(error: ProgrammingError): LearnedLesson | null {
        for (const [id, lesson] of this.learnedLessons) {
            if (lesson.problem.includes(error.message) || error.message.includes(lesson.problem)) {
                return lesson;
            }
        }
        return null;
    }

    /**
     * ØªÙˆÙ„ÙŠØ¯ Ø­Ù„ Ù„Ù„Ø®Ø·Ø£
     */
    private generateSolution(error: ProgrammingError): string {
        // Ø­Ù„ÙˆÙ„ Ø¨Ø³ÙŠØ·Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù†ÙˆØ¹ Ø§Ù„Ø®Ø·Ø£
        if (error.errorType === ErrorType.SYNTAX) {
            return "ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨Ù†Ø§Ø¡ Ø§Ù„Ø¬Ù…Ù„Ø© ÙˆØ§Ù„Ø£Ù‚ÙˆØ§Ø³ Ø§Ù„Ù…ØªØ·Ø§Ø¨Ù‚Ø©";
        } else if (error.errorType === ErrorType.LEXICAL) {
            return "ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø£Ø­Ø±Ù ÙˆØ§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…Ø©";
        } else if (error.errorType === ErrorType.SEMANTIC) {
            return "ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…Ø¹Ù†Ù‰ Ø§Ù„Ø¯Ù„Ø§Ù„ÙŠ ÙˆØ§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…Ø©";
        } else {
            return "Ø±Ø§Ø¬Ø¹ Ø§Ù„ÙƒÙˆØ¯ ÙˆØ­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰";
        }
    }

    /**
     * Ø§Ù‚ØªØ±Ø§Ø­ Ø­Ù„ Ù„Ø®Ø·Ø£
     */
    public proposeSolution(error: ProgrammingError): ProposedSolution {
        const solution = new ProposedSolution(error, SolutionType.FIX);

        // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø¯Ø±Ø³ Ù…Ø´Ø§Ø¨Ù‡
        const lesson = this.findSimilarLesson(error);

        if (lesson) {
            solution.linkToLesson(lesson);
            solution.setFixedCode(
                this.applyFix(error.code, lesson.solution),
                lesson.solution
            );
        } else {
            // ØªÙˆÙ„ÙŠØ¯ Ø­Ù„ Ø¬Ø¯ÙŠØ¯
            const fix = this.generateSolution(error);
            solution.setFixedCode(
                this.applyFix(error.code, fix),
                fix
            );
        }

        this.solutionHistory.push(solution);
        return solution;
    }

    /**
     * ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø¥ØµÙ„Ø§Ø­
     */
    private applyFix(code: string, fix: string): string {
        // ÙÙŠ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ÙØ¹Ù„ÙŠØŒ Ø³ÙŠØªÙ… ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø¥ØµÙ„Ø§Ø­ Ø¨Ø°ÙƒØ§Ø¡
        // Ù‡Ù†Ø§ Ù†Ø¶ÙŠÙ ØªØ¹Ù„ÙŠÙ‚ ÙÙ‚Ø·
        return `// ${fix}\n${code}`;
    }

    /**
     * Ø§Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø°Ø§ØªÙŠ
     */
    public selfImprove(): void {
        console.log("ğŸ”„ Ø¨Ø¯Ø¡ Ø§Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø°Ø§ØªÙŠ...");

        // 1. ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ø´Ø§Ø¦Ø¹Ø©
        const commonErrors = this.getCommonErrors(5);
        console.log(`Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ø´Ø§Ø¦Ø¹Ø©: ${commonErrors.length}`);

        // 2. ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ Ø§Ø®ØªØ¨Ø§Ø±
        commonErrors.forEach(([pattern, count]) => {
            const spec = new CodeSpecification(
                `Ø§Ø®ØªØ¨Ø§Ø± Ù„ØªØ¬Ù†Ø¨: ${pattern}`,
                CodeGenerationType.FUNCTION
            );
            const testCode = this.codeGenerator.generate(spec);
            console.log(`ØªÙ… ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ Ø§Ø®ØªØ¨Ø§Ø±: ${testCode.linesOfCode} Ø³Ø·Ø±`);
        });

        // 3. ØªØ­Ø¯ÙŠØ« Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªØ­Ø³ÙŠÙ†
        this.updateImprovementRate();

        console.log("âœ… Ø§ÙƒØªÙ…Ù„ Ø§Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø°Ø§ØªÙŠ");
    }

    /**
     * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ø´Ø§Ø¦Ø¹Ø©
     */
    private getCommonErrors(limit: number): Array<[string, number]> {
        return Array.from(this.errorPatterns.entries())
            .sort((a, b) => b[1] - a[1])
            .slice(0, limit);
    }

    /**
     * ØªØ­Ø¯ÙŠØ« Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªØ­Ø³ÙŠÙ†
     */
    private updateImprovementRate(): void {
        if (this.solutionHistory.length === 0) {
            this.improvementRate = 0;
            return;
        }

        // Ø­Ø³Ø§Ø¨ Ù…Ø¹Ø¯Ù„ Ø§Ù„Ø­Ù„ÙˆÙ„ Ø§Ù„Ù†Ø§Ø¬Ø­Ø©
        const recentSolutions = this.solutionHistory.slice(-10);
        const avgConfidence = recentSolutions.reduce((sum, sol) => sum + sol.confidence, 0) / recentSolutions.length;
        
        this.improvementRate = avgConfidence;
        this.dynamicStates.set("improvementRate", this.improvementRate);
    }

    /**
     * ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ Ø°ÙƒÙŠ
     */
    public generateIntelligentCode(description: string): string {
        const spec = new CodeSpecification(description, CodeGenerationType.CLASS);
        
        // Ø¥Ø¶Ø§ÙØ© Ù…ØªØ·Ù„Ø¨Ø§Øª Ù…Ù† Ø§Ù„Ø¯Ø±ÙˆØ³ Ø§Ù„Ù…Ø³ØªÙØ§Ø¯Ø©
        this.learnedLessons.forEach(lesson => {
            if (lesson.confidence === ConfidenceLevel.VERY_HIGH) {
                spec.addRequirement(lesson.solution);
            }
        });

        const generated = this.codeGenerator.generate(spec);
        
        // ØªØ±Ø¬Ù…Ø© Ø§Ù„ÙƒÙˆØ¯ Ù„Ù„ØªØ­Ù‚Ù‚
        const result = this.compiler.compile(generated.code, "generated.bn");
        
        if (!result.success) {
            // Ø§Ù„ØªØ¹Ù„Ù… Ù…Ù† Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
            this.learnFromErrors(result.errors);
            
            // Ù…Ø­Ø§ÙˆÙ„Ø© Ø¥ØµÙ„Ø§Ø­ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
            result.errors.forEach(error => {
                const solution = this.proposeSolution(error);
                console.log(solution.getReport());
            });
        }

        return generated.code;
    }

    /**
     * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„ØªØ¹Ù„Ù…
     */
    public getLearningStatistics(): any {
        return {
            totalLessons: this.learnedLessons.size,
            totalLearningCycles: this.totalLearningCycles,
            improvementRate: (this.improvementRate * 100).toFixed(2) + "%",
            errorPatterns: this.errorPatterns.size,
            solutionsProposed: this.solutionHistory.length,
            compilerStats: this.compiler.getStatistics(),
            generatorStats: this.codeGenerator.getStatistics()
        };
    }

    /**
     * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ ØªÙ‚Ø±ÙŠØ± Ø´Ø§Ù…Ù„
     */
    public getComprehensiveReport(): string {
        let report = `â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n`;
        report += `â•‘        ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ù„ØºØ© Ø°Ø§ØªÙŠØ© Ø§Ù„ØªØ¹Ù„Ù… - Self-Learning Language        â•‘\n`;
        report += `â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n`;

        const stats = this.getLearningStatistics();

        report += `ğŸ“š Ø§Ù„Ø¯Ø±ÙˆØ³ Ø§Ù„Ù…Ø³ØªÙØ§Ø¯Ø©: ${stats.totalLessons}\n`;
        report += `ğŸ”„ Ø¯ÙˆØ±Ø§Øª Ø§Ù„ØªØ¹Ù„Ù…: ${stats.totalLearningCycles}\n`;
        report += `ğŸ“ˆ Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªØ­Ø³ÙŠÙ†: ${stats.improvementRate}\n`;
        report += `âš ï¸ Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ø£Ø®Ø·Ø§Ø¡: ${stats.errorPatterns}\n`;
        report += `ğŸ’¡ Ø§Ù„Ø­Ù„ÙˆÙ„ Ø§Ù„Ù…Ù‚ØªØ±Ø­Ø©: ${stats.solutionsProposed}\n\n`;

        report += `=== Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…ØªØ±Ø¬Ù… ===\n`;
        report += `Ø§Ù„ØªØ±Ø¬Ù…Ø§Øª Ø§Ù„ÙƒÙ„ÙŠØ©: ${stats.compilerStats.totalCompilations}\n`;
        report += `Ù…Ø¹Ø¯Ù„ Ø§Ù„Ù†Ø¬Ø§Ø­: ${stats.compilerStats.successRate}\n\n`;

        report += `=== Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…ÙˆÙ„Ø¯ ===\n`;
        report += `Ø§Ù„ØªÙˆÙ„ÙŠØ¯Ø§Øª Ø§Ù„ÙƒÙ„ÙŠØ©: ${stats.generatorStats.totalGenerations}\n`;
        report += `Ù…ØªÙˆØ³Ø· Ø§Ù„Ø¬ÙˆØ¯Ø©: ${stats.generatorStats.averageQuality}\n`;

        return report;
    }
}

