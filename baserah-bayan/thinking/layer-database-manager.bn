/**
 * Ù…Ø¯ÙŠØ± Ù‚ÙˆØ§Ø¹Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ø·Ø¨Ù‚Ø§Øª Ø§Ù„ØªÙÙƒÙŠØ± - Thinking Layers Database Manager
 * 
 * ğŸ—„ï¸ Ø¥Ø¯Ø§Ø±Ø© Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…ØªÙ†Ø§Ù…ÙŠØ© Ù„ÙƒÙ„ Ø·Ø¨Ù‚Ø© ØªÙÙƒÙŠØ±
 * ğŸ’¾ Ø­ÙØ¸ ÙˆØ§Ø³ØªØ±Ø¬Ø§Ø¹ Ø§Ù„Ù…Ø¹Ø±ÙØ© Ø§Ù„Ù…ØªØ®ØµØµØ©
 * ğŸ” Ø¨Ø­Ø« Ù…ØªÙ‚Ø¯Ù… ÙÙŠ Ø§Ù„Ù…Ø¹Ø±ÙØ©
 * ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª ÙˆÙ…Ù‚Ø§ÙŠÙŠØ³ Ø§Ù„Ø£Ø¯Ø§Ø¡
 * 
 * @author Ø¨Ø§Ø³Ù„ ÙŠØ­ÙŠÙ‰ Ø¹Ø¨Ø¯Ø§Ù„Ù„Ù‡
 * @version 1.0.0
 * @date 2025-10-28
 */

import { MotherEquation } from "../core/mother-equation.bn";

// ==================== Ø§Ù„ØªØ¹Ø¯Ø§Ø¯Ø§Øª ====================

/**
 * Ø£Ù†ÙˆØ§Ø¹ Ø·Ø¨Ù‚Ø§Øª Ø§Ù„ØªÙÙƒÙŠØ±
 */
enum LayerType {
    MATHEMATICAL = "Ø±ÙŠØ§Ø¶ÙŠØ©",
    LOGICAL = "Ù…Ù†Ø·Ù‚ÙŠØ©",
    INTERPRETIVE = "ØªÙØ³ÙŠØ±ÙŠØ©",
    PHYSICAL = "ÙÙŠØ²ÙŠØ§Ø¦ÙŠØ©",
    LINGUISTIC = "Ù„ØºÙˆÙŠØ©",
    SYMBOLIC = "Ø±Ù…Ø²ÙŠØ©",
    VISUAL = "Ø¨ØµØ±ÙŠØ©",
    SEMANTIC = "Ø¯Ù„Ø§Ù„ÙŠØ©",
    EVENT = "Ø£Ø­Ø¯Ø§Ø«",
    EMOTIONAL = "Ø¹Ø§Ø·ÙÙŠØ©",
    PROPERTY = "Ø®ØµØ§Ø¦Øµ"
}

/**
 * Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
 */
enum SearchType {
    EXACT = "Ù…Ø·Ø§Ø¨Ù‚_ØªÙ…Ø§Ù…Ø§Ù‹",
    CONTAINS = "ÙŠØ­ØªÙˆÙŠ",
    STARTS_WITH = "ÙŠØ¨Ø¯Ø£_Ø¨Ù€",
    ENDS_WITH = "ÙŠÙ†ØªÙ‡ÙŠ_Ø¨Ù€",
    PATTERN = "Ù†Ù…Ø·",
    SEMANTIC = "Ø¯Ù„Ø§Ù„ÙŠ",
    FUZZY = "ØªÙ‚Ø±ÙŠØ¨ÙŠ"
}

/**
 * Ù…Ø³ØªÙˆÙŠØ§Øª Ø§Ù„Ø«Ù‚Ø©
 */
enum ConfidenceLevel {
    VERY_LOW = "Ù…Ù†Ø®ÙØ¶_Ø¬Ø¯Ø§Ù‹",
    LOW = "Ù…Ù†Ø®ÙØ¶",
    MEDIUM = "Ù…ØªÙˆØ³Ø·",
    HIGH = "Ø¹Ø§Ù„ÙŠ",
    VERY_HIGH = "Ø¹Ø§Ù„ÙŠ_Ø¬Ø¯Ø§Ù‹",
    ABSOLUTE = "Ù…Ø·Ù„Ù‚"
}

/**
 * Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø¹Ø±ÙØ©
 */
enum KnowledgeStatus {
    PENDING = "Ù…Ø¹Ù„Ù‚",
    VERIFIED = "Ù…ÙˆØ«Ù‚",
    UNVERIFIED = "ØºÙŠØ±_Ù…ÙˆØ«Ù‚",
    CONFLICTING = "Ù…ØªØ¶Ø§Ø±Ø¨",
    DEPRECATED = "Ù‚Ø¯ÙŠÙ…",
    ACTIVE = "Ù†Ø´Ø·"
}

// ==================== Ø§Ù„ÙØ¦Ø§Øª ====================

/**
 * Ø¹Ù†ØµØ± Ù…Ø¹Ø±ÙÙŠ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
 */
class KnowledgeEntry extends MotherEquation {
    public id: number;
    public layerType: LayerType;
    public key: string;
    public value: string;
    public metadata: object;
    public confidence: number;
    public status: KnowledgeStatus;
    public source: string;
    public timestamp: number;
    public accessCount: number;
    public lastAccessed: number;
    
    constructor(
        id: number,
        layerType: LayerType,
        key: string,
        value: string,
        metadata: object = {},
        confidence: number = 0.8
    ) {
        super(`knowledge_entry_${id}`);
        
        this.id = id;
        this.layerType = layerType;
        this.key = key;
        this.value = value;
        this.metadata = metadata;
        this.confidence = confidence;
        this.status = KnowledgeStatus.ACTIVE;
        this.source = "system";
        this.timestamp = Date.now();
        this.accessCount = 0;
        this.lastAccessed = Date.now();
        
        // Î¦: Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø«Ø§Ø¨ØªØ©
        this.fixedProperties = {
            id: id,
            layerType: layerType,
            createdAt: this.timestamp
        };
        
        // Î¨: Ø§Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©
        this.dynamicStates = {
            value: value,
            confidence: confidence,
            status: this.status,
            accessCount: this.accessCount,
            lastAccessed: this.lastAccessed
        };
    }
    
    public updateValue(newValue: string, newConfidence: number = null): void {
        this.value = newValue;
        if (newConfidence !== null) {
            this.confidence = newConfidence;
        }
        this.timestamp = Date.now();
        
        this.dynamicStates.value = newValue;
        this.dynamicStates.confidence = this.confidence;
    }
    
    public incrementAccess(): void {
        this.accessCount++;
        this.lastAccessed = Date.now();
        
        this.dynamicStates.accessCount = this.accessCount;
        this.dynamicStates.lastAccessed = this.lastAccessed;
    }
    
    public getConfidenceLevel(): ConfidenceLevel {
        if (this.confidence >= 0.95) return ConfidenceLevel.ABSOLUTE;
        if (this.confidence >= 0.8) return ConfidenceLevel.VERY_HIGH;
        if (this.confidence >= 0.6) return ConfidenceLevel.HIGH;
        if (this.confidence >= 0.4) return ConfidenceLevel.MEDIUM;
        if (this.confidence >= 0.2) return ConfidenceLevel.LOW;
        return ConfidenceLevel.VERY_LOW;
    }
}

/**
 * Ø§Ø³ØªØ¹Ù„Ø§Ù… Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
 */
class DatabaseQuery extends MotherEquation {
    public layerType: LayerType | null;
    public searchType: SearchType;
    public searchTerm: string;
    public minConfidence: number;
    public maxResults: number;
    public filters: object;
    
    constructor(
        searchTerm: string,
        searchType: SearchType = SearchType.CONTAINS,
        layerType: LayerType | null = null
    ) {
        super("database_query");
        
        this.layerType = layerType;
        this.searchType = searchType;
        this.searchTerm = searchTerm;
        this.minConfidence = 0.0;
        this.maxResults = 100;
        this.filters = {};
        
        // Î¦: Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø«Ø§Ø¨ØªØ©
        this.fixedProperties = {
            searchType: searchType,
            createdAt: Date.now()
        };
        
        // Î¨: Ø§Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©
        this.dynamicStates = {
            searchTerm: searchTerm,
            layerType: layerType,
            minConfidence: this.minConfidence
        };
    }
    
    public setMinConfidence(minConf: number): DatabaseQuery {
        this.minConfidence = minConf;
        this.dynamicStates.minConfidence = minConf;
        return this;
    }
    
    public setMaxResults(max: number): DatabaseQuery {
        this.maxResults = max;
        return this;
    }
    
    public addFilter(key: string, value: any): DatabaseQuery {
        this.filters[key] = value;
        return this;
    }
}

/**
 * Ù…Ø¯ÙŠØ± Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ø·Ø¨Ù‚Ø© ÙˆØ§Ø­Ø¯Ø©
 */
class LayerDatabaseManager extends MotherEquation {
    public layerType: LayerType;
    public databasePath: string;
    public entries: Map<string, KnowledgeEntry>;
    public keyIndex: Map<string, Array<number>>;
    public nextId: number;
    
    // Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
    public totalEntries: number;
    public totalQueries: number;
    public cacheHits: number;
    public cacheMisses: number;
    
    constructor(layerType: LayerType, databasePath: string) {
        super(`layer_db_${layerType}`);
        
        this.layerType = layerType;
        this.databasePath = databasePath;
        this.entries = new Map();
        this.keyIndex = new Map();
        this.nextId = 1;
        
        this.totalEntries = 0;
        this.totalQueries = 0;
        this.cacheHits = 0;
        this.cacheMisses = 0;
        
        // Î¦: Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø«Ø§Ø¨ØªØ©
        this.fixedProperties = {
            layerType: layerType,
            databasePath: databasePath,
            createdAt: Date.now()
        };
        
        // Î¨: Ø§Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©
        this.dynamicStates = {
            totalEntries: 0,
            totalQueries: 0,
            cacheHitRate: 0.0
        };
        
        console.log(`ğŸ—„ï¸ ØªÙ‡ÙŠØ¦Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ø·Ø¨Ù‚Ø© ${layerType}`);
    }
    
    /**
     * Ø¥Ø¶Ø§ÙØ© Ø¹Ù†ØµØ± Ù…Ø¹Ø±ÙÙŠ
     */
    public addEntry(
        key: string,
        value: string,
        metadata: object = {},
        confidence: number = 0.8
    ): number {
        let entry = new KnowledgeEntry(
            this.nextId,
            this.layerType,
            key,
            value,
            metadata,
            confidence
        );
        
        this.entries.set(entry.id.toString(), entry);
        
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙÙ‡Ø±Ø³
        if (!this.keyIndex.has(key)) {
            this.keyIndex.set(key, []);
        }
        this.keyIndex.get(key)!.push(entry.id);
        
        this.nextId++;
        this.totalEntries++;
        this.dynamicStates.totalEntries = this.totalEntries;
        
        return entry.id;
    }

    /**
     * ØªØ­Ø¯ÙŠØ« Ø¹Ù†ØµØ± Ù…Ø¹Ø±ÙÙŠ
     */
    public updateEntry(id: number, newValue: string, newConfidence: number = null): boolean {
        let entry = this.entries.get(id.toString());
        if (entry) {
            entry.updateValue(newValue, newConfidence);
            return true;
        }
        return false;
    }

    /**
     * Ø­Ø°Ù Ø¹Ù†ØµØ± Ù…Ø¹Ø±ÙÙŠ
     */
    public deleteEntry(id: number): boolean {
        let entry = this.entries.get(id.toString());
        if (entry) {
            // Ø­Ø°Ù Ù…Ù† Ø§Ù„ÙÙ‡Ø±Ø³
            let keyEntries = this.keyIndex.get(entry.key);
            if (keyEntries) {
                let index = keyEntries.indexOf(id);
                if (index > -1) {
                    keyEntries.splice(index, 1);
                }
            }

            // Ø­Ø°Ù Ù…Ù† Ø§Ù„Ù‚Ø§Ù…ÙˆØ³
            this.entries.delete(id.toString());
            this.totalEntries--;
            this.dynamicStates.totalEntries = this.totalEntries;
            return true;
        }
        return false;
    }

    /**
     * Ø§Ù„Ø¨Ø­Ø« Ø¨Ø§Ù„Ù…ÙØªØ§Ø­
     */
    public searchByKey(key: string): Array<KnowledgeEntry> {
        this.totalQueries++;
        this.dynamicStates.totalQueries = this.totalQueries;

        let ids = this.keyIndex.get(key);
        if (!ids) {
            this.cacheMisses++;
            return [];
        }

        this.cacheHits++;
        this._updateCacheHitRate();

        let results: Array<KnowledgeEntry> = [];
        for (let id of ids) {
            let entry = this.entries.get(id.toString());
            if (entry) {
                entry.incrementAccess();
                results.push(entry);
            }
        }

        return results;
    }

    /**
     * Ø§Ù„Ø¨Ø­Ø« Ø§Ù„Ù…ØªÙ‚Ø¯Ù…
     */
    public search(query: DatabaseQuery): Array<KnowledgeEntry> {
        this.totalQueries++;
        this.dynamicStates.totalQueries = this.totalQueries;

        let results: Array<KnowledgeEntry> = [];

        for (let [id, entry] of this.entries) {
            // ØªØµÙÙŠØ© Ø­Ø³Ø¨ Ø§Ù„Ø«Ù‚Ø©
            if (entry.confidence < query.minConfidence) {
                continue;
            }

            // ØªØµÙÙŠØ© Ø­Ø³Ø¨ Ù†ÙˆØ¹ Ø§Ù„Ø¨Ø­Ø«
            let matches = false;

            if (query.searchType === SearchType.EXACT) {
                matches = entry.key === query.searchTerm || entry.value === query.searchTerm;
            } else if (query.searchType === SearchType.CONTAINS) {
                matches = entry.key.includes(query.searchTerm) || entry.value.includes(query.searchTerm);
            } else if (query.searchType === SearchType.STARTS_WITH) {
                matches = entry.key.startsWith(query.searchTerm) || entry.value.startsWith(query.searchTerm);
            } else if (query.searchType === SearchType.ENDS_WITH) {
                matches = entry.key.endsWith(query.searchTerm) || entry.value.endsWith(query.searchTerm);
            } else if (query.searchType === SearchType.PATTERN) {
                // Ø¨Ø­Ø« Ù†Ù…Ø·ÙŠ Ø¨Ø³ÙŠØ·
                let pattern = query.searchTerm.replace(/%/g, ".*").replace(/_/g, ".");
                let regex = new RegExp(pattern);
                matches = regex.test(entry.key) || regex.test(entry.value);
            }

            if (matches) {
                entry.incrementAccess();
                results.push(entry);

                if (results.length >= query.maxResults) {
                    break;
                }
            }
        }

        // ØªØ±ØªÙŠØ¨ Ø­Ø³Ø¨ Ø§Ù„Ø«Ù‚Ø©
        results.sort((a, b) => b.confidence - a.confidence);

        return results;
    }

    /**
     * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø£ÙƒØ«Ø± Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ø³ØªØ®Ø¯Ø§Ù…Ø§Ù‹
     */
    public getMostAccessed(limit: number = 10): Array<KnowledgeEntry> {
        let allEntries = Array.from(this.entries.values());
        allEntries.sort((a, b) => b.accessCount - a.accessCount);
        return allEntries.slice(0, limit);
    }

    /**
     * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø£Ø­Ø¯Ø« Ø§Ù„Ø¹Ù†Ø§ØµØ±
     */
    public getRecent(limit: number = 10): Array<KnowledgeEntry> {
        let allEntries = Array.from(this.entries.values());
        allEntries.sort((a, b) => b.timestamp - a.timestamp);
        return allEntries.slice(0, limit);
    }

    /**
     * ØªØ­Ø¯ÙŠØ« Ù…Ø¹Ø¯Ù„ Ù†Ø¬Ø§Ø­ Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„Ù…Ø¤Ù‚ØªØ©
     */
    private _updateCacheHitRate(): void {
        let total = this.cacheHits + this.cacheMisses;
        if (total > 0) {
            this.dynamicStates.cacheHitRate = this.cacheHits / total;
        }
    }

    /**
     * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
     */
    public getStatistics(): object {
        return {
            layerType: this.layerType,
            totalEntries: this.totalEntries,
            totalQueries: this.totalQueries,
            cacheHits: this.cacheHits,
            cacheMisses: this.cacheMisses,
            cacheHitRate: this.dynamicStates.cacheHitRate,
            averageConfidence: this._calculateAverageConfidence(),
            databaseSize: this._estimateDatabaseSize()
        };
    }

    private _calculateAverageConfidence(): number {
        if (this.totalEntries === 0) return 0.0;

        let sum = 0;
        for (let [id, entry] of this.entries) {
            sum += entry.confidence;
        }
        return sum / this.totalEntries;
    }

    private _estimateDatabaseSize(): string {
        let size = this.totalEntries * 500; // ØªÙ‚Ø¯ÙŠØ± 500 Ø¨Ø§ÙŠØª Ù„ÙƒÙ„ Ø¹Ù†ØµØ±
        if (size < 1024) return `${size} B`;
        if (size < 1024 * 1024) return `${(size / 1024).toFixed(2)} KB`;
        return `${(size / (1024 * 1024)).toFixed(2)} MB`;
    }

    /**
     * ØªØµØ¯ÙŠØ± Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¥Ù„Ù‰ JSON
     */
    public exportToJSON(): string {
        let data = {
            layerType: this.layerType,
            entries: Array.from(this.entries.values()).map(entry => ({
                id: entry.id,
                key: entry.key,
                value: entry.value,
                metadata: entry.metadata,
                confidence: entry.confidence,
                status: entry.status,
                timestamp: entry.timestamp,
                accessCount: entry.accessCount
            })),
            statistics: this.getStatistics()
        };

        return JSON.stringify(data, null, 2);
    }

    /**
     * Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† JSON
     */
    public importFromJSON(jsonData: string): number {
        try {
            let data = JSON.parse(jsonData);
            let imported = 0;

            for (let entryData of data.entries) {
                this.addEntry(
                    entryData.key,
                    entryData.value,
                    entryData.metadata || {},
                    entryData.confidence || 0.8
                );
                imported++;
            }

            console.log(`âœ… ØªÙ… Ø§Ø³ØªÙŠØ±Ø§Ø¯ ${imported} Ø¹Ù†ØµØ± Ù…Ø¹Ø±ÙÙŠ`);
            return imported;
        } catch (error) {
            console.error(`âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§Ø³ØªÙŠØ±Ø§Ø¯: ${error}`);
            return 0;
        }
    }
}

// ==================== Ø§Ù„ØªØµØ¯ÙŠØ± ====================

export {
    LayerType,
    SearchType,
    ConfidenceLevel,
    KnowledgeStatus,
    KnowledgeEntry,
    DatabaseQuery,
    LayerDatabaseManager
};
