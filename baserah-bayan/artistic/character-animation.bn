// ============================================================================
// character-animation.bn
// نظام تحريك الشخصيات والعظام
// 
// هذا النظام يوفر:
// - نظام عظام (Skeletal System)
// - تحريك إجرائي (Procedural Animation)
// - تحريك بالإطارات المفتاحية (Keyframe Animation)
// - تحريك العضلات والمفاصل
// - تعبيرات الوجه
// ============================================================================

import { MotherEquation } from "../core/mother-equation.bn";
import { Vector2D, PhysicsBody } from "./physics-based-animation.bn";

// ============================================================================
// التعدادات (Enums)
// ============================================================================

enum BoneType {
    ROOT = "root",
    SPINE = "spine",
    HEAD = "head",
    ARM = "arm",
    LEG = "leg",
    HAND = "hand",
    FOOT = "foot",
    CUSTOM = "custom"
}

enum AnimationType {
    IDLE = "idle",
    WALK = "walk",
    RUN = "run",
    JUMP = "jump",
    ATTACK = "attack",
    DEFEND = "defend",
    CUSTOM = "custom"
}

enum InterpolationType {
    LINEAR = "linear",
    EASE_IN = "ease_in",
    EASE_OUT = "ease_out",
    EASE_IN_OUT = "ease_in_out",
    BEZIER = "bezier"
}

enum FacialExpression {
    NEUTRAL = "neutral",
    HAPPY = "happy",
    SAD = "sad",
    ANGRY = "angry",
    SURPRISED = "surprised",
    FEAR = "fear",
    DISGUST = "disgust",
    CUSTOM = "custom"
}

// ============================================================================
// Bone - عظمة
// ============================================================================

class Bone extends MotherEquation {
    public boneId: string;
    public boneName: string;
    public boneType: BoneType;
    public position: Vector2D;
    public rotation: number;
    public length: number;
    public parent: Bone;
    public children: array<Bone>;
    public localPosition: Vector2D;
    public localRotation: number;

    constructor(boneId: string, boneName: string, boneType: BoneType, length: number) {
        super(boneId);
        
        this.boneId = boneId;
        this.boneName = boneName;
        this.boneType = boneType;
        this.position = new Vector2D(0, 0);
        this.rotation = 0;
        this.length = length;
        this.parent = null;
        this.children = [];
        this.localPosition = new Vector2D(0, 0);
        this.localRotation = 0;

        // Φ: الخصائص الثابتة
        this.fixedProperties = {
            boneId: boneId,
            boneName: boneName,
            boneType: boneType,
            length: length
        };

        // Ψ: الحالات الديناميكية
        this.dynamicStates = {
            position: this.position,
            rotation: this.rotation,
            localPosition: this.localPosition,
            localRotation: this.localRotation
        };
    }

    // إضافة عظمة فرعية
    public addChild(child: Bone): void {
        child.parent = this;
        this.children.push(child);
    }

    // تحديث الموقع العالمي
    public updateWorldTransform(): void {
        if (this.parent) {
            // حساب الموقع العالمي من الموقع المحلي
            let parentEndX = this.parent.position.x + Math.cos(this.parent.rotation) * this.parent.length;
            let parentEndY = this.parent.position.y + Math.sin(this.parent.rotation) * this.parent.length;
            
            this.position.x = parentEndX + this.localPosition.x;
            this.position.y = parentEndY + this.localPosition.y;
            this.rotation = this.parent.rotation + this.localRotation;
        } else {
            // العظمة الجذر
            this.position = this.localPosition.clone();
            this.rotation = this.localRotation;
        }

        // تحديث جميع الأطفال
        for (let i = 0; i < this.children.length; i++) {
            this.children[i].updateWorldTransform();
        }

        // تحديث الحالات الديناميكية
        this.dynamicStates.position = this.position;
        this.dynamicStates.rotation = this.rotation;
    }

    // الحصول على نقطة النهاية
    public getEndPoint(): Vector2D {
        let endX = this.position.x + Math.cos(this.rotation) * this.length;
        let endY = this.position.y + Math.sin(this.rotation) * this.length;
        return new Vector2D(endX, endY);
    }
}

// ============================================================================
// Keyframe - إطار مفتاحي
// ============================================================================

class Keyframe extends MotherEquation {
    public keyframeId: string;
    public time: number;
    public boneId: string;
    public position: Vector2D;
    public rotation: number;
    public interpolation: InterpolationType;

    constructor(keyframeId: string, time: number, boneId: string, position: Vector2D, rotation: number) {
        super(keyframeId);
        
        this.keyframeId = keyframeId;
        this.time = time;
        this.boneId = boneId;
        this.position = position;
        this.rotation = rotation;
        this.interpolation = InterpolationType.LINEAR;

        // Φ: الخصائص الثابتة
        this.fixedProperties = {
            keyframeId: keyframeId,
            time: time,
            boneId: boneId
        };

        // Ψ: الحالات الديناميكية
        this.dynamicStates = {
            position: position,
            rotation: rotation,
            interpolation: this.interpolation
        };
    }
}

// ============================================================================
// AnimationClip - مقطع تحريك
// ============================================================================

class AnimationClip extends MotherEquation {
    public clipId: string;
    public clipName: string;
    public animationType: AnimationType;
    public duration: number;
    public keyframes: array<Keyframe>;
    public isLooping: boolean;

    constructor(clipId: string, clipName: string, animationType: AnimationType, duration: number) {
        super(clipId);
        
        this.clipId = clipId;
        this.clipName = clipName;
        this.animationType = animationType;
        this.duration = duration;
        this.keyframes = [];
        this.isLooping = true;

        // Φ: الخصائص الثابتة
        this.fixedProperties = {
            clipId: clipId,
            clipName: clipName,
            animationType: animationType
        };

        // Ψ: الحالات الديناميكية
        this.dynamicStates = {
            duration: duration,
            keyframeCount: 0,
            isLooping: this.isLooping
        };
    }

    // إضافة إطار مفتاحي
    public addKeyframe(keyframe: Keyframe): void {
        this.keyframes.push(keyframe);
        this.keyframes.sort((a, b) => a.time - b.time);
        this.dynamicStates.keyframeCount = this.keyframes.length;
    }

    // الحصول على الإطارات المحيطة بوقت معين
    public getSurroundingKeyframes(boneId: string, time: number): object {
        let boneKeyframes = this.keyframes.filter(kf => kf.boneId === boneId);
        
        if (boneKeyframes.length === 0) return null;
        if (boneKeyframes.length === 1) return { before: boneKeyframes[0], after: boneKeyframes[0], t: 0 };

        let before = boneKeyframes[0];
        let after = boneKeyframes[boneKeyframes.length - 1];

        for (let i = 0; i < boneKeyframes.length - 1; i++) {
            if (boneKeyframes[i].time <= time && boneKeyframes[i + 1].time >= time) {
                before = boneKeyframes[i];
                after = boneKeyframes[i + 1];
                break;
            }
        }

        // حساب معامل الاستيفاء
        let t = 0;
        if (after.time !== before.time) {
            t = (time - before.time) / (after.time - before.time);
        }

        return { before: before, after: after, t: t };
    }

    // استيفاء القيمة
    public interpolate(before: Keyframe, after: Keyframe, t: number): object {
        let interpolationType = before.interpolation;
        
        // تطبيق نوع الاستيفاء
        let adjustedT = t;
        if (interpolationType === InterpolationType.EASE_IN) {
            adjustedT = t * t;
        } else if (interpolationType === InterpolationType.EASE_OUT) {
            adjustedT = 1 - (1 - t) * (1 - t);
        } else if (interpolationType === InterpolationType.EASE_IN_OUT) {
            adjustedT = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
        }

        // استيفاء الموقع
        let position = new Vector2D(
            before.position.x + (after.position.x - before.position.x) * adjustedT,
            before.position.y + (after.position.y - before.position.y) * adjustedT
        );

        // استيفاء الدوران
        let rotation = before.rotation + (after.rotation - before.rotation) * adjustedT;

        return { position: position, rotation: rotation };
    }
}

// ============================================================================
// Skeleton - هيكل عظمي
// ============================================================================

class Skeleton extends MotherEquation {
    public skeletonId: string;
    public skeletonName: string;
    public rootBone: Bone;
    public bones: array<Bone>;
    public boneMap: object;

    constructor(skeletonId: string, skeletonName: string) {
        super(skeletonId);
        
        this.skeletonId = skeletonId;
        this.skeletonName = skeletonName;
        this.rootBone = null;
        this.bones = [];
        this.boneMap = {};

        // Φ: الخصائص الثابتة
        this.fixedProperties = {
            skeletonId: skeletonId,
            skeletonName: skeletonName
        };

        // Ψ: الحالات الديناميكية
        this.dynamicStates = {
            boneCount: 0,
            isInitialized: false
        };
    }

    // إضافة عظمة
    public addBone(bone: Bone, parentBoneId: string): void {
        this.bones.push(bone);
        this.boneMap[bone.boneId] = bone;

        if (!parentBoneId) {
            this.rootBone = bone;
        } else {
            let parent = this.boneMap[parentBoneId];
            if (parent) {
                parent.addChild(bone);
            }
        }

        this.dynamicStates.boneCount = this.bones.length;
        this.dynamicStates.isInitialized = this.rootBone !== null;
    }

    // الحصول على عظمة
    public getBone(boneId: string): Bone {
        return this.boneMap[boneId];
    }

    // تحديث جميع العظام
    public update(): void {
        if (this.rootBone) {
            this.rootBone.updateWorldTransform();
        }
    }
}

// ============================================================================
// CharacterAnimator - محرك تحريك الشخصية
// ============================================================================

class CharacterAnimator extends MotherEquation {
    public animatorId: string;
    public skeleton: Skeleton;
    public currentClip: AnimationClip;
    public currentTime: number;
    public isPlaying: boolean;
    public playbackSpeed: number;
    public clips: array<AnimationClip>;

    constructor(animatorId: string, skeleton: Skeleton) {
        super(animatorId);

        this.animatorId = animatorId;
        this.skeleton = skeleton;
        this.currentClip = null;
        this.currentTime = 0;
        this.isPlaying = false;
        this.playbackSpeed = 1.0;
        this.clips = [];

        // Φ: الخصائص الثابتة
        this.fixedProperties = {
            animatorId: animatorId,
            skeleton: skeleton
        };

        // Ψ: الحالات الديناميكية
        this.dynamicStates = {
            currentTime: this.currentTime,
            isPlaying: this.isPlaying,
            playbackSpeed: this.playbackSpeed,
            clipCount: 0
        };
    }

    // إضافة مقطع تحريك
    public addClip(clip: AnimationClip): void {
        this.clips.push(clip);
        this.dynamicStates.clipCount = this.clips.length;
    }

    // تشغيل مقطع
    public play(clipName: string): void {
        let clip = this.clips.find(c => c.clipName === clipName);
        if (!clip) return;

        this.currentClip = clip;
        this.currentTime = 0;
        this.isPlaying = true;
        this.dynamicStates.isPlaying = true;
    }

    // إيقاف مؤقت
    public pause(): void {
        this.isPlaying = false;
        this.dynamicStates.isPlaying = false;
    }

    // استئناف
    public resume(): void {
        this.isPlaying = true;
        this.dynamicStates.isPlaying = true;
    }

    // إيقاف
    public stop(): void {
        this.isPlaying = false;
        this.currentTime = 0;
        this.dynamicStates.isPlaying = false;
        this.dynamicStates.currentTime = 0;
    }

    // تحديث التحريك
    public update(deltaTime: number): void {
        if (!this.isPlaying || !this.currentClip) return;

        // تحديث الوقت
        this.currentTime += deltaTime * this.playbackSpeed;

        // التعامل مع التكرار
        if (this.currentTime >= this.currentClip.duration) {
            if (this.currentClip.isLooping) {
                this.currentTime = this.currentTime % this.currentClip.duration;
            } else {
                this.currentTime = this.currentClip.duration;
                this.isPlaying = false;
            }
        }

        // تطبيق الإطارات المفتاحية على العظام
        for (let i = 0; i < this.skeleton.bones.length; i++) {
            let bone = this.skeleton.bones[i];
            let surrounding = this.currentClip.getSurroundingKeyframes(bone.boneId, this.currentTime);

            if (surrounding) {
                let interpolated = this.currentClip.interpolate(
                    surrounding.before,
                    surrounding.after,
                    surrounding.t
                );

                bone.localPosition = interpolated.position;
                bone.localRotation = interpolated.rotation;
            }
        }

        // تحديث الهيكل العظمي
        this.skeleton.update();

        this.dynamicStates.currentTime = this.currentTime;
    }

    // الحصول على التقدم (0-1)
    public getProgress(): number {
        if (!this.currentClip) return 0;
        return this.currentTime / this.currentClip.duration;
    }
}

// ============================================================================
// FacialAnimator - محرك تحريك الوجه
// ============================================================================

class FacialAnimator extends MotherEquation {
    public animatorId: string;
    public currentExpression: FacialExpression;
    public blendShapes: object;
    public transitionTime: number;
    public transitionDuration: number;
    public isTransitioning: boolean;

    constructor(animatorId: string) {
        super(animatorId);

        this.animatorId = animatorId;
        this.currentExpression = FacialExpression.NEUTRAL;
        this.blendShapes = {
            eyebrowRaise: 0,
            eyebrowFurrow: 0,
            eyeOpen: 1,
            mouthSmile: 0,
            mouthFrown: 0,
            mouthOpen: 0
        };
        this.transitionTime = 0;
        this.transitionDuration = 0.3;
        this.isTransitioning = false;

        // Φ: الخصائص الثابتة
        this.fixedProperties = {
            animatorId: animatorId
        };

        // Ψ: الحالات الديناميكية
        this.dynamicStates = {
            currentExpression: this.currentExpression,
            blendShapes: this.blendShapes,
            isTransitioning: this.isTransitioning
        };
    }

    // تعيين تعبير
    public setExpression(expression: FacialExpression): void {
        if (expression === this.currentExpression) return;

        this.currentExpression = expression;
        this.isTransitioning = true;
        this.transitionTime = 0;

        // تعيين قيم الأشكال المدمجة حسب التعبير
        let targetShapes = this.getExpressionBlendShapes(expression);

        // هنا يمكن إضافة انتقال سلس
        this.blendShapes = targetShapes;

        this.dynamicStates.currentExpression = expression;
        this.dynamicStates.blendShapes = this.blendShapes;
    }

    // الحصول على قيم الأشكال المدمجة للتعبير
    private getExpressionBlendShapes(expression: FacialExpression): object {
        switch (expression) {
            case FacialExpression.HAPPY:
                return {
                    eyebrowRaise: 0.3,
                    eyebrowFurrow: 0,
                    eyeOpen: 0.8,
                    mouthSmile: 1.0,
                    mouthFrown: 0,
                    mouthOpen: 0.2
                };
            case FacialExpression.SAD:
                return {
                    eyebrowRaise: 0,
                    eyebrowFurrow: 0.5,
                    eyeOpen: 0.6,
                    mouthSmile: 0,
                    mouthFrown: 0.8,
                    mouthOpen: 0
                };
            case FacialExpression.ANGRY:
                return {
                    eyebrowRaise: 0,
                    eyebrowFurrow: 1.0,
                    eyeOpen: 1.0,
                    mouthSmile: 0,
                    mouthFrown: 0.6,
                    mouthOpen: 0.3
                };
            case FacialExpression.SURPRISED:
                return {
                    eyebrowRaise: 1.0,
                    eyebrowFurrow: 0,
                    eyeOpen: 1.0,
                    mouthSmile: 0,
                    mouthFrown: 0,
                    mouthOpen: 0.8
                };
            case FacialExpression.FEAR:
                return {
                    eyebrowRaise: 0.8,
                    eyebrowFurrow: 0.3,
                    eyeOpen: 1.0,
                    mouthSmile: 0,
                    mouthFrown: 0.4,
                    mouthOpen: 0.5
                };
            default:
                return {
                    eyebrowRaise: 0,
                    eyebrowFurrow: 0,
                    eyeOpen: 1,
                    mouthSmile: 0,
                    mouthFrown: 0,
                    mouthOpen: 0
                };
        }
    }

    // تحديث
    public update(deltaTime: number): void {
        if (this.isTransitioning) {
            this.transitionTime += deltaTime;
            if (this.transitionTime >= this.transitionDuration) {
                this.isTransitioning = false;
                this.dynamicStates.isTransitioning = false;
            }
        }
    }
}

export {
    Bone,
    Keyframe,
    AnimationClip,
    Skeleton,
    CharacterAnimator,
    FacialAnimator,
    BoneType,
    AnimationType,
    InterpolationType,
    FacialExpression
};

