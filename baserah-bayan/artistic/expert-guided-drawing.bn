/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ù…ÙˆØ¬Ù‡ Ø¨Ø§Ù„Ø®Ø¨ÙŠØ± - Expert-Guided Drawing
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * ØªÙƒØ§Ù…Ù„ Ø§Ù„ÙˆØ­Ø¯Ø© Ø§Ù„ÙÙ†ÙŠØ© Ù…Ø¹ Ù†Ø¸Ø§Ù… Ø§Ù„Ø®Ø¨ÙŠØ±/Ø§Ù„Ù…Ø³ØªÙƒØ´Ù
 * Integration of Artistic Unit with Expert/Explorer System
 * 
 * Ø§Ù„Ù…ÙÙ‡ÙˆÙ…:
 * - Ø§Ù„Ø®Ø¨ÙŠØ± ÙŠÙ‚ÙˆØ¯ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø±Ø³Ù…
 * - Ø§Ù„Ù…Ø³ØªÙƒØ´Ù ÙŠÙƒØªØ´Ù Ø£Ù†Ù…Ø§Ø· Ø¬Ø¯ÙŠØ¯Ø©
 * - Ø§Ù„Ù†Ø¸Ø±ÙŠØ§Øª Ø§Ù„Ø«Ù„Ø§Ø« ØªØ·Ø¨Ù‚ Ø¹Ù„Ù‰ Ø§Ù„Ø±Ø³Ù…
 * - Ø§Ù„ØªÙƒÙŠÙ Ø§Ù„Ø°ÙƒÙŠ Ù„Ù„Ø£Ø´ÙƒØ§Ù„
 * 
 * @author Baserah AI System
 * @version 1.0.0
 * @date 2025-10-26
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

import { 
    GeneralShapeEquation, 
    ShapeType, 
    Color,
    StyleProperties
} from "./general-shape-equation.bn";

import { ClassicDrawingEngine } from "./classic-drawing-engine.bn";

import { 
    BaserahIntegratedExpertExplorer,
    ExpertiseLevel,
    ExplorationStrategy
} from "../brain/integrated-expert-explorer.bn";

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ù†Ø¸Ø§Ù… Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ù…ÙˆØ¬Ù‡ Ø¨Ø§Ù„Ø®Ø¨ÙŠØ±
// Expert-Guided Drawing System
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class ExpertGuidedDrawingSystem {
    brain: BaserahIntegratedExpertExplorer;
    drawingEngine: ClassicDrawingEngine;
    currentShape: GeneralShapeEquation;
    drawingHistory: GeneralShapeEquation[];
    
    constructor(canvasId: string, width: number = 800, height: number = 600) {
        // Ø¥Ù†Ø´Ø§Ø¡ Ø¯Ù…Ø§Øº Ø§Ù„Ù†Ø¸Ø§Ù…
        this.brain = new BaserahIntegratedExpertExplorer(
            "ArtisticBrain",
            "drawing_and_inference"
        );
        
        // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø­Ø±Ùƒ Ø§Ù„Ø±Ø³Ù…
        this.drawingEngine = new ClassicDrawingEngine(canvasId, width, height);
        
        this.currentShape = null;
        this.drawingHistory = [];
        
        console.log("ğŸ¨ ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø¸Ø§Ù… Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ù…ÙˆØ¬Ù‡ Ø¨Ø§Ù„Ø®Ø¨ÙŠØ±");
    }
    
    function initialize(): boolean {
        /**
         * ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù†Ø¸Ø§Ù…
         * Initialize system
         */
        if (!this.drawingEngine.initialize()) {
            console.log("âŒ ÙØ´Ù„ ØªÙ‡ÙŠØ¦Ø© Ù…Ø­Ø±Ùƒ Ø§Ù„Ø±Ø³Ù…");
            return false;
        }
        
        // Ø¥Ø¶Ø§ÙØ© Ù…Ø¹Ø±ÙØ© Ø£Ø³Ø§Ø³ÙŠØ© Ù„Ù„Ø®Ø¨ÙŠØ±
        this.brain.expert.addKnowledge("drawing_basics", {
            shapes: ["line", "circle", "bezier", "sine", "parametric"],
            styles: ["solid", "dashed", "dotted"],
            colors: ["red", "green", "blue", "black"]
        });
        
        console.log("âœ… ØªÙ… ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù†Ø¸Ø§Ù… Ø¨Ù†Ø¬Ø§Ø­");
        return true;
    }
    
    // â•â•â• Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ù…ÙˆØ¬Ù‡ Ø¨Ø§Ù„Ø®Ø¨ÙŠØ± â•â•â•
    
    function expertGuidedDraw(task: object): GeneralShapeEquation {
        /**
         * Ø±Ø³Ù… Ù…ÙˆØ¬Ù‡ Ø¨Ù‚Ø±Ø§Ø±Ø§Øª Ø§Ù„Ø®Ø¨ÙŠØ±
         * Drawing guided by expert decisions
         */
        console.log("\nğŸ§  Ø¨Ø¯Ø¡ Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ù…ÙˆØ¬Ù‡ Ø¨Ø§Ù„Ø®Ø¨ÙŠØ±");
        console.log(`   Ø§Ù„Ù…Ù‡Ù…Ø©: ${task.description}`);
        
        // Ø§Ù„Ø®Ø¨ÙŠØ± ÙŠØªØ®Ø° Ù‚Ø±Ø§Ø± Ø­ÙˆÙ„ ÙƒÙŠÙÙŠØ© Ø§Ù„Ø±Ø³Ù…
        let decision = this.brain.expert.makeRevolutionaryExpertDecision({
            task: "decide_drawing_approach",
            requirements: task,
            context: {
                history: this.drawingHistory.length,
                expertise: this.brain.expert.expertiseLevel
            }
        });
        
        console.log(`   Ù‚Ø±Ø§Ø± Ø§Ù„Ø®Ø¨ÙŠØ±: ${decision.decision}`);
        console.log(`   Ø§Ù„Ø«Ù‚Ø©: ${decision.confidence}`);
        
        // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø´ÙƒÙ„ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù‚Ø±Ø§Ø±
        let shape = this.createShapeFromDecision(decision, task);
        
        // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù†Ø¸Ø±ÙŠØ§Øª Ø§Ù„Ø«Ù„Ø§Ø«
        this.applyRevolutionaryTheories(shape, decision);
        
        // Ø±Ø³Ù… Ø§Ù„Ø´ÙƒÙ„
        this.drawingEngine.drawEquation(shape);
        
        // Ø­ÙØ¸ ÙÙŠ Ø§Ù„ØªØ§Ø±ÙŠØ®
        this.drawingHistory.push(shape);
        this.currentShape = shape;
        
        // Ø§Ù„Ø®Ø¨ÙŠØ± ÙŠØªØ¹Ù„Ù… Ù…Ù† Ø§Ù„Ù†ØªÙŠØ¬Ø©
        this.brain.expert.learnFromOutcome({
            task: task,
            decision: decision,
            outcome: {
                success: true,
                shape: shape.shapeName,
                terms: shape.mathematicalTerms.length
            }
        });
        
        console.log(`âœ… ØªÙ… Ø±Ø³Ù…: ${shape.shapeName}`);
        
        return shape;
    }
    
    function exploratoryDraw(constraints: object): GeneralShapeEquation {
        /**
         * Ø±Ø³Ù… Ø§Ø³ØªÙƒØ´Ø§ÙÙŠ Ø¨Ù‚ÙŠØ§Ø¯Ø© Ø§Ù„Ù…Ø³ØªÙƒØ´Ù
         * Exploratory drawing led by explorer
         */
        console.log("\nğŸ” Ø¨Ø¯Ø¡ Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø§Ø³ØªÙƒØ´Ø§ÙÙŠ");
        
        // Ø§Ù„Ù…Ø³ØªÙƒØ´Ù ÙŠØ³ØªÙƒØ´Ù Ø¥Ù…ÙƒØ§Ù†ÙŠØ§Øª Ø¬Ø¯ÙŠØ¯Ø©
        let exploration = this.brain.explorer.exploreRevolutionary({
            task: "discover_new_shapes",
            constraints: constraints,
            context: {
                history: this.drawingHistory
            }
        });
        
        console.log(`   Ø§ÙƒØªØ´Ø§Ù: ${exploration.discoveries.length} Ø¥Ù…ÙƒØ§Ù†ÙŠØ§Øª`);
        
        // Ø§Ø®ØªÙŠØ§Ø± Ø£ÙØ¶Ù„ Ø§ÙƒØªØ´Ø§Ù
        let bestDiscovery = exploration.discoveries[0];
        
        // Ø¥Ù†Ø´Ø§Ø¡ Ø´ÙƒÙ„ Ù…Ù† Ø§Ù„Ø§ÙƒØªØ´Ø§Ù
        let shape = this.createShapeFromExploration(bestDiscovery, constraints);
        
        // Ø±Ø³Ù… Ø§Ù„Ø´ÙƒÙ„
        this.drawingEngine.drawEquation(shape);
        
        // Ø­ÙØ¸ ÙÙŠ Ø§Ù„ØªØ§Ø±ÙŠØ®
        this.drawingHistory.push(shape);
        this.currentShape = shape;
        
        console.log(`âœ… ØªÙ… Ø±Ø³Ù… Ø´ÙƒÙ„ Ø§Ø³ØªÙƒØ´Ø§ÙÙŠ: ${shape.shapeName}`);
        
        return shape;
    }
    
    // â•â•â• ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù†Ø¸Ø±ÙŠØ§Øª Ø§Ù„Ø«ÙˆØ±ÙŠØ© â•â•â•
    
    function applyRevolutionaryTheories(shape: GeneralShapeEquation, decision: object): void {
        /**
         * ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù†Ø¸Ø±ÙŠØ§Øª Ø§Ù„Ø«Ù„Ø§Ø« Ø¹Ù„Ù‰ Ø§Ù„Ø´ÙƒÙ„
         * Apply three revolutionary theories to shape
         */
        console.log("   ğŸ”¬ ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù†Ø¸Ø±ÙŠØ§Øª Ø§Ù„Ø«ÙˆØ±ÙŠØ©:");
        
        // 1. Ù†Ø¸Ø±ÙŠØ© Ø«Ù†Ø§Ø¦ÙŠØ© Ø§Ù„ØµÙØ±
        this.applyZeroDuality(shape, decision);
        
        // 2. Ù†Ø¸Ø±ÙŠØ© ØªØ¹Ø§Ù…Ø¯ Ø§Ù„Ø£Ø¶Ø¯Ø§Ø¯
        this.applyPerpendicularOpposites(shape, decision);
        
        // 3. Ù†Ø¸Ø±ÙŠØ© Ø§Ù„ÙØªØ§Ø¦Ù„
        this.applyFilamentTheory(shape, decision);
    }
    
    function applyZeroDuality(shape: GeneralShapeEquation, decision: object): void {
        /**
         * ØªØ·Ø¨ÙŠÙ‚ Ù†Ø¸Ø±ÙŠØ© Ø«Ù†Ø§Ø¦ÙŠØ© Ø§Ù„ØµÙØ±
         * Apply Zero Duality Theory
         */
        let factor = this.brain.expert.zeroDualityFactor;
        
        // Ø¥Ø¶Ø§ÙØ© Ø¹Ù†ØµØ± Ù…ØªÙˆØ§Ø²Ù† (Ù…Ø«Ø§Ù„: Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ø®Ø·ØŒ Ø£Ø¶Ù Ø®Ø·Ù‡ Ø§Ù„Ù…Ø¹Ø§ÙƒØ³)
        if (shape.mathematicalTerms.length > 0 && factor > 0.5) {
            let firstTerm = shape.mathematicalTerms[0];
            
            if (firstTerm.termType == "line") {
                // Ø¥Ø¶Ø§ÙØ© Ø®Ø· Ù…Ø¹Ø§ÙƒØ³ Ù„Ù„ØªÙˆØ§Ø²Ù†
                let params = firstTerm.parameters;
                let centerX = (params.x1 + params.x2) / 2;
                let centerY = (params.y1 + params.y2) / 2;
                
                // Ø®Ø· Ù…Ø¹Ø§ÙƒØ³ Ø­ÙˆÙ„ Ø§Ù„Ù…Ø±ÙƒØ²
                let oppositeX1 = 2 * centerX - params.x1;
                let oppositeY1 = 2 * centerY - params.y1;
                let oppositeX2 = 2 * centerX - params.x2;
                let oppositeY2 = 2 * centerY - params.y2;
                
                shape.addLineTerm(oppositeX1, oppositeY1, oppositeX2, oppositeY2);
                
                console.log(`      âœ“ Ø«Ù†Ø§Ø¦ÙŠØ© Ø§Ù„ØµÙØ±: Ø£Ø¶ÙŠÙ Ø®Ø· Ù…ØªÙˆØ§Ø²Ù† (Ø¹Ø§Ù…Ù„: ${factor})`);
            }
        }
    }
    
    function applyPerpendicularOpposites(shape: GeneralShapeEquation, decision: object): void {
        /**
         * ØªØ·Ø¨ÙŠÙ‚ Ù†Ø¸Ø±ÙŠØ© ØªØ¹Ø§Ù…Ø¯ Ø§Ù„Ø£Ø¶Ø¯Ø§Ø¯
         * Apply Perpendicular Opposites Theory
         */
        let strength = this.brain.expert.perpendicularStrength;
        
        // Ø¥Ø¶Ø§ÙØ© Ø¹Ù†ØµØ± Ù…ØªØ¹Ø§Ù…Ø¯ (Ù…Ø«Ø§Ù„: Ø®Ø· Ø¹Ù…ÙˆØ¯ÙŠ Ø¹Ù„Ù‰ Ø®Ø· Ø£ÙÙ‚ÙŠ)
        if (shape.mathematicalTerms.length > 0 && strength > 0.5) {
            let firstTerm = shape.mathematicalTerms[0];
            
            if (firstTerm.termType == "line") {
                let params = firstTerm.parameters;
                
                // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø±ÙƒØ²
                let centerX = (params.x1 + params.x2) / 2;
                let centerY = (params.y1 + params.y2) / 2;
                
                // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø¹Ù…ÙˆØ¯ÙŠ
                let dx = params.x2 - params.x1;
                let dy = params.y2 - params.y1;
                let length = Math.sqrt(dx * dx + dy * dy);
                
                // Ø®Ø· Ø¹Ù…ÙˆØ¯ÙŠ
                let perpX1 = centerX - dy / 2;
                let perpY1 = centerY + dx / 2;
                let perpX2 = centerX + dy / 2;
                let perpY2 = centerY - dx / 2;
                
                shape.addLineTerm(perpX1, perpY1, perpX2, perpY2);
                
                console.log(`      âœ“ ØªØ¹Ø§Ù…Ø¯ Ø§Ù„Ø£Ø¶Ø¯Ø§Ø¯: Ø£Ø¶ÙŠÙ Ø®Ø· Ø¹Ù…ÙˆØ¯ÙŠ (Ù‚ÙˆØ©: ${strength})`);
            }
        }
    }
    
    function applyFilamentTheory(shape: GeneralShapeEquation, decision: object): void {
        /**
         * ØªØ·Ø¨ÙŠÙ‚ Ù†Ø¸Ø±ÙŠØ© Ø§Ù„ÙØªØ§Ø¦Ù„
         * Apply Filament Theory
         */
        let count = this.brain.expert.filamentCount;
        
        // ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„ØªÙ‚Ù„ÙŠØ¯ÙŠØŒ Ù†Ø·Ø¨Ù‚ Ø§Ù„ÙØªØ§Ø¦Ù„ ÙƒÙ…ÙˆØ¬Ø§Øª ØµØºÙŠØ±Ø©
        if (count > 0) {
            // Ø¥Ø¶Ø§ÙØ© Ù…ÙˆØ¬Ø© ØµØºÙŠØ±Ø© ÙƒÙØªÙŠÙ„
            shape.addSineWaveTerm(10, 0.5, 0);
            
            console.log(`      âœ“ Ù†Ø¸Ø±ÙŠØ© Ø§Ù„ÙØªØ§Ø¦Ù„: Ø£Ø¶ÙŠÙØª ${count} ÙØªØ§Ø¦Ù„`);
        }
    }
    
    // â•â•â• Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø© â•â•â•
    
    function createShapeFromDecision(decision: object, task: object): GeneralShapeEquation {
        /**
         * Ø¥Ù†Ø´Ø§Ø¡ Ø´ÙƒÙ„ Ù…Ù† Ù‚Ø±Ø§Ø± Ø§Ù„Ø®Ø¨ÙŠØ±
         * Create shape from expert decision
         */
        let shapeName = task.shapeName || "Ø´ÙƒÙ„ Ø¬Ø¯ÙŠØ¯";
        let shapeType = task.shapeType || ShapeType.COMPOSITE;
        
        let shape = new GeneralShapeEquation(shapeName, shapeType);
        
        // Ø¥Ø¶Ø§ÙØ© Ø­Ø¯ÙˆØ¯ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù‚Ø±Ø§Ø±
        if (decision.approach == "simple") {
            // Ø´ÙƒÙ„ Ø¨Ø³ÙŠØ·
            shape.addCircleTerm(400, 300, 100);
        } else if (decision.approach == "complex") {
            // Ø´ÙƒÙ„ Ù…Ø¹Ù‚Ø¯
            shape.addCircleTerm(400, 300, 100);
            shape.addLineTerm(300, 300, 500, 300);
            shape.addSineWaveTerm(50, 1, 0);
        } else {
            // Ø§ÙØªØ±Ø§Ø¶ÙŠ
            shape.addLineTerm(100, 100, 700, 500);
        }
        
        // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø£Ù†Ù…Ø§Ø·
        if (task.style) {
            shape.setStrokeColor(
                task.style.r || 0,
                task.style.g || 0,
                task.style.b || 0,
                task.style.a || 1
            );
            shape.setLineWidth(task.style.lineWidth || 2);
        }
        
        return shape;
    }
    
    function createShapeFromExploration(discovery: object, constraints: object): GeneralShapeEquation {
        /**
         * Ø¥Ù†Ø´Ø§Ø¡ Ø´ÙƒÙ„ Ù…Ù† Ø§ÙƒØªØ´Ø§Ù Ø§Ù„Ù…Ø³ØªÙƒØ´Ù
         * Create shape from explorer discovery
         */
        let shapeName = `Ø§ÙƒØªØ´Ø§Ù_${this.drawingHistory.length + 1}`;
        let shape = new GeneralShapeEquation(shapeName, ShapeType.COMPOSITE);
        
        // Ø¥Ù†Ø´Ø§Ø¡ Ø´ÙƒÙ„ Ø¹Ø´ÙˆØ§Ø¦ÙŠ Ù…Ø¨ØªÙƒØ±
        let centerX = 400;
        let centerY = 300;
        let radius = 50 + Math.random() * 100;
        
        // Ø¯Ø§Ø¦Ø±Ø© Ù…Ø±ÙƒØ²ÙŠØ©
        shape.addCircleTerm(centerX, centerY, radius);
        
        // Ø®Ø·ÙˆØ· Ø´Ø¹Ø§Ø¹ÙŠØ©
        let rays = 5 + Math.floor(Math.random() * 5);
        for (let i = 0; i < rays; i++) {
            let angle = (i * 2 * Math.PI) / rays;
            let x = centerX + radius * Math.cos(angle);
            let y = centerY + radius * Math.sin(angle);
            let x2 = centerX + (radius + 50) * Math.cos(angle);
            let y2 = centerY + (radius + 50) * Math.sin(angle);
            
            shape.addLineTerm(x, y, x2, y2);
        }
        
        // Ø£Ù„ÙˆØ§Ù† Ø¹Ø´ÙˆØ§Ø¦ÙŠØ©
        shape.setStrokeColor(
            Math.floor(Math.random() * 255),
            Math.floor(Math.random() * 255),
            Math.floor(Math.random() * 255),
            1
        );
        
        return shape;
    }
    
    function clear(): void {
        /**
         * Ù…Ø³Ø­ Ø§Ù„Ù„ÙˆØ­Ø©
         * Clear canvas
         */
        this.drawingEngine.clear();
        this.currentShape = null;
    }
    
    function getStatistics(): object {
        /**
         * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù†Ø¸Ø§Ù…
         * Get system statistics
         */
        return {
            totalShapes: this.drawingHistory.length,
            expertLevel: this.brain.expert.expertiseLevel,
            explorerStrategy: this.brain.explorer.strategy,
            zeroDualityFactor: this.brain.expert.zeroDualityFactor,
            perpendicularStrength: this.brain.expert.perpendicularStrength,
            filamentCount: this.brain.expert.filamentCount
        };
    }
}

export { ExpertGuidedDrawingSystem };

