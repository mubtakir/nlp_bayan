/**
 * Ø£Ù…Ø«Ù„Ø© Ø§Ù„Ø§Ø³ØªÙ†Ø¨Ø§Ø· - Inference Examples
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * Ø§Ù„ÙˆØµÙ: Ø£Ù…Ø«Ù„Ø© Ø¹Ù…Ù„ÙŠØ© Ù„Ø§Ø³ØªÙ†Ø¨Ø§Ø· Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø§Ù„Ø´ÙƒÙ„ Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
 * Ø§Ù„Ù‡Ø¯Ù: ØªÙˆØ¶ÙŠØ­ Ù‚Ø¯Ø±Ø§Øª Ù…Ø­Ø±Ùƒ Ø§Ù„Ø§Ø³ØªÙ†Ø¨Ø§Ø·
 * Ø§Ù„Ù…Ù†Ù‡Ø¬ÙŠØ©: Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø©
 * 
 * Ø§Ù„Ù…Ø·ÙˆØ±: Ø¨ØµÙŠØ±Ø© AI
 * Ø§Ù„ØªØ§Ø±ÙŠØ®: 2025-10-26
 */

import { SigmoidInferenceEngine } from "./sigmoid-inference-engine.bn";
import { ExpertGuidedInferenceCoordinator } from "./expert-guided-inference.bn";

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ù…Ø«Ø§Ù„ 1: Ø§Ø³ØªÙ†Ø¨Ø§Ø· Ø¯Ø§Ù„Ø© Ø§Ù„Ø®Ø·ÙˆØ©
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function example1_StepFunction(): void {
    console.log("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    console.log("Ù…Ø«Ø§Ù„ 1: Ø§Ø³ØªÙ†Ø¨Ø§Ø· Ø¯Ø§Ù„Ø© Ø§Ù„Ø®Ø·ÙˆØ©");
    console.log("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    
    // ØªÙˆÙ„ÙŠØ¯ Ø¨ÙŠØ§Ù†Ø§Øª Ø¯Ø§Ù„Ø© Ø§Ù„Ø®Ø·ÙˆØ©
    let xData: number[] = [];
    let yData: number[] = [];
    
    for (let i = 0; i < 100; i++) {
        let x = (i - 50) / 10;
        let y = x < 0 ? 0 : 1;
        xData.push(x);
        yData.push(y);
    }
    
    // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø­Ø±Ùƒ Ø§Ù„Ø§Ø³ØªÙ†Ø¨Ø§Ø·
    let engine = new SigmoidInferenceEngine("step_engine");
    
    // Ø§Ù„Ø§Ø³ØªÙ†Ø¨Ø§Ø·
    let result = engine.inferFromPoints(xData, yData);
    
    // Ø¹Ø±Ø¶ Ø§Ù„Ù†ØªØ§Ø¦Ø¬
    console.log(`âœ… Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„Ù…Ø³ØªÙ†Ø¨Ø·Ø©: ${result.equation.equationId}`);
    console.log(`   Ø§Ù„Ø«Ù‚Ø©: ${result.confidence.toFixed(3)}`);
    console.log(`   Ø¹Ø¯Ø¯ Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø³ÙŠØºÙ…ÙˆÙŠØ¯: ${result.equation.sigmoidTerms.length}`);
    console.log(`   RÂ²: ${result.qualityMetrics.rSquared.toFixed(3)}`);
    console.log(`   Ø§Ù„ØªÙØ³ÙŠØ±: ${result.reasoning}`);
    console.log("");
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ù…Ø«Ø§Ù„ 2: Ø§Ø³ØªÙ†Ø¨Ø§Ø· Ù…ÙˆØ¬Ø©
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function example2_WaveFunction(): void {
    console.log("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    console.log("Ù…Ø«Ø§Ù„ 2: Ø§Ø³ØªÙ†Ø¨Ø§Ø· Ù…ÙˆØ¬Ø©");
    console.log("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    
    // ØªÙˆÙ„ÙŠØ¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù…ÙˆØ¬Ø©
    let xData: number[] = [];
    let yData: number[] = [];
    
    for (let i = 0; i < 100; i++) {
        let x = i / 10;
        let y = Math.sin(x);
        xData.push(x);
        yData.push(y);
    }
    
    let engine = new SigmoidInferenceEngine("wave_engine");
    let result = engine.inferFromPoints(xData, yData);
    
    console.log(`âœ… Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„Ù…Ø³ØªÙ†Ø¨Ø·Ø©: ${result.equation.equationId}`);
    console.log(`   Ø§Ù„Ø«Ù‚Ø©: ${result.confidence.toFixed(3)}`);
    console.log(`   Ø¹Ø¯Ø¯ Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø³ÙŠØºÙ…ÙˆÙŠØ¯: ${result.equation.sigmoidTerms.length}`);
    console.log(`   RÂ²: ${result.qualityMetrics.rSquared.toFixed(3)}`);
    console.log(`   Ø§Ù„Ø¯ÙˆØ±ÙŠØ©: ${result.features.periodicity.toFixed(3)}`);
    console.log(`   Ø§Ù„ØªÙØ³ÙŠØ±: ${result.reasoning}`);
    console.log("");
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ù…Ø«Ø§Ù„ 3: Ø§Ø³ØªÙ†Ø¨Ø§Ø· Ø´ÙƒÙ„ Ù…Ø¹Ù‚Ø¯
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function example3_ComplexShape(): void {
    console.log("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    console.log("Ù…Ø«Ø§Ù„ 3: Ø§Ø³ØªÙ†Ø¨Ø§Ø· Ø´ÙƒÙ„ Ù…Ø¹Ù‚Ø¯");
    console.log("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    
    // ØªÙˆÙ„ÙŠØ¯ Ø¨ÙŠØ§Ù†Ø§Øª Ø´ÙƒÙ„ Ù…Ø¹Ù‚Ø¯ (Ù…Ø²ÙŠØ¬ Ù…Ù† Ø³ÙŠØºÙ…ÙˆÙŠØ¯)
    let xData: number[] = [];
    let yData: number[] = [];
    
    for (let i = 0; i < 100; i++) {
        let x = (i - 50) / 10;
        let y = 1 / (1 + Math.exp(-2 * x)) + 0.5 / (1 + Math.exp(-5 * (x - 2)));
        xData.push(x);
        yData.push(y);
    }
    
    let engine = new SigmoidInferenceEngine("complex_engine");
    let result = engine.inferFromPoints(xData, yData);
    
    console.log(`âœ… Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„Ù…Ø³ØªÙ†Ø¨Ø·Ø©: ${result.equation.equationId}`);
    console.log(`   Ø§Ù„Ø«Ù‚Ø©: ${result.confidence.toFixed(3)}`);
    console.log(`   Ø¹Ø¯Ø¯ Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø³ÙŠØºÙ…ÙˆÙŠØ¯: ${result.equation.sigmoidTerms.length}`);
    console.log(`   RÂ²: ${result.qualityMetrics.rSquared.toFixed(3)}`);
    console.log(`   Ø§Ù„ØªØ¹Ù‚ÙŠØ¯: ${result.features.complexity.toFixed(3)}`);
    console.log(`   Ø§Ù„ØªÙØ³ÙŠØ±: ${result.reasoning}`);
    console.log("");
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ù…Ø«Ø§Ù„ 4: Ø§Ø³ØªÙ†Ø¨Ø§Ø· Ù…Ù† Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø´ÙˆØ´Ø©
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function example4_NoisyData(): void {
    console.log("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    console.log("Ù…Ø«Ø§Ù„ 4: Ø§Ø³ØªÙ†Ø¨Ø§Ø· Ù…Ù† Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø´ÙˆØ´Ø©");
    console.log("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    
    // ØªÙˆÙ„ÙŠØ¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¹ Ø¶ÙˆØ¶Ø§Ø¡
    let xData: number[] = [];
    let yData: number[] = [];
    
    for (let i = 0; i < 100; i++) {
        let x = (i - 50) / 10;
        let y = 1 / (1 + Math.exp(-x)) + (Math.random() - 0.5) * 0.1;
        xData.push(x);
        yData.push(y);
    }
    
    let engine = new SigmoidInferenceEngine("noisy_engine");
    let result = engine.inferFromPoints(xData, yData);
    
    console.log(`âœ… Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„Ù…Ø³ØªÙ†Ø¨Ø·Ø©: ${result.equation.equationId}`);
    console.log(`   Ø§Ù„Ø«Ù‚Ø©: ${result.confidence.toFixed(3)}`);
    console.log(`   Ø¹Ø¯Ø¯ Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø³ÙŠØºÙ…ÙˆÙŠØ¯: ${result.equation.sigmoidTerms.length}`);
    console.log(`   RÂ²: ${result.qualityMetrics.rSquared.toFixed(3)}`);
    console.log(`   Ø§Ù„Ø®Ø·Ø£ Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ: ${result.qualityMetrics.residualError.toFixed(3)}`);
    console.log(`   Ø§Ù„ØªÙØ³ÙŠØ±: ${result.reasoning}`);
    console.log("");
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ù…Ø«Ø§Ù„ 5: Ø§Ø³ØªÙ†Ø¨Ø§Ø· Ø¯Ø§Ø¦Ø±Ø© Ø¨Ø§Ø±Ø§Ù…ØªØ±ÙŠØ©
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function example5_ParametricCircle(): void {
    console.log("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    console.log("Ù…Ø«Ø§Ù„ 5: Ø§Ø³ØªÙ†Ø¨Ø§Ø· Ø¯Ø§Ø¦Ø±Ø© Ø¨Ø§Ø±Ø§Ù…ØªØ±ÙŠØ©");
    console.log("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    
    // ØªÙˆÙ„ÙŠØ¯ Ø¨ÙŠØ§Ù†Ø§Øª Ø¯Ø§Ø¦Ø±Ø©
    let xData: number[] = [];
    let yData: number[] = [];
    
    for (let i = 0; i < 100; i++) {
        let t = (i / 100) * 2 * Math.PI;
        let x = Math.cos(t);
        let y = Math.sin(t);
        xData.push(x);
        yData.push(y);
    }
    
    let engine = new SigmoidInferenceEngine("circle_engine");
    let result = engine.inferFromPoints(xData, yData);
    
    console.log(`âœ… Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„Ù…Ø³ØªÙ†Ø¨Ø·Ø©: ${result.equation.equationId}`);
    console.log(`   Ø§Ù„Ø«Ù‚Ø©: ${result.confidence.toFixed(3)}`);
    console.log(`   Ø¹Ø¯Ø¯ Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø³ÙŠØºÙ…ÙˆÙŠØ¯: ${result.equation.sigmoidTerms.length}`);
    console.log(`   RÂ²: ${result.qualityMetrics.rSquared.toFixed(3)}`);
    console.log(`   Ù…ØºÙ„Ù‚: ${result.features.isClosed}`);
    console.log(`   Ø§Ù„ØªÙ…Ø§Ø«Ù„: ${result.features.symmetry.toFixed(3)}`);
    console.log(`   Ø§Ù„ØªÙØ³ÙŠØ±: ${result.reasoning}`);
    console.log("");
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ù…Ø«Ø§Ù„ 6: Ø§Ø³ØªÙ†Ø¨Ø§Ø· Ù…ÙˆØ¬Ù‡ Ø¨Ø§Ù„Ø®Ø¨ÙŠØ±
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function example6_ExpertGuided(): void {
    console.log("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    console.log("Ù…Ø«Ø§Ù„ 6: Ø§Ø³ØªÙ†Ø¨Ø§Ø· Ù…ÙˆØ¬Ù‡ Ø¨Ø§Ù„Ø®Ø¨ÙŠØ±");
    console.log("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    
    // ØªÙˆÙ„ÙŠØ¯ Ø¨ÙŠØ§Ù†Ø§Øª
    let xData: number[] = [];
    let yData: number[] = [];
    
    for (let i = 0; i < 100; i++) {
        let x = (i - 50) / 10;
        let y = 1 / (1 + Math.exp(-x));
        xData.push(x);
        yData.push(y);
    }
    
    // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ù†Ø³Ù‚ Ø§Ù„Ù…ÙˆØ¬Ù‡ Ø¨Ø§Ù„Ø®Ø¨ÙŠØ±
    let coordinator = new ExpertGuidedInferenceCoordinator("expert_coord");
    
    // Ø§Ù„Ø§Ø³ØªÙ†Ø¨Ø§Ø· Ø§Ù„Ù…ÙˆØ¬Ù‡
    let decision = coordinator.coordinateInference(xData, yData);
    
    console.log(`âœ… Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„Ù…Ø³ØªÙ†Ø¨Ø·Ø©: ${decision.primaryResult.equation.equationId}`);
    console.log(`   Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ©: ${decision.strategyUsed}`);
    console.log(`   Ø«Ù‚Ø© Ø§Ù„Ø®Ø¨ÙŠØ±: ${decision.expertConfidence.toFixed(3)}`);
    console.log(`   Ø«Ù‚Ø© Ø§Ù„Ù…Ø³ØªÙƒØ´Ù: ${decision.explorerConfidence.toFixed(3)}`);
    console.log(`   Ø§Ù„Ø«Ù‚Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©: ${decision.finalConfidence.toFixed(3)}`);
    console.log(`   Ø§Ù„ØªÙØ³ÙŠØ±: ${decision.reasoning}`);
    console.log("");
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ù…Ø«Ø§Ù„ 7: Ù…Ù‚Ø§Ø±Ù†Ø© Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function example7_CompareStrategies(): void {
    console.log("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    console.log("Ù…Ø«Ø§Ù„ 7: Ù…Ù‚Ø§Ø±Ù†Ø© Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª");
    console.log("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    
    // ØªÙˆÙ„ÙŠØ¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù…ØªÙ†ÙˆØ¹Ø©
    let datasets = [
        { name: "Ø®Ø·ÙˆØ©", generator: (x: number) => x < 0 ? 0 : 1 },
        { name: "Ù…ÙˆØ¬Ø©", generator: (x: number) => Math.sin(x) },
        { name: "Ù…Ø¹Ù‚Ø¯", generator: (x: number) => 1 / (1 + Math.exp(-2 * x)) + 0.5 / (1 + Math.exp(-5 * (x - 2))) }
    ];
    
    let coordinator = new ExpertGuidedInferenceCoordinator("compare_coord");
    
    for (let d = 0; d < datasets.length; d++) {
        let dataset = datasets[d];
        let xData: number[] = [];
        let yData: number[] = [];
        
        for (let i = 0; i < 100; i++) {
            let x = (i - 50) / 10;
            let y = dataset.generator(x);
            xData.push(x);
            yData.push(y);
        }
        
        let decision = coordinator.coordinateInference(xData, yData);
        
        console.log(`ğŸ“Š ${dataset.name}:`);
        console.log(`   Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ©: ${decision.strategyUsed}`);
        console.log(`   Ø§Ù„Ø«Ù‚Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©: ${decision.finalConfidence.toFixed(3)}`);
    }
    
    // Ø¹Ø±Ø¶ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
    let metrics = coordinator.getMetrics();
    console.log("");
    console.log("ğŸ“ˆ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø£Ø¯Ø§Ø¡:");
    console.log(`   Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø§Ø³ØªÙ†Ø¨Ø§Ø·Ø§Øª: ${metrics.totalInferences}`);
    console.log(`   Ù‚Ø±Ø§Ø±Ø§Øª ÙŠÙ‚ÙˆØ¯Ù‡Ø§ Ø§Ù„Ø®Ø¨ÙŠØ±: ${metrics.expertLedDecisions}`);
    console.log(`   Ù‚Ø±Ø§Ø±Ø§Øª ÙŠÙ‚ÙˆØ¯Ù‡Ø§ Ø§Ù„Ù…Ø³ØªÙƒØ´Ù: ${metrics.explorerLedDecisions}`);
    console.log(`   Ù‚Ø±Ø§Ø±Ø§Øª Ù…ØªÙˆØ§Ø²Ù†Ø©: ${metrics.balancedDecisions}`);
    console.log(`   Ù…ØªÙˆØ³Ø· Ø§Ù„Ø«Ù‚Ø©: ${metrics.avgConfidence.toFixed(3)}`);
    console.log(`   Ù…Ø¹Ø¯Ù„ Ø§Ù„Ù†Ø¬Ø§Ø­: ${(metrics.successRate * 100).toFixed(1)}%`);
    console.log("");
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ØªØ´ØºÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ù…Ø«Ù„Ø©
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function runAllExamples(): void {
    console.log("\n");
    console.log("ğŸ¨ Ø¨Ø¯Ø¡ ØªØ´ØºÙŠÙ„ Ø£Ù…Ø«Ù„Ø© Ø§Ù„Ø§Ø³ØªÙ†Ø¨Ø§Ø·");
    console.log("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    example1_StepFunction();
    example2_WaveFunction();
    example3_ComplexShape();
    example4_NoisyData();
    example5_ParametricCircle();
    example6_ExpertGuided();
    example7_CompareStrategies();
    
    console.log("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    console.log("âœ… Ø§ÙƒØªÙ…Ù„Øª Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ù…Ø«Ù„Ø© Ø¨Ù†Ø¬Ø§Ø­!");
    console.log("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ØªØµØ¯ÙŠØ±
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export {
    example1_StepFunction,
    example2_WaveFunction,
    example3_ComplexShape,
    example4_NoisyData,
    example5_ParametricCircle,
    example6_ExpertGuided,
    example7_CompareStrategies,
    runAllExamples
};

