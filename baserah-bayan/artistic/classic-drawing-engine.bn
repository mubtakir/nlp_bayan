/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * Ù…Ø­Ø±Ùƒ Ø§Ù„Ø±Ø³Ù… Ø§Ù„ØªÙ‚Ù„ÙŠØ¯ÙŠ - Classic Drawing Engine
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * ÙŠÙ‚ÙˆÙ… Ø¨Ù‚Ø±Ø§Ø¡Ø© Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ø¹Ø§Ù… ÙˆØªØ­ÙˆÙŠÙ„Ù‡Ø§ Ø¥Ù„Ù‰ ØµÙˆØ±Ø©
 * Reads General Shape Equation and converts it to image
 * 
 * Ø§Ù„Ù…ÙÙ‡ÙˆÙ…:
 * - ÙŠÙ‚Ø±Ø£ Ø§Ù„Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© ÙˆØ§Ø­Ø¯Ø§Ù‹ ØªÙ„Ùˆ Ø§Ù„Ø¢Ø®Ø±
 * - ÙŠØ±Ø³Ù… ÙƒÙ„ Ø­Ø¯ Ø­Ø³Ø¨ Ù†ÙˆØ¹Ù‡
 * - ÙŠØ·Ø¨Ù‚ Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠØ© (Ù„ÙˆÙ†ØŒ Ø³Ù…ÙƒØŒ ØªØ¹Ø¨Ø¦Ø©)
 * - Ù†Ø¸Ø§Ù… ØªØªØ§Ø¨Ø¹ÙŠ: Ø­Ø¯ Ø¨Ø¹Ø¯ Ø­Ø¯
 * 
 * Ø§Ù„ÙˆØ¸Ø§Ø¦Ù:
 * - Ø±Ø³Ù… Ø§Ù„Ø£Ø´ÙƒØ§Ù„ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
 * - ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø£Ù†Ù…Ø§Ø·
 * - Ø§Ù„ØªØµØ¯ÙŠØ± Ø¥Ù„Ù‰ Canvas/SVG
 * - Ø§Ù„ØªØ­Ø±ÙŠÙƒ (Ù‚Ø±ÙŠØ¨Ø§Ù‹)
 * 
 * @author Baserah AI System
 * @version 1.0.0
 * @date 2025-10-26
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

import { 
    GeneralShapeEquation, 
    ShapeType, 
    FillType, 
    LineStyle,
    Color,
    StyleProperties,
    MathematicalTerm
} from "./general-shape-equation.bn";

class Point2D {
    x: number;
    y: number;
    
    constructor(x: number = 0, y: number = 0) {
        this.x = x;
        this.y = y;
    }
}

class CanvasContext {
    canvasId: string;
    width: number;
    height: number;
    context: any;  // Ø³ÙŠÙƒÙˆÙ† CanvasRenderingContext2D ÙÙŠ Ø§Ù„Ù…ØªØµÙØ­
    
    constructor(canvasId: string, width: number = 800, height: number = 600) {
        this.canvasId = canvasId;
        this.width = width;
        this.height = height;
        this.context = null;
    }
    
    function initialize(): boolean {
        /**
         * ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø³ÙŠØ§Ù‚
         * Initialize context
         */
        try {
            if (typeof document !== 'undefined') {
                let canvas = document.getElementById(this.canvasId);
                if (canvas) {
                    this.context = canvas.getContext('2d');
                    canvas.width = this.width;
                    canvas.height = this.height;
                    return true;
                }
            }
            return false;
        } catch (e) {
            console.log(`âŒ Ø®Ø·Ø£ ÙÙŠ ØªÙ‡ÙŠØ¦Ø© Canvas: ${e}`);
            return false;
        }
    }
    
    function clear(): void {
        /**
         * Ù…Ø³Ø­ Ø§Ù„Ù„ÙˆØ­Ø©
         * Clear canvas
         */
        if (this.context) {
            this.context.clearRect(0, 0, this.width, this.height);
        }
    }
}

class ClassicDrawingEngine {
    canvasContext: CanvasContext;
    currentEquation: GeneralShapeEquation;
    resolution: number;  // Ø¯Ù‚Ø© Ø§Ù„Ø±Ø³Ù… (Ø¹Ø¯Ø¯ Ø§Ù„Ù†Ù‚Ø§Ø·)
    
    constructor(canvasId: string, width: number = 800, height: number = 600) {
        this.canvasContext = new CanvasContext(canvasId, width, height);
        this.currentEquation = null;
        this.resolution = 100;
        
        console.log(`ğŸ¨ ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø­Ø±Ùƒ Ø§Ù„Ø±Ø³Ù… Ø§Ù„ØªÙ‚Ù„ÙŠØ¯ÙŠ`);
    }
    
    function initialize(): boolean {
        /**
         * ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ø­Ø±Ùƒ
         * Initialize engine
         */
        return this.canvasContext.initialize();
    }
    
    // â•â•â• Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ â•â•â•
    
    function drawEquation(equation: GeneralShapeEquation): boolean {
        /**
         * Ø±Ø³Ù… Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ø¹Ø§Ù…
         * Draw general shape equation
         */
        try {
            this.currentEquation = equation;
            this.canvasContext.clear();
            
            console.log(`ğŸ¨ Ø¨Ø¯Ø¡ Ø±Ø³Ù…: ${equation.shapeName}`);
            console.log(`   Ø¹Ø¯Ø¯ Ø§Ù„Ø­Ø¯ÙˆØ¯: ${equation.mathematicalTerms.length}`);
            
            // Ø±Ø³Ù… ÙƒÙ„ Ø­Ø¯ Ø¨Ø§Ù„ØªØªØ§Ø¨Ø¹
            for (let i = 0; i < equation.mathematicalTerms.length; i++) {
                let term = equation.mathematicalTerms[i];
                console.log(`   Ø±Ø³Ù… Ø§Ù„Ø­Ø¯ ${i + 1}: ${term.termType}`);
                this.drawTerm(term, equation.globalStyle);
            }
            
            console.log(`âœ… ØªÙ… Ø±Ø³Ù… ${equation.shapeName} Ø¨Ù†Ø¬Ø§Ø­`);
            return true;
            
        } catch (e) {
            console.log(`âŒ Ø®Ø·Ø£ ÙÙŠ Ø±Ø³Ù… Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø©: ${e}`);
            return false;
        }
    }
    
    function drawTerm(term: MathematicalTerm, globalStyle: StyleProperties): void {
        /**
         * Ø±Ø³Ù… Ø­Ø¯ ÙˆØ§Ø­Ø¯
         * Draw single term
         */
        let ctx = this.canvasContext.context;
        if (!ctx) {
            return;
        }
        
        // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø£Ù†Ù…Ø§Ø·
        this.applyStyle(term.style, globalStyle);
        
        // Ø±Ø³Ù… Ø­Ø³Ø¨ Ø§Ù„Ù†ÙˆØ¹
        if (term.termType == "line") {
            this.drawLine(term.parameters);
        } else if (term.termType == "circle") {
            this.drawCircle(term.parameters);
        } else if (term.termType == "bezier") {
            this.drawBezier(term.parameters);
        } else if (term.termType == "sine") {
            this.drawSineWave(term.parameters, term.range);
        } else if (term.termType == "parametric") {
            this.drawParametric(term.parameters, term.range);
        } else {
            console.log(`âš ï¸ Ù†ÙˆØ¹ Ø­Ø¯ ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ…: ${term.termType}`);
        }
    }
    
    // â•â•â• Ø±Ø³Ù… Ø§Ù„Ø£Ø´ÙƒØ§Ù„ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© â•â•â•
    
    function drawLine(params: object): void {
        /**
         * Ø±Ø³Ù… Ø®Ø· Ù…Ø³ØªÙ‚ÙŠÙ…
         * Draw line
         */
        let ctx = this.canvasContext.context;
        ctx.beginPath();
        ctx.moveTo(params.x1, params.y1);
        ctx.lineTo(params.x2, params.y2);
        ctx.stroke();
    }
    
    function drawCircle(params: object): void {
        /**
         * Ø±Ø³Ù… Ø¯Ø§Ø¦Ø±Ø©
         * Draw circle
         */
        let ctx = this.canvasContext.context;
        ctx.beginPath();
        ctx.arc(params.centerX, params.centerY, params.radius, 0, 2 * Math.PI);
        ctx.stroke();
        
        // Ø§Ù„ØªØ¹Ø¨Ø¦Ø© Ø¥Ù† ÙˆØ¬Ø¯Øª
        if (ctx.fillStyle && ctx.fillStyle != 'rgba(0,0,0,0)') {
            ctx.fill();
        }
    }
    
    function drawBezier(params: object): void {
        /**
         * Ø±Ø³Ù… Ù…Ù†Ø­Ù†Ù‰ Ø¨ÙŠØ²ÙŠÙ‡
         * Draw Bezier curve
         */
        let ctx = this.canvasContext.context;
        let points = params.controlPoints;
        
        if (points.length < 2) {
            return;
        }
        
        ctx.beginPath();
        ctx.moveTo(points[0][0], points[0][1]);
        
        if (points.length == 3) {
            // Ù…Ù†Ø­Ù†Ù‰ ØªØ±Ø¨ÙŠØ¹ÙŠ
            ctx.quadraticCurveTo(
                points[1][0], points[1][1],
                points[2][0], points[2][1]
            );
        } else if (points.length == 4) {
            // Ù…Ù†Ø­Ù†Ù‰ ØªÙƒØ¹ÙŠØ¨ÙŠ
            ctx.bezierCurveTo(
                points[1][0], points[1][1],
                points[2][0], points[2][1],
                points[3][0], points[3][1]
            );
        } else {
            // Ø±Ø³Ù… Ø®Ø·ÙˆØ· Ù…ØªØµÙ„Ø©
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i][0], points[i][1]);
            }
        }
        
        ctx.stroke();
    }
    
    function drawSineWave(params: object, range: number[]): void {
        /**
         * Ø±Ø³Ù… Ù…ÙˆØ¬Ø© Ø¬ÙŠØ¨ÙŠØ©
         * Draw sine wave
         */
        let ctx = this.canvasContext.context;
        let amplitude = params.amplitude;
        let frequency = params.frequency;
        let phase = params.phase || 0;
        
        let start = range[0];
        let end = range[1];
        let step = (end - start) / this.resolution;
        
        ctx.beginPath();
        
        for (let i = 0; i <= this.resolution; i++) {
            let t = start + i * step;
            let x = t * 50 + 100;  // ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø§Ù„Ø´Ø§Ø´Ø©
            let y = 300 + amplitude * Math.sin(frequency * t + phase);
            
            if (i == 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        }
        
        ctx.stroke();
    }
    
    function drawParametric(params: object, range: number[]): void {
        /**
         * Ø±Ø³Ù… Ù…Ø¹Ø§Ø¯Ù„Ø© Ø¨Ø§Ø±Ø§Ù…ØªØ±ÙŠØ©
         * Draw parametric equation
         */
        let ctx = this.canvasContext.context;
        let xFunc = params.xFunction;
        let yFunc = params.yFunction;
        
        let start = range[0];
        let end = range[1];
        let step = (end - start) / this.resolution;
        
        ctx.beginPath();
        
        for (let i = 0; i <= this.resolution; i++) {
            let t = start + i * step;
            
            // ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø¯ÙˆØ§Ù„ (ØªØ¨Ø³ÙŠØ· - ÙŠØ­ØªØ§Ø¬ parser Ø­Ù‚ÙŠÙ‚ÙŠ)
            let x = this.evaluateFunction(xFunc, t);
            let y = this.evaluateFunction(yFunc, t);
            
            if (i == 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        }
        
        ctx.stroke();
    }
    
    // â•â•â• ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø£Ù†Ù…Ø§Ø· â•â•â•
    
    function applyStyle(termStyle: StyleProperties, globalStyle: StyleProperties): void {
        /**
         * ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø¹Ù„Ù‰ Ø§Ù„Ø³ÙŠØ§Ù‚
         * Apply styles to context
         */
        let ctx = this.canvasContext.context;
        if (!ctx) {
            return;
        }
        
        // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù†Ù…Ø· Ø§Ù„Ø­Ø¯ Ø£Ùˆ Ø§Ù„Ù†Ù…Ø· Ø§Ù„Ø¹Ø§Ù…
        let style = termStyle.lineWidth > 0 ? termStyle : globalStyle;
        
        // Ù„ÙˆÙ† Ø§Ù„Ø®Ø·
        ctx.strokeStyle = style.strokeColor.toRGBA();
        
        // Ù„ÙˆÙ† Ø§Ù„ØªØ¹Ø¨Ø¦Ø©
        ctx.fillStyle = style.fillColor.toRGBA();
        
        // Ø³Ù…Ùƒ Ø§Ù„Ø®Ø·
        ctx.lineWidth = style.lineWidth;
        
        // Ù†Ù…Ø· Ø§Ù„Ø®Ø·
        if (style.lineStyle == LineStyle.DASHED) {
            ctx.setLineDash([10, 5]);
        } else if (style.lineStyle == LineStyle.DOTTED) {
            ctx.setLineDash([2, 3]);
        } else if (style.lineStyle == LineStyle.DASH_DOT) {
            ctx.setLineDash([10, 5, 2, 5]);
        } else {
            ctx.setLineDash([]);
        }
        
        // Ø§Ù„Ø´ÙØ§ÙÙŠØ©
        ctx.globalAlpha = style.opacity;
    }
    
    // â•â•â• Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø© â•â•â•
    
    function evaluateFunction(funcStr: string, t: number): number {
        /**
         * ØªÙ‚ÙŠÙŠÙ… Ø¯Ø§Ù„Ø© Ø±ÙŠØ§Ø¶ÙŠØ© (ØªØ¨Ø³ÙŠØ·)
         * Evaluate mathematical function (simplified)
         */
        try {
            // Ø§Ø³ØªØ¨Ø¯Ø§Ù„ t Ø¨Ø§Ù„Ù‚ÙŠÙ…Ø©
            let expr = funcStr.replace(/t/g, t.toString());
            
            // ØªÙ‚ÙŠÙŠÙ… Ø¨Ø³ÙŠØ· (ÙÙŠ Ø§Ù„ÙˆØ§Ù‚Ø¹ ÙŠØ­ØªØ§Ø¬ parser Ø£ÙØ¶Ù„)
            // Ù‡Ø°Ø§ Ù…Ø«Ø§Ù„ Ø¨Ø³ÙŠØ· ÙÙ‚Ø·
            if (expr.includes('sin')) {
                let match = expr.match(/sin\((.*?)\)/);
                if (match) {
                    let arg = parseFloat(match[1]);
                    return Math.sin(arg);
                }
            } else if (expr.includes('cos')) {
                let match = expr.match(/cos\((.*?)\)/);
                if (match) {
                    let arg = parseFloat(match[1]);
                    return Math.cos(arg);
                }
            }
            
            // Ù…Ø­Ø§ÙˆÙ„Ø© ØªÙ‚ÙŠÙŠÙ… Ù…Ø¨Ø§Ø´Ø±
            return eval(expr);
            
        } catch (e) {
            console.log(`âš ï¸ Ø®Ø·Ø£ ÙÙŠ ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø¯Ø§Ù„Ø©: ${funcStr}`);
            return 0;
        }
    }
    
    function setResolution(resolution: number): void {
        /**
         * ØªØ¹ÙŠÙŠÙ† Ø¯Ù‚Ø© Ø§Ù„Ø±Ø³Ù…
         * Set drawing resolution
         */
        this.resolution = Math.max(10, Math.min(1000, resolution));
    }
    
    function clear(): void {
        /**
         * Ù…Ø³Ø­ Ø§Ù„Ù„ÙˆØ­Ø©
         * Clear canvas
         */
        this.canvasContext.clear();
    }
}

export { ClassicDrawingEngine, Point2D, CanvasContext };

