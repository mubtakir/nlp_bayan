/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ø¹Ø§Ù… - General Shape Equation
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ø¹Ø§Ù… ØªØ±Ø« Ù…Ù† Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„Ø£Ù…
 * General Shape Equation inherits from Mother Equation
 * 
 * Ø§Ù„Ù…ÙÙ‡ÙˆÙ…:
 * - ÙƒÙ„ Ø´ÙƒÙ„ Ù‡Ùˆ Ù…Ø¹Ø§Ø¯Ù„Ø© Ø±ÙŠØ§Ø¶ÙŠØ©
 * - Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø© ØªØ­Ù…Ù„ Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠ + Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠØ©
 * - Ù†Ø¸Ø§Ù… ØªØªØ§Ø¨Ø¹ÙŠ: ÙƒÙ„ Ø­Ø¯ ÙŠÙØ±Ø³Ù… Ø«Ù… Ù†Ù†ØªÙ‚Ù„ Ù„Ù„ØªØ§Ù„ÙŠ
 * 
 * Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª:
 * - Ø­Ø¯ÙˆØ¯ Ø±ÙŠØ§Ø¶ÙŠØ©: Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø§Ù„Ø´ÙƒÙ„ Ù†ÙØ³Ù‡
 * - Ø­Ø¯ÙˆØ¯ Ø¨Ø±Ù…Ø¬ÙŠØ©: Ù„ÙˆÙ†ØŒ Ø³Ù…ÙƒØŒ ØªØ¹Ø¨Ø¦Ø©ØŒ Ø´ÙØ§ÙÙŠØ©
 * - Ø§Ø³Ù… Ø§Ù„Ø´ÙƒÙ„ ÙˆØ®ØµØ§Ø¦ØµÙ‡ ÙˆØ­Ø§Ù„Ø§ØªÙ‡
 * 
 * @author Baserah AI System
 * @version 1.0.0
 * @date 2025-10-26
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

import { MotherEquation, ObjectType, StaticProperties, DynamicProperties } from "../core/mother-equation.bn";

// â•â•â• Ø§Ù„ØªØ¹Ø¯Ø§Ø¯Ø§Øª â•â•â•

enum ShapeType {
    LINE,              // Ø®Ø· Ù…Ø³ØªÙ‚ÙŠÙ…
    CIRCLE,            // Ø¯Ø§Ø¦Ø±Ø©
    ELLIPSE,           // Ù‚Ø·Ø¹ Ù†Ø§Ù‚Øµ
    RECTANGLE,         // Ù…Ø³ØªØ·ÙŠÙ„
    POLYGON,           // Ù…Ø¶Ù„Ø¹
    BEZIER,            // Ù…Ù†Ø­Ù†Ù‰ Ø¨ÙŠØ²ÙŠÙ‡
    SINE_WAVE,         // Ù…ÙˆØ¬Ø© Ø¬ÙŠØ¨ÙŠØ©
    EXPONENTIAL,       // Ø¯Ø§Ù„Ø© Ø£Ø³ÙŠØ©
    PARAMETRIC,        // Ù…Ø¹Ø§Ø¯Ù„Ø© Ø¨Ø§Ø±Ø§Ù…ØªØ±ÙŠØ©
    COMPOSITE          // Ø´ÙƒÙ„ Ù…Ø±ÙƒØ¨
}

enum FillType {
    NONE,              // Ø¨Ø¯ÙˆÙ† ØªØ¹Ø¨Ø¦Ø©
    SOLID,             // ØªØ¹Ø¨Ø¦Ø© ØµÙ„Ø¨Ø©
    GRADIENT_LINEAR,   // ØªØ¯Ø±Ø¬ Ø®Ø·ÙŠ
    GRADIENT_RADIAL,   // ØªØ¯Ø±Ø¬ Ø¯Ø§Ø¦Ø±ÙŠ
    PATTERN            // Ù†Ù…Ø·
}

enum LineStyle {
    SOLID,             // Ø®Ø· Ù…ØªØµÙ„
    DASHED,            // Ø®Ø· Ù…ØªÙ‚Ø·Ø¹
    DOTTED,            // Ø®Ø· Ù…Ù†Ù‚Ø·
    DASH_DOT           // Ø®Ø· Ù…ØªÙ‚Ø·Ø¹ ÙˆÙ…Ù†Ù‚Ø·
}

// â•â•â• Ù‡ÙŠØ§ÙƒÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª â•â•â•

class Color {
    r: number;  // Ø£Ø­Ù…Ø± (0-255)
    g: number;  // Ø£Ø®Ø¶Ø± (0-255)
    b: number;  // Ø£Ø²Ø±Ù‚ (0-255)
    a: number;  // Ø´ÙØ§ÙÙŠØ© (0-1)
    
    constructor(r: number = 0, g: number = 0, b: number = 0, a: number = 1.0) {
        this.r = Math.max(0, Math.min(255, r));
        this.g = Math.max(0, Math.min(255, g));
        this.b = Math.max(0, Math.min(255, b));
        this.a = Math.max(0, Math.min(1, a));
    }
    
    function toHex(): string {
        let rHex = Math.floor(this.r).toString(16).padStart(2, '0');
        let gHex = Math.floor(this.g).toString(16).padStart(2, '0');
        let bHex = Math.floor(this.b).toString(16).padStart(2, '0');
        return `#${rHex}${gHex}${bHex}`;
    }
    
    function toRGBA(): string {
        return `rgba(${Math.floor(this.r)}, ${Math.floor(this.g)}, ${Math.floor(this.b)}, ${this.a})`;
    }
}

class StyleProperties {
    strokeColor: Color;
    fillColor: Color;
    lineWidth: number;
    lineStyle: LineStyle;
    fillType: FillType;
    opacity: number;
    
    constructor() {
        this.strokeColor = new Color(0, 0, 0, 1);
        this.fillColor = new Color(255, 255, 255, 0);
        this.lineWidth = 1.5;
        this.lineStyle = LineStyle.SOLID;
        this.fillType = FillType.NONE;
        this.opacity = 1.0;
    }
}

class MathematicalTerm {
    termId: string;
    termType: string;        // "line", "circle", "bezier", etc.
    parameters: object;      // Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø©
    range: number[];         // Ù†Ø·Ø§Ù‚ Ø§Ù„Ø±Ø³Ù… [start, end]
    style: StyleProperties;  // Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø±Ø³Ù…
    
    constructor(termType: string) {
        this.termId = this.generateId();
        this.termType = termType;
        this.parameters = {};
        this.range = [0, 1];
        this.style = new StyleProperties();
    }
    
    function generateId(): string {
        return `term_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
}

// â•â•â• Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ø¹Ø§Ù… â•â•â•

class GeneralShapeEquation extends MotherEquation {
    shapeType: ShapeType;
    shapeName: string;
    
    // Ø§Ù„Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ©
    mathematicalTerms: MathematicalTerm[];
    
    // Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠØ© Ø§Ù„Ø¹Ø§Ù…Ø©
    globalStyle: StyleProperties;
    
    // Ø§Ù„Ø­Ø§Ù„Ø§Øª
    state: object;
    
    // Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙˆØµÙÙŠØ©
    category: string;
    tags: string[];
    
    constructor(shapeName: string, shapeType: ShapeType = ShapeType.COMPOSITE) {
        super(ObjectType.PHYSICAL, shapeName);
        
        this.shapeType = shapeType;
        this.shapeName = shapeName;
        this.mathematicalTerms = [];
        this.globalStyle = new StyleProperties();
        this.state = {};
        this.category = "general";
        this.tags = [];
        
        console.log(`ğŸ¨ ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¹Ø§Ø¯Ù„Ø© Ø´ÙƒÙ„ Ø¹Ø§Ù…: ${shapeName}`);
    }
    
    // â•â•â• Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø­Ø¯ÙˆØ¯ â•â•â•
    
    function addLineTerm(x1: number, y1: number, x2: number, y2: number): string {
        /**
         * Ø¥Ø¶Ø§ÙØ© Ø­Ø¯ Ø®Ø· Ù…Ø³ØªÙ‚ÙŠÙ…
         * Add line term
         */
        let term = new MathematicalTerm("line");
        term.parameters = {
            x1: x1,
            y1: y1,
            x2: x2,
            y2: y2
        };
        this.mathematicalTerms.push(term);
        return term.termId;
    }
    
    function addCircleTerm(centerX: number, centerY: number, radius: number): string {
        /**
         * Ø¥Ø¶Ø§ÙØ© Ø­Ø¯ Ø¯Ø§Ø¦Ø±Ø©
         * Add circle term
         */
        let term = new MathematicalTerm("circle");
        term.parameters = {
            centerX: centerX,
            centerY: centerY,
            radius: radius
        };
        this.mathematicalTerms.push(term);
        return term.termId;
    }
    
    function addBezierTerm(points: number[][]): string {
        /**
         * Ø¥Ø¶Ø§ÙØ© Ø­Ø¯ Ù…Ù†Ø­Ù†Ù‰ Ø¨ÙŠØ²ÙŠÙ‡
         * Add Bezier curve term
         */
        let term = new MathematicalTerm("bezier");
        term.parameters = {
            controlPoints: points
        };
        this.mathematicalTerms.push(term);
        return term.termId;
    }
    
    function addSineWaveTerm(amplitude: number, frequency: number, phase: number = 0): string {
        /**
         * Ø¥Ø¶Ø§ÙØ© Ø­Ø¯ Ù…ÙˆØ¬Ø© Ø¬ÙŠØ¨ÙŠØ©
         * Add sine wave term
         */
        let term = new MathematicalTerm("sine");
        term.parameters = {
            amplitude: amplitude,
            frequency: frequency,
            phase: phase
        };
        term.range = [0, 2 * Math.PI];
        this.mathematicalTerms.push(term);
        return term.termId;
    }
    
    function addParametricTerm(xFunc: string, yFunc: string, tRange: number[] = [0, 1]): string {
        /**
         * Ø¥Ø¶Ø§ÙØ© Ø­Ø¯ Ù…Ø¹Ø§Ø¯Ù„Ø© Ø¨Ø§Ø±Ø§Ù…ØªØ±ÙŠØ©
         * Add parametric equation term
         */
        let term = new MathematicalTerm("parametric");
        term.parameters = {
            xFunction: xFunc,
            yFunction: yFunc
        };
        term.range = tRange;
        this.mathematicalTerms.push(term);
        return term.termId;
    }
    
    // â•â•â• ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø®ØµØ§Ø¦Øµ â•â•â•
    
    function setTermStyle(termId: string, style: StyleProperties): boolean {
        /**
         * ØªØ¹ÙŠÙŠÙ† Ø®ØµØ§Ø¦Øµ Ø­Ø¯ Ù…Ø¹ÙŠÙ†
         * Set term style
         */
        for (let term of this.mathematicalTerms) {
            if (term.termId == termId) {
                term.style = style;
                return true;
            }
        }
        return false;
    }
    
    function setGlobalStyle(style: StyleProperties): void {
        /**
         * ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø¹Ø§Ù…Ø©
         * Set global style
         */
        this.globalStyle = style;
    }
    
    function setStrokeColor(r: number, g: number, b: number, a: number = 1.0): void {
        /**
         * ØªØ¹ÙŠÙŠÙ† Ù„ÙˆÙ† Ø§Ù„Ø®Ø·
         * Set stroke color
         */
        this.globalStyle.strokeColor = new Color(r, g, b, a);
    }
    
    function setFillColor(r: number, g: number, b: number, a: number = 1.0): void {
        /**
         * ØªØ¹ÙŠÙŠÙ† Ù„ÙˆÙ† Ø§Ù„ØªØ¹Ø¨Ø¦Ø©
         * Set fill color
         */
        this.globalStyle.fillColor = new Color(r, g, b, a);
    }
    
    function setLineWidth(width: number): void {
        /**
         * ØªØ¹ÙŠÙŠÙ† Ø³Ù…Ùƒ Ø§Ù„Ø®Ø·
         * Set line width
         */
        this.globalStyle.lineWidth = Math.max(0.1, width);
    }
    
    // â•â•â• Ø§Ù„Ø­Ø§Ù„Ø§Øª â•â•â•
    
    function setState(key: string, value: any): void {
        /**
         * ØªØ¹ÙŠÙŠÙ† Ø­Ø§Ù„Ø©
         * Set state
         */
        this.state[key] = value;
    }
    
    function getState(key: string): any {
        /**
         * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø­Ø§Ù„Ø©
         * Get state
         */
        return this.state[key];
    }
    
    // â•â•â• Ø§Ù„ØªØµØ¯ÙŠØ± â•â•â•
    
    function toEquationString(): string {
        /**
         * ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ Ù†Øµ Ù…Ø¹Ø§Ø¯Ù„Ø©
         * Convert to equation string
         */
        let equation = `${this.shapeName} = `;
        
        for (let i = 0; i < this.mathematicalTerms.length; i++) {
            let term = this.mathematicalTerms[i];
            if (i > 0) {
                equation += " + ";
            }
            equation += `${term.termType}(${JSON.stringify(term.parameters)})`;
        }
        
        return equation;
    }
    
    function toJSON(): object {
        /**
         * ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ JSON
         * Convert to JSON
         */
        return {
            id: this.id,
            shapeName: this.shapeName,
            shapeType: this.shapeType,
            mathematicalTerms: this.mathematicalTerms.map(term => ({
                termId: term.termId,
                termType: term.termType,
                parameters: term.parameters,
                range: term.range,
                style: {
                    strokeColor: term.style.strokeColor.toRGBA(),
                    fillColor: term.style.fillColor.toRGBA(),
                    lineWidth: term.style.lineWidth,
                    lineStyle: term.style.lineStyle,
                    fillType: term.style.fillType,
                    opacity: term.style.opacity
                }
            })),
            globalStyle: {
                strokeColor: this.globalStyle.strokeColor.toRGBA(),
                fillColor: this.globalStyle.fillColor.toRGBA(),
                lineWidth: this.globalStyle.lineWidth,
                lineStyle: this.globalStyle.lineStyle,
                fillType: this.globalStyle.fillType,
                opacity: this.globalStyle.opacity
            },
            state: this.state,
            category: this.category,
            tags: this.tags,
            creationTime: this.creationTime
        };
    }
}

export { 
    ShapeType,
    FillType,
    LineStyle,
    Color,
    StyleProperties,
    MathematicalTerm,
    GeneralShapeEquation
};

