/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„Ø´ÙƒÙ„ Ø¨Ø§Ù„Ø³ÙŠØºÙ…ÙˆÙŠØ¯ - Sigmoid Shape Equation
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø«ÙˆØ±ÙŠ Ù„Ø±Ø³Ù… Ø§Ù„Ø£Ø´ÙƒØ§Ù„ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¯ÙˆØ§Ù„ Ø³ÙŠØºÙ…ÙˆÙŠØ¯ Ø§Ù„Ù…Ø¹Ù…Ù…Ø©
 * Revolutionary system for drawing shapes using generalized sigmoid functions
 * 
 * Ø§Ù„Ù…ÙÙ‡ÙˆÙ… Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ:
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ÙƒÙ„ Ø´ÙƒÙ„ Ø·Ø¨ÙŠØ¹ÙŠ = Ø®Ø·ÙˆØ· Ù…Ø³ØªÙ‚ÙŠÙ…Ø© + Ø§Ù†Ø­Ù†Ø§Ø¡Ø§Øª
 * Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ø¹Ø§Ù…Ø© (GSE):
 * 
 * fÌ‚(x) = Î£(i=1 to N) Î±áµ¢ Â· Ïƒâ‚™áµ¢(x; káµ¢, xâ‚€áµ¢) + L(x; Î², Î³)
 * 
 * Ø­ÙŠØ«:
 * - Ïƒâ‚™áµ¢: Ø¯Ø§Ù„Ø© Ø³ÙŠØºÙ…ÙˆÙŠØ¯ Ù…Ø¹Ù…Ù…Ø©
 * - L: Ù…ÙƒÙˆÙ† Ø®Ø·ÙŠ (Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø¹Ø§Ù…)
 * - Î±áµ¢: Ù…Ø¹Ø§Ù…Ù„ Ø§Ù„ÙˆØ²Ù†
 * - káµ¢: Ù…Ø¹Ø§Ù…Ù„ Ø§Ù„Ø­Ø¯Ø©
 * - xâ‚€áµ¢: Ù†Ù‚Ø·Ø© Ø§Ù„Ù…Ù†ØªØµÙ
 * - náµ¢: Ù…Ø¹Ø§Ù…Ù„ Ø§Ù„ØªÙ‚Ø·ÙŠØ¹ (1=Ù†Ø§Ø¹Ù…ØŒ 2+=Ø­Ø§Ø¯)
 * 
 * @author Baserah AI System
 * @version 1.0.0
 * @date 2025-10-26
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

import { MotherEquation } from "../core/mother-equation.bn";

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ø§Ù„Ø£Ø³ Ø§Ù„Ù…Ø¹Ù‚Ø¯ - Complex Exponent
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class ComplexExponent {
    real: number;  // Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ (a)
    imag: number;  // Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„ØªØ®ÙŠÙ„ÙŠ (b)
    
    constructor(real: number = 1.0, imag: number = 0.0) {
        this.real = real;
        this.imag = imag;
    }
    
    function magnitude(): number {
        /**
         * Ø­Ø³Ø§Ø¨ Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…Ø·Ù„Ù‚Ø©
         * Calculate magnitude
         */
        return Math.sqrt(this.real * this.real + this.imag * this.imag);
    }
    
    function phase(): number {
        /**
         * Ø­Ø³Ø§Ø¨ Ø§Ù„Ø²Ø§ÙˆÙŠØ© (phase)
         * Calculate phase angle
         */
        return Math.atan2(this.imag, this.real);
    }
    
    function toComplex(): object {
        /**
         * ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ Ø¹Ø¯Ø¯ Ù…Ø¹Ù‚Ø¯
         * Convert to complex number
         */
        return {
            real: this.real,
            imag: this.imag
        };
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ø¯Ø§Ù„Ø© Ø³ÙŠØºÙ…ÙˆÙŠØ¯ Ø§Ù„Ù…Ø¹Ù…Ù…Ø© - Generalized Sigmoid Function
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class GeneralizedSigmoid {
    exponent: ComplexExponent;  // Ø§Ù„Ø£Ø³ Ø§Ù„Ù…Ø¹Ù‚Ø¯
    scale: number;              // Ù…Ø¹Ø§Ù…Ù„ Ø§Ù„ØªØ­Ø¬ÙŠÙ… (Î±)
    sharpness: number;          // Ù…Ø¹Ø§Ù…Ù„ Ø§Ù„Ø­Ø¯Ø© (k)
    center: number;             // Ù†Ù‚Ø·Ø© Ø§Ù„Ù…Ù†ØªØµÙ (xâ‚€)
    cutoff: number;             // Ù…Ø¹Ø§Ù…Ù„ Ø§Ù„ØªÙ‚Ø·ÙŠØ¹ (n)
    shiftY: number;             // Ø¥Ø²Ø§Ø­Ø© Ø¹Ù…ÙˆØ¯ÙŠØ©
    
    constructor(
        exponent: ComplexExponent,
        scale: number = 1.0,
        sharpness: number = 1.0,
        center: number = 0.0,
        cutoff: number = 1,
        shiftY: number = 0.0
    ) {
        this.exponent = exponent;
        this.scale = scale;
        this.sharpness = sharpness;
        this.center = center;
        this.cutoff = cutoff;
        this.shiftY = shiftY;
    }
    
    function evaluate(x: number): number {
        /**
         * Ø­Ø³Ø§Ø¨ Ù‚ÙŠÙ…Ø© Ø¯Ø§Ù„Ø© Ø³ÙŠØºÙ…ÙˆÙŠØ¯ Ø§Ù„Ù…Ø¹Ù…Ù…Ø©
         * Evaluate generalized sigmoid function
         * 
         * Ïƒâ‚™(x; k, xâ‚€) = 1 / (1 + e^(-k(x - xâ‚€)^n))
         */
        try {
            // Ø­Ø³Ø§Ø¨ (x - xâ‚€)
            let xShifted = x - this.center;
            
            // Ø­Ø³Ø§Ø¨ (x - xâ‚€)^n
            let xPowered = Math.pow(xShifted, this.cutoff);
            
            // Ø­Ø³Ø§Ø¨ -k(x - xâ‚€)^n
            let exponentValue = -this.sharpness * xPowered;
            
            // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø£Ø³ Ø§Ù„Ù…Ø¹Ù‚Ø¯
            let complexExp = this.exponent.toComplex();
            
            // Ø­Ø³Ø§Ø¨ e^(-k(x - xâ‚€)^n * (a + bi))
            // Ù†Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ ÙÙ‚Ø· Ù„Ù„Ø¨Ø³Ø§Ø·Ø©
            let expValue = Math.exp(exponentValue * complexExp.real);
            
            // Ø­Ø³Ø§Ø¨ 1 / (1 + e^(...))
            let sigmoidValue = 1.0 / (1.0 + expValue);
            
            // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ØªØ­Ø¬ÙŠÙ… ÙˆØ§Ù„Ø¥Ø²Ø§Ø­Ø©
            return this.scale * sigmoidValue + this.shiftY;
            
        } catch (e) {
            // ÙÙŠ Ø­Ø§Ù„Ø© overflow
            return x > this.center ? this.scale + this.shiftY : this.shiftY;
        }
    }
    
    function derivative(x: number, h: number = 0.00001): number {
        /**
         * Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø´ØªÙ‚Ø© Ø§Ù„Ø¹Ø¯Ø¯ÙŠØ©
         * Calculate numerical derivative
         */
        let fPlus = this.evaluate(x + h);
        let fMinus = this.evaluate(x - h);
        return (fPlus - fMinus) / (2 * h);
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ø§Ù„Ù…ÙƒÙˆÙ† Ø§Ù„Ø®Ø·ÙŠ - Linear Component
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class LinearComponent {
    slope: number;      // Ø§Ù„Ù…ÙŠÙ„ (Î²)
    intercept: number;  // Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ù…Ù‚Ø·ÙˆØ¹ (Î³)
    
    constructor(slope: number = 0.0, intercept: number = 0.0) {
        this.slope = slope;
        this.intercept = intercept;
    }
    
    function evaluate(x: number): number {
        /**
         * Ø­Ø³Ø§Ø¨ Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…ÙƒÙˆÙ† Ø§Ù„Ø®Ø·ÙŠ
         * Evaluate linear component
         * 
         * L(x; Î², Î³) = Î²x + Î³
         */
        return this.slope * x + this.intercept;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ø­Ø¯ Ø³ÙŠØºÙ…ÙˆÙŠØ¯ - Sigmoid Term
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SigmoidTerm {
    termId: string;
    sigmoid: GeneralizedSigmoid;
    weight: number;  // ÙˆØ²Ù† Ø§Ù„Ø­Ø¯ ÙÙŠ Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø©
    range: number[]; // Ù†Ø·Ø§Ù‚ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ [start, end]
    description: string;
    
    constructor(
        sigmoid: GeneralizedSigmoid,
        weight: number = 1.0,
        range: number[] = null,
        description: string = ""
    ) {
        this.termId = this.generateId();
        this.sigmoid = sigmoid;
        this.weight = weight;
        this.range = range || [-Infinity, Infinity];
        this.description = description;
    }
    
    function generateId(): string {
        return `sigmoid_${Date.now()}_${Math.floor(Math.random() * 10000)}`;
    }
    
    function evaluate(x: number): number {
        /**
         * Ø­Ø³Ø§Ø¨ Ù‚ÙŠÙ…Ø© Ø§Ù„Ø­Ø¯
         * Evaluate term value
         */
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù†Ø·Ø§Ù‚
        if (x < this.range[0] || x > this.range[1]) {
            return 0;
        }
        
        return this.weight * this.sigmoid.evaluate(x);
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„Ø´ÙƒÙ„ Ø¨Ø§Ù„Ø³ÙŠØºÙ…ÙˆÙŠØ¯ - Sigmoid Shape Equation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SigmoidShapeEquation extends MotherEquation {
    shapeName: string;
    sigmoidTerms: SigmoidTerm[];
    linearComponent: LinearComponent;
    resolution: number;  // Ø¯Ù‚Ø© Ø§Ù„Ø±Ø³Ù…
    
    constructor(shapeName: string, resolution: number = 100) {
        super();
        this.shapeName = shapeName;
        this.sigmoidTerms = [];
        this.linearComponent = new LinearComponent();
        this.resolution = resolution;
        
        console.log(`ğŸŒŠ ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¹Ø§Ø¯Ù„Ø© Ø´ÙƒÙ„ Ø³ÙŠØºÙ…ÙˆÙŠØ¯: ${shapeName}`);
    }
    
    // â•â•â• Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª â•â•â•
    
    function setLinearComponent(slope: number, intercept: number): void {
        /**
         * ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù…ÙƒÙˆÙ† Ø§Ù„Ø®Ø·ÙŠ
         * Set linear component
         */
        this.linearComponent = new LinearComponent(slope, intercept);
        console.log(`   âœ“ Ù…ÙƒÙˆÙ† Ø®Ø·ÙŠ: y = ${slope}x + ${intercept}`);
    }
    
    function addSigmoidTerm(
        scale: number,
        sharpness: number,
        center: number,
        cutoff: number = 1,
        weight: number = 1.0,
        description: string = ""
    ): string {
        /**
         * Ø¥Ø¶Ø§ÙØ© Ø­Ø¯ Ø³ÙŠØºÙ…ÙˆÙŠØ¯
         * Add sigmoid term
         */
        let exponent = new ComplexExponent(1.0, 0.0);
        let sigmoid = new GeneralizedSigmoid(
            exponent,
            scale,
            sharpness,
            center,
            cutoff,
            0.0
        );
        
        let term = new SigmoidTerm(sigmoid, weight, null, description);
        this.sigmoidTerms.push(term);
        
        console.log(`   âœ“ Ø­Ø¯ Ø³ÙŠØºÙ…ÙˆÙŠØ¯: Î±=${scale}, k=${sharpness}, xâ‚€=${center}, n=${cutoff}`);
        
        return term.termId;
    }
    
    function addGateTerm(
        height: number,
        start: number,
        end: number,
        sharpness: number = 10.0
    ): string {
        /**
         * Ø¥Ø¶Ø§ÙØ© Ø¯Ø§Ù„Ø© Ø¨ÙˆØ§Ø¨Ø© (Ù…Ø³ØªØ·ÙŠÙ„)
         * Add gate function (rectangle)
         * 
         * Ø§Ù„Ø¨ÙˆØ§Ø¨Ø© = Ïƒ(x, start) - Ïƒ(x, end)
         */
        // Ø³ÙŠØºÙ…ÙˆÙŠØ¯ Ø§Ù„Ø¯Ø®ÙˆÙ„ (Ù…Ù† 0 Ø¥Ù„Ù‰ 1)
        let entryId = this.addSigmoidTerm(
            height,
            sharpness,
            start,
            1,
            1.0,
            `Ø¨ÙˆØ§Ø¨Ø© Ø¯Ø®ÙˆÙ„ Ø¹Ù†Ø¯ ${start}`
        );
        
        // Ø³ÙŠØºÙ…ÙˆÙŠØ¯ Ø§Ù„Ø®Ø±ÙˆØ¬ (Ù…Ù† 1 Ø¥Ù„Ù‰ 0)
        let exitId = this.addSigmoidTerm(
            -height,
            sharpness,
            end,
            1,
            1.0,
            `Ø¨ÙˆØ§Ø¨Ø© Ø®Ø±ÙˆØ¬ Ø¹Ù†Ø¯ ${end}`
        );
        
        console.log(`   âœ“ Ø¯Ø§Ù„Ø© Ø¨ÙˆØ§Ø¨Ø©: [${start}, ${end}] Ø¨Ø§Ø±ØªÙØ§Ø¹ ${height}`);
        
        return `gate_${entryId}_${exitId}`;
    }
    
    function addSmoothTransition(
        from: number,
        to: number,
        center: number,
        smoothness: number = 1.0
    ): string {
        /**
         * Ø¥Ø¶Ø§ÙØ© Ø§Ù†ØªÙ‚Ø§Ù„ Ø³Ù„Ø³
         * Add smooth transition
         */
        let scale = to - from;
        let sharpness = 1.0 / smoothness;
        
        return this.addSigmoidTerm(
            scale,
            sharpness,
            center,
            1,
            1.0,
            `Ø§Ù†ØªÙ‚Ø§Ù„ Ù…Ù† ${from} Ø¥Ù„Ù‰ ${to}`
        );
    }
    
    function addSharpTransition(
        from: number,
        to: number,
        center: number,
        sharpness: number = 10.0,
        cutoff: number = 3
    ): string {
        /**
         * Ø¥Ø¶Ø§ÙØ© Ø§Ù†ØªÙ‚Ø§Ù„ Ø­Ø§Ø¯
         * Add sharp transition
         */
        let scale = to - from;
        
        return this.addSigmoidTerm(
            scale,
            sharpness,
            center,
            cutoff,
            1.0,
            `Ø§Ù†ØªÙ‚Ø§Ù„ Ø­Ø§Ø¯ Ø¹Ù†Ø¯ ${center}`
        );
    }
    
    // â•â•â• Ø§Ù„ØªÙ‚ÙŠÙŠÙ… â•â•â•
    
    function evaluate(x: number): number {
        /**
         * Ø­Ø³Ø§Ø¨ Ù‚ÙŠÙ…Ø© Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ø¹Ø§Ù…Ø©
         * Evaluate General Shape Equation (GSE)
         * 
         * fÌ‚(x) = Î£ Î±áµ¢ Â· Ïƒâ‚™áµ¢(x) + L(x)
         */
        // Ø§Ù„Ù…ÙƒÙˆÙ† Ø§Ù„Ø®Ø·ÙŠ
        let result = this.linearComponent.evaluate(x);
        
        // Ù…Ø¬Ù…ÙˆØ¹ Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø³ÙŠØºÙ…ÙˆÙŠØ¯
        for (let i = 0; i < this.sigmoidTerms.length; i++) {
            result += this.sigmoidTerms[i].evaluate(x);
        }
        
        return result;
    }
    
    function evaluateRange(start: number, end: number): object[] {
        /**
         * Ø­Ø³Ø§Ø¨ Ø§Ù„Ù‚ÙŠÙ… Ø¹Ù„Ù‰ Ù†Ø·Ø§Ù‚
         * Evaluate over range
         */
        let points = [];
        let step = (end - start) / this.resolution;
        
        for (let i = 0; i <= this.resolution; i++) {
            let x = start + i * step;
            let y = this.evaluate(x);
            points.push({x: x, y: y});
        }
        
        return points;
    }
    
    function toEquationString(): string {
        /**
         * ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ Ù†Øµ Ù…Ø¹Ø§Ø¯Ù„Ø©
         * Convert to equation string
         */
        let equation = `${this.shapeName} = `;
        
        // Ø§Ù„Ù…ÙƒÙˆÙ† Ø§Ù„Ø®Ø·ÙŠ
        equation += `(${this.linearComponent.slope}x + ${this.linearComponent.intercept})`;
        
        // Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø³ÙŠØºÙ…ÙˆÙŠØ¯
        for (let i = 0; i < this.sigmoidTerms.length; i++) {
            let term = this.sigmoidTerms[i];
            let sig = term.sigmoid;
            equation += ` + ${term.weight} * Ïƒ(x; k=${sig.sharpness}, xâ‚€=${sig.center}, n=${sig.cutoff})`;
        }
        
        return equation;
    }
}

export { 
    ComplexExponent,
    GeneralizedSigmoid,
    LinearComponent,
    SigmoidTerm,
    SigmoidShapeEquation
};

