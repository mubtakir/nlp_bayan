/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * Ù…Ø­Ø±Ùƒ Ø§Ù„Ø±Ø³Ù… Ø¨Ø§Ù„Ø³ÙŠØºÙ…ÙˆÙŠØ¯ - Sigmoid Drawing Engine
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø«ÙˆØ±ÙŠ Ù„Ø±Ø³Ù… Ø§Ù„Ø£Ø´ÙƒØ§Ù„ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¯ÙˆØ§Ù„ Ø³ÙŠØºÙ…ÙˆÙŠØ¯ Ø§Ù„Ù…Ø¹Ù…Ù…Ø©
 * Revolutionary drawing engine using generalized sigmoid functions
 * 
 * Ø§Ù„ÙÙ„Ø³ÙØ©:
 * â•â•â•â•â•â•â•â•
 * - ÙƒÙ„ Ø´ÙƒÙ„ Ø·Ø¨ÙŠØ¹ÙŠ = Ø§Ø³ØªÙ‚Ø§Ù…Ø© + Ø§Ù†Ø­Ù†Ø§Ø¡
 * - Ø§Ù„Ø§Ø³ØªÙ‚Ø§Ù…Ø© = Ù…ÙƒÙˆÙ† Ø®Ø·ÙŠ
 * - Ø§Ù„Ø§Ù†Ø­Ù†Ø§Ø¡ = Ø¯ÙˆØ§Ù„ Ø³ÙŠØºÙ…ÙˆÙŠØ¯
 * - Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„ÙƒØ§Ù…Ù„ = Ù…Ø¬Ù…ÙˆØ¹ Ø§Ù„Ø­Ø¯ÙˆØ¯
 * 
 * Ø§Ù„Ù…Ù…ÙŠØ²Ø§Øª:
 * â•â•â•â•â•â•â•â•
 * âœ“ Ø±Ø³Ù… Ø¯Ù‚ÙŠÙ‚ Ù„Ù„Ø£Ø´ÙƒØ§Ù„ Ø§Ù„Ù…Ø¹Ù‚Ø¯Ø©
 * âœ“ Ø§Ù†ØªÙ‚Ø§Ù„Ø§Øª Ù†Ø§Ø¹Ù…Ø© ÙˆØ­Ø§Ø¯Ø©
 * âœ“ Ø¯ÙˆØ§Ù„ Ø§Ù„Ø¨ÙˆØ§Ø¨Ø© (Ø§Ù„Ù…Ø³ØªØ·ÙŠÙ„Ø§Øª)
 * âœ“ ØªØ­ÙƒÙ… Ù…Ø­Ù„ÙŠ ÙÙŠ Ø§Ù„Ø´ÙƒÙ„
 * âœ“ Ù„Ø§ Ø­Ø§Ø¬Ø© Ù„Ø¢Ù„Ø§Ù Ø§Ù„ØµÙˆØ±
 * 
 * @author Baserah AI System
 * @version 1.0.0
 * @date 2025-10-26
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

import { SigmoidShapeEquation } from "./sigmoid-shape-equation.bn";

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ø³ÙŠØ§Ù‚ Ø§Ù„Ø±Ø³Ù… - Drawing Context
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SigmoidCanvasContext {
    canvas: object;
    ctx: object;
    width: number;
    height: number;
    scaleX: number;
    scaleY: number;
    offsetX: number;
    offsetY: number;
    
    constructor(canvasId: string, width: number = 800, height: number = 600) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.width = width;
        this.height = height;
        
        // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ­Ø¬ÙŠÙ… Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
        this.scaleX = 50;  // 50 Ø¨ÙƒØ³Ù„ Ù„ÙƒÙ„ ÙˆØ­Ø¯Ø©
        this.scaleY = 50;
        this.offsetX = width / 2;
        this.offsetY = height / 2;
    }
    
    function setScale(scaleX: number, scaleY: number): void {
        this.scaleX = scaleX;
        this.scaleY = scaleY;
    }
    
    function setOffset(offsetX: number, offsetY: number): void {
        this.offsetX = offsetX;
        this.offsetY = offsetY;
    }
    
    function toCanvasX(x: number): number {
        return this.offsetX + x * this.scaleX;
    }
    
    function toCanvasY(y: number): number {
        return this.offsetY - y * this.scaleY;  // Ø¹ÙƒØ³ Y Ù„Ù„Ø±Ø³Ù…
    }
    
    function clear(): void {
        this.ctx.clearRect(0, 0, this.width, this.height);
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ù…Ø­Ø±Ùƒ Ø§Ù„Ø±Ø³Ù… Ø¨Ø§Ù„Ø³ÙŠØºÙ…ÙˆÙŠØ¯ - Sigmoid Drawing Engine
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SigmoidDrawingEngine {
    canvasContext: SigmoidCanvasContext;
    currentEquation: SigmoidShapeEquation;
    drawingRange: number[];
    resolution: number;
    
    // Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
    stats: object;
    
    constructor() {
        this.canvasContext = null;
        this.currentEquation = null;
        this.drawingRange = [-10, 10];
        this.resolution = 500;
        
        this.stats = {
            shapesDrawn: 0,
            termsEvaluated: 0,
            pointsPlotted: 0,
            lastDrawTime: 0
        };
        
        console.log("ğŸŒŠ ØªÙ… ØªÙ‡ÙŠØ¦Ø© Ù…Ø­Ø±Ùƒ Ø§Ù„Ø±Ø³Ù… Ø¨Ø§Ù„Ø³ÙŠØºÙ…ÙˆÙŠØ¯");
    }
    
    // â•â•â• Ø§Ù„ØªÙ‡ÙŠØ¦Ø© â•â•â•
    
    function initialize(canvasId: string, width: number = 800, height: number = 600): boolean {
        try {
            this.canvasContext = new SigmoidCanvasContext(canvasId, width, height);
            console.log(`âœ“ ØªÙ… ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù„ÙˆØ­Ø©: ${width}x${height}`);
            return true;
        } catch (e) {
            console.error(`âœ— ÙØ´Ù„ ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù„ÙˆØ­Ø©: ${e}`);
            return false;
        }
    }
    
    function setDrawingRange(start: number, end: number): void {
        this.drawingRange = [start, end];
        console.log(`âœ“ Ù†Ø·Ø§Ù‚ Ø§Ù„Ø±Ø³Ù…: [${start}, ${end}]`);
    }
    
    function setResolution(resolution: number): void {
        this.resolution = resolution;
        console.log(`âœ“ Ø¯Ù‚Ø© Ø§Ù„Ø±Ø³Ù…: ${resolution} Ù†Ù‚Ø·Ø©`);
    }
    
    // â•â•â• Ø§Ù„Ø±Ø³Ù… â•â•â•
    
    function drawEquation(equation: SigmoidShapeEquation, color: string = "#2563eb"): boolean {
        /**
         * Ø±Ø³Ù… Ù…Ø¹Ø§Ø¯Ù„Ø© Ø´ÙƒÙ„ Ø³ÙŠØºÙ…ÙˆÙŠØ¯
         * Draw sigmoid shape equation
         */
        if (!this.canvasContext) {
            console.error("âœ— Ù„Ù… ÙŠØªÙ… ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù„ÙˆØ­Ø©");
            return false;
        }
        
        let startTime = Date.now();
        
        this.currentEquation = equation;
        let ctx = this.canvasContext.ctx;
        
        // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù†Ù‚Ø§Ø·
        let points = equation.evaluateRange(this.drawingRange[0], this.drawingRange[1]);
        
        // Ø¨Ø¯Ø¡ Ø§Ù„Ø±Ø³Ù…
        ctx.beginPath();
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        
        // Ø±Ø³Ù… Ø§Ù„Ù…Ù†Ø­Ù†Ù‰
        for (let i = 0; i < points.length; i++) {
            let point = points[i];
            let canvasX = this.canvasContext.toCanvasX(point.x);
            let canvasY = this.canvasContext.toCanvasY(point.y);
            
            if (i === 0) {
                ctx.moveTo(canvasX, canvasY);
            } else {
                ctx.lineTo(canvasX, canvasY);
            }
        }
        
        ctx.stroke();
        
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
        this.stats.shapesDrawn++;
        this.stats.termsEvaluated += equation.sigmoidTerms.length;
        this.stats.pointsPlotted += points.length;
        this.stats.lastDrawTime = Date.now() - startTime;
        
        console.log(`âœ“ ØªÙ… Ø±Ø³Ù…: ${equation.shapeName} (${this.stats.lastDrawTime}ms)`);
        
        return true;
    }
    
    function drawParametric(
        equation: SigmoidShapeEquation,
        yEquation: SigmoidShapeEquation,
        color: string = "#2563eb"
    ): boolean {
        /**
         * Ø±Ø³Ù… Ù…Ù†Ø­Ù†Ù‰ Ø¨Ø§Ø±Ø§Ù…ØªØ±ÙŠ
         * Draw parametric curve
         * 
         * x = equation(t)
         * y = yEquation(t)
         */
        if (!this.canvasContext) {
            console.error("âœ— Ù„Ù… ÙŠØªÙ… ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù„ÙˆØ­Ø©");
            return false;
        }
        
        let ctx = this.canvasContext.ctx;
        
        // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù†Ù‚Ø§Ø·
        let step = (this.drawingRange[1] - this.drawingRange[0]) / this.resolution;
        
        ctx.beginPath();
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        
        for (let i = 0; i <= this.resolution; i++) {
            let t = this.drawingRange[0] + i * step;
            let x = equation.evaluate(t);
            let y = yEquation.evaluate(t);
            
            let canvasX = this.canvasContext.toCanvasX(x);
            let canvasY = this.canvasContext.toCanvasY(y);
            
            if (i === 0) {
                ctx.moveTo(canvasX, canvasY);
            } else {
                ctx.lineTo(canvasX, canvasY);
            }
        }
        
        ctx.stroke();
        
        console.log(`âœ“ ØªÙ… Ø±Ø³Ù… Ù…Ù†Ø­Ù†Ù‰ Ø¨Ø§Ø±Ø§Ù…ØªØ±ÙŠ`);
        
        return true;
    }
    
    function drawAxes(): void {
        /**
         * Ø±Ø³Ù… Ø§Ù„Ù…Ø­Ø§ÙˆØ±
         * Draw axes
         */
        if (!this.canvasContext) return;
        
        let ctx = this.canvasContext.ctx;
        
        ctx.strokeStyle = "#94a3b8";
        ctx.lineWidth = 1;
        
        // Ø§Ù„Ù…Ø­ÙˆØ± X
        ctx.beginPath();
        ctx.moveTo(0, this.canvasContext.offsetY);
        ctx.lineTo(this.canvasContext.width, this.canvasContext.offsetY);
        ctx.stroke();
        
        // Ø§Ù„Ù…Ø­ÙˆØ± Y
        ctx.beginPath();
        ctx.moveTo(this.canvasContext.offsetX, 0);
        ctx.lineTo(this.canvasContext.offsetX, this.canvasContext.height);
        ctx.stroke();
    }
    
    function drawGrid(spacing: number = 1): void {
        /**
         * Ø±Ø³Ù… Ø§Ù„Ø´Ø¨ÙƒØ©
         * Draw grid
         */
        if (!this.canvasContext) return;
        
        let ctx = this.canvasContext.ctx;
        
        ctx.strokeStyle = "#e2e8f0";
        ctx.lineWidth = 0.5;
        
        // Ø®Ø·ÙˆØ· Ø¹Ù…ÙˆØ¯ÙŠØ©
        for (let x = this.drawingRange[0]; x <= this.drawingRange[1]; x += spacing) {
            let canvasX = this.canvasContext.toCanvasX(x);
            ctx.beginPath();
            ctx.moveTo(canvasX, 0);
            ctx.lineTo(canvasX, this.canvasContext.height);
            ctx.stroke();
        }
        
        // Ø®Ø·ÙˆØ· Ø£ÙÙ‚ÙŠØ©
        for (let y = this.drawingRange[0]; y <= this.drawingRange[1]; y += spacing) {
            let canvasY = this.canvasContext.toCanvasY(y);
            ctx.beginPath();
            ctx.moveTo(0, canvasY);
            ctx.lineTo(this.canvasContext.width, canvasY);
            ctx.stroke();
        }
    }
    
    function clear(): void {
        /**
         * Ù…Ø³Ø­ Ø§Ù„Ù„ÙˆØ­Ø©
         * Clear canvas
         */
        if (this.canvasContext) {
            this.canvasContext.clear();
        }
    }
    
    // â•â•â• Ø£Ø¯ÙˆØ§Øª Ù…Ø³Ø§Ø¹Ø¯Ø© â•â•â•
    
    function visualizeTerms(equation: SigmoidShapeEquation): void {
        /**
         * Ø±Ø³Ù… ÙƒÙ„ Ø­Ø¯ Ø¹Ù„Ù‰ Ø­Ø¯Ø©
         * Visualize individual terms
         */
        if (!this.canvasContext) return;
        
        let colors = ["#ef4444", "#f59e0b", "#10b981", "#3b82f6", "#8b5cf6"];
        
        // Ø±Ø³Ù… Ø§Ù„Ù…ÙƒÙˆÙ† Ø§Ù„Ø®Ø·ÙŠ
        let linearEq = new SigmoidShapeEquation("Linear");
        linearEq.setLinearComponent(
            equation.linearComponent.slope,
            equation.linearComponent.intercept
        );
        this.drawEquation(linearEq, "#94a3b8");
        
        // Ø±Ø³Ù… ÙƒÙ„ Ø­Ø¯ Ø³ÙŠØºÙ…ÙˆÙŠØ¯
        for (let i = 0; i < equation.sigmoidTerms.length; i++) {
            let term = equation.sigmoidTerms[i];
            let termEq = new SigmoidShapeEquation(`Term ${i + 1}`);
            
            let sig = term.sigmoid;
            termEq.addSigmoidTerm(
                sig.scale,
                sig.sharpness,
                sig.center,
                sig.cutoff,
                term.weight
            );
            
            let color = colors[i % colors.length];
            this.drawEquation(termEq, color);
        }
        
        // Ø±Ø³Ù… Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„ÙƒØ§Ù…Ù„Ø©
        this.drawEquation(equation, "#000000");
    }
    
    function getStats(): object {
        /**
         * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
         * Get statistics
         */
        return {
            shapesDrawn: this.stats.shapesDrawn,
            termsEvaluated: this.stats.termsEvaluated,
            pointsPlotted: this.stats.pointsPlotted,
            lastDrawTime: this.stats.lastDrawTime,
            averagePointsPerShape: this.stats.shapesDrawn > 0 
                ? Math.floor(this.stats.pointsPlotted / this.stats.shapesDrawn)
                : 0
        };
    }
}

export { SigmoidCanvasContext, SigmoidDrawingEngine };

