/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * Ù…Ø³ØªØ®Ù„Øµ Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ù…Ø´ØªØ±ÙƒØ© Ù…Ù† Ø§Ù„ØµÙˆØ± - Image Common Features Extractor
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * Ø§Ù„ÙˆØµÙ: Ù†Ø¸Ø§Ù… Ø§Ø³ØªØ®Ù„Ø§Øµ Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ù…Ø´ØªØ±ÙƒØ© Ù…Ù† Ù…Ø¬Ù…ÙˆØ¹Ø© ØµÙˆØ±
 * Ø§Ù„Ù‡Ø¯Ù: Ø¥ÙŠØ¬Ø§Ø¯ Ø§Ù„Ø¹ÙˆØ§Ù…Ù„ Ø§Ù„Ù…Ø´ØªØ±ÙƒØ© Ø¨ÙŠÙ† ØµÙˆØ± Ù…ØªØ¹Ø¯Ø¯Ø© Ù„Ù†ÙØ³ Ø§Ù„ÙƒØ§Ø¦Ù†
 * Ø§Ù„Ù…Ù†Ù‡Ø¬ÙŠØ©: Ø§Ø³ØªÙ†Ø¨Ø§Ø· + Ù…Ù‚Ø§Ø±Ù†Ø© + ØªØµÙÙŠØ© + Ø§Ø³ØªØ®Ù„Ø§Øµ
 * 
 * Ø§Ù„ÙÙƒØ±Ø©:
 * â•â•â•â•â•â•â•
 * - Ø¥Ø¯Ø®Ø§Ù„ Ù…Ø¬Ù…ÙˆØ¹Ø© ØµÙˆØ± Ù„Ù†ÙØ³ Ø§Ù„ÙƒØ§Ø¦Ù† (Ù…Ø«Ù„Ø§Ù‹: Ù‚Ø·Ø©)
 * - ÙƒÙ„ ØµÙˆØ±Ø© Ù‚Ø¯ ØªØ®ØªÙ„Ù ÙÙŠ: Ø§Ù„Ø®Ù„ÙÙŠØ©ØŒ Ø§Ù„Ø­Ø¬Ù…ØŒ Ø§Ù„Ù…ÙˆÙ‚Ø¹ØŒ Ø§Ù„Ù„ÙˆÙ†ØŒ Ø§Ù„Ø²Ø§ÙˆÙŠØ©
 * - Ø§Ù„Ù†Ø¸Ø§Ù… ÙŠØ³ØªÙ†Ø¨Ø· Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ù„ÙƒÙ„ ØµÙˆØ±Ø©
 * - ÙŠÙ‚Ø§Ø±Ù† Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø§Øª ÙˆÙŠØ¬Ø¯ Ø§Ù„Ø¹ÙˆØ§Ù…Ù„ Ø§Ù„Ù…Ø´ØªØ±ÙƒØ©
 * - Ø§Ù„Ø¹ÙˆØ§Ù…Ù„ Ø§Ù„Ù…Ø´ØªØ±ÙƒØ© = Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ Ù„Ù„ÙƒØ§Ø¦Ù†
 * - Ù…Ø§ Ø¹Ø¯Ø§Ù‡Ø§ = Ø®Ù„ÙÙŠØ§Øª ÙˆØªÙØ§ØµÙŠÙ„ Ø«Ø§Ù†ÙˆÙŠØ©
 * 
 * Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„ØªØ¬Ø§ÙˆØ²:
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * - ØªØ¬Ø§ÙˆØ² Ø§Ù„Ù…ÙˆÙ‚Ø¹ (Position Invariance)
 * - ØªØ¬Ø§ÙˆØ² Ø§Ù„Ø­Ø¬Ù… (Scale Invariance)
 * - ØªØ¬Ø§ÙˆØ² Ø§Ù„Ù„ÙˆÙ† (Color Invariance)
 * - ØªØ¬Ø§ÙˆØ² Ø§Ù„Ø¯ÙˆØ±Ø§Ù† (Rotation Invariance)
 * - ØªØ¬Ø§ÙˆØ² Ø§Ù„Ø¥Ø¶Ø§Ø¡Ø© (Illumination Invariance)
 * 
 * Ø§Ù„Ù…Ø·ÙˆØ±: Ø¨ØµÙŠØ±Ø© AI
 * Ø§Ù„ØªØ§Ø±ÙŠØ®: 2025-10-29
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

import { MotherEquation } from "../core/mother-equation.bn";
import { SigmoidShapeEquation } from "./sigmoid-shape-equation.bn";
import { SigmoidInferenceEngine, InferenceResult } from "./sigmoid-inference-engine.bn";

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ø§Ù„ØªØ¹Ø¯Ø§Ø¯Ø§Øª - Enumerations
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„ØªØ¬Ø§ÙˆØ²
 */
export enum InvarianceOption {
    POSITION = "POSITION",           // ØªØ¬Ø§ÙˆØ² Ø§Ù„Ù…ÙˆÙ‚Ø¹
    SCALE = "SCALE",                 // ØªØ¬Ø§ÙˆØ² Ø§Ù„Ø­Ø¬Ù…
    COLOR = "COLOR",                 // ØªØ¬Ø§ÙˆØ² Ø§Ù„Ù„ÙˆÙ†
    ROTATION = "ROTATION",           // ØªØ¬Ø§ÙˆØ² Ø§Ù„Ø¯ÙˆØ±Ø§Ù†
    ILLUMINATION = "ILLUMINATION",   // ØªØ¬Ø§ÙˆØ² Ø§Ù„Ø¥Ø¶Ø§Ø¡Ø©
    PERSPECTIVE = "PERSPECTIVE",     // ØªØ¬Ø§ÙˆØ² Ø§Ù„Ù…Ù†Ø¸ÙˆØ±
    NOISE = "NOISE"                  // ØªØ¬Ø§ÙˆØ² Ø§Ù„Ø¶ÙˆØ¶Ø§Ø¡
}

/**
 * Ù†ÙˆØ¹ Ø§Ù„Ù…ÙŠØ²Ø©
 */
export enum FeatureType {
    GEOMETRIC = "GEOMETRIC",         // Ù‡Ù†Ø¯Ø³ÙŠØ© (Ø´ÙƒÙ„ØŒ Ø­ÙˆØ§Ù)
    TOPOLOGICAL = "TOPOLOGICAL",     // Ø·ÙˆØ¨ÙˆÙ„ÙˆØ¬ÙŠØ© (Ø§ØªØµØ§Ù„ØŒ Ø«Ù‚ÙˆØ¨)
    TEXTURAL = "TEXTURAL",           // Ù†Ø³ÙŠØ¬ÙŠØ© (Ù†Ù…Ø· Ø§Ù„Ø³Ø·Ø­)
    SPECTRAL = "SPECTRAL",           // Ø·ÙŠÙÙŠØ© (Ø£Ù„ÙˆØ§Ù†ØŒ ØªØ±Ø¯Ø¯)
    STRUCTURAL = "STRUCTURAL",       // Ø¨Ù†ÙŠÙˆÙŠØ© (ØªØ±ÙƒÙŠØ¨)
    STATISTICAL = "STATISTICAL"      // Ø¥Ø­ØµØ§Ø¦ÙŠØ© (ØªÙˆØ²ÙŠØ¹)
}

/**
 * Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø«Ù‚Ø©
 */
export enum ConfidenceLevel {
    VERY_HIGH = "VERY_HIGH",         // Ø«Ù‚Ø© Ø¹Ø§Ù„ÙŠØ© Ø¬Ø¯Ø§Ù‹ (>90%)
    HIGH = "HIGH",                   // Ø«Ù‚Ø© Ø¹Ø§Ù„ÙŠØ© (70-90%)
    MEDIUM = "MEDIUM",               // Ø«Ù‚Ø© Ù…ØªÙˆØ³Ø·Ø© (50-70%)
    LOW = "LOW",                     // Ø«Ù‚Ø© Ù…Ù†Ø®ÙØ¶Ø© (30-50%)
    VERY_LOW = "VERY_LOW"            // Ø«Ù‚Ø© Ù…Ù†Ø®ÙØ¶Ø© Ø¬Ø¯Ø§Ù‹ (<30%)
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ø§Ù„ÙØ¦Ø§Øª - Classes
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * ØµÙˆØ±Ø© Ù…Ø¯Ø®Ù„Ø©
 */
export class InputImage extends MotherEquation {
    public imageId: string;
    public imageData: any;                    // Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØµÙˆØ±Ø©
    public width: number;
    public height: number;
    public metadata: Map<string, any>;        // Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ©
    public inferenceResult: InferenceResult | null;  // Ù†ØªÙŠØ¬Ø© Ø§Ù„Ø§Ø³ØªÙ†Ø¨Ø§Ø·
    
    constructor(imageId: string, imageData: any, width: number, height: number) {
        super();
        this.imageId = imageId;
        this.imageData = imageData;
        this.width = width;
        this.height = height;
        this.metadata = new Map();
        this.inferenceResult = null;
    }
    
    public setMetadata(key: string, value: any): void {
        this.metadata.set(key, value);
    }
    
    public getMetadata(key: string): any {
        return this.metadata.get(key);
    }
}

/**
 * Ù…ÙŠØ²Ø© Ù…Ø´ØªØ±ÙƒØ©
 */
export class CommonFeature extends MotherEquation {
    public featureId: string;
    public featureType: FeatureType;
    public value: any;                        // Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…ÙŠØ²Ø©
    public occurrenceCount: number;           // Ø¹Ø¯Ø¯ Ù…Ø±Ø§Øª Ø§Ù„Ø¸Ù‡ÙˆØ±
    public occurrenceRate: number;            // Ù†Ø³Ø¨Ø© Ø§Ù„Ø¸Ù‡ÙˆØ± (0-1)
    public variance: number;                  // Ø§Ù„ØªØ¨Ø§ÙŠÙ†
    public confidence: ConfidenceLevel;
    public sourceImages: Array<string>;       // Ø§Ù„ØµÙˆØ± Ø§Ù„Ù…ØµØ¯Ø±
    
    constructor(featureId: string, featureType: FeatureType, value: any) {
        super();
        this.featureId = featureId;
        this.featureType = featureType;
        this.value = value;
        this.occurrenceCount = 0;
        this.occurrenceRate = 0.0;
        this.variance = 0.0;
        this.confidence = ConfidenceLevel.MEDIUM;
        this.sourceImages = [];
    }
    
    public addOccurrence(imageId: string): void {
        this.occurrenceCount++;
        if (!this.sourceImages.includes(imageId)) {
            this.sourceImages.push(imageId);
        }
    }
    
    public calculateConfidence(totalImages: number): void {
        this.occurrenceRate = this.occurrenceCount / totalImages;
        
        if (this.occurrenceRate > 0.9) {
            this.confidence = ConfidenceLevel.VERY_HIGH;
        } else if (this.occurrenceRate > 0.7) {
            this.confidence = ConfidenceLevel.HIGH;
        } else if (this.occurrenceRate > 0.5) {
            this.confidence = ConfidenceLevel.MEDIUM;
        } else if (this.occurrenceRate > 0.3) {
            this.confidence = ConfidenceLevel.LOW;
        } else {
            this.confidence = ConfidenceLevel.VERY_LOW;
        }
    }
    
    public getDescription(): string {
        return `Ù…ÙŠØ²Ø© ${this.featureType}: Ø¸Ù‡Ø±Øª ÙÙŠ ${this.occurrenceCount} ØµÙˆØ±Ø© (${(this.occurrenceRate * 100).toFixed(1)}%) - Ø«Ù‚Ø©: ${this.confidence}`;
    }
}

/**
 * Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø§Ø³ØªØ®Ù„Ø§Øµ
 */
export class ExtractionSettings extends MotherEquation {
    public toleranceRate: number;             // Ù†Ø³Ø¨Ø© Ø§Ù„Ø³Ù…Ø§Ø­ (0-1)
    public minOccurrenceRate: number;         // Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ù†Ø³Ø¨Ø© Ø§Ù„Ø¸Ù‡ÙˆØ±
    public invarianceOptions: Set<InvarianceOption>;  // Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„ØªØ¬Ø§ÙˆØ²
    public featureTypes: Set<FeatureType>;    // Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ù…ÙŠØ²Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©
    public normalizeFeatures: boolean;        // ØªØ·Ø¨ÙŠØ¹ Ø§Ù„Ù…ÙŠØ²Ø§Øª
    
    constructor() {
        super();
        this.toleranceRate = 0.15;            // 15% Ø³Ù…Ø§Ø­ Ø§ÙØªØ±Ø§Ø¶ÙŠ
        this.minOccurrenceRate = 0.5;         // 50% Ø­Ø¯ Ø£Ø¯Ù†Ù‰
        this.invarianceOptions = new Set();
        this.featureTypes = new Set();
        this.normalizeFeatures = true;
        
        // Ø¥Ø¶Ø§ÙØ© Ø¬Ù…ÙŠØ¹ Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ù…ÙŠØ²Ø§Øª Ø§ÙØªØ±Ø§Ø¶ÙŠØ§Ù‹
        this.featureTypes.add(FeatureType.GEOMETRIC);
        this.featureTypes.add(FeatureType.TOPOLOGICAL);
        this.featureTypes.add(FeatureType.TEXTURAL);
        this.featureTypes.add(FeatureType.SPECTRAL);
        this.featureTypes.add(FeatureType.STRUCTURAL);
        this.featureTypes.add(FeatureType.STATISTICAL);
    }
    
    public enableInvariance(option: InvarianceOption): void {
        this.invarianceOptions.add(option);
    }
    
    public disableInvariance(option: InvarianceOption): void {
        this.invarianceOptions.delete(option);
    }
    
    public isInvarianceEnabled(option: InvarianceOption): boolean {
        return this.invarianceOptions.has(option);
    }
    
    public enableFeatureType(type: FeatureType): void {
        this.featureTypes.add(type);
    }
    
    public disableFeatureType(type: FeatureType): void {
        this.featureTypes.delete(type);
    }
}

/**
 * Ù†ØªÙŠØ¬Ø© Ø§Ù„Ø§Ø³ØªØ®Ù„Ø§Øµ
 */
export class ExtractionResult extends MotherEquation {
    public resultId: string;
    public commonFeatures: Array<CommonFeature>;
    public totalImages: number;
    public processedImages: number;
    public overallConfidence: number;
    public extractedShape: SigmoidShapeEquation | null;  // Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ù…Ø³ØªØ®Ù„Øµ
    public report: string;
    public timestamp: number;
    public processingTime: number;            // ÙˆÙ‚Øª Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© (ms)
    
    constructor(resultId: string) {
        super();
        this.resultId = resultId;
        this.commonFeatures = [];
        this.totalImages = 0;
        this.processedImages = 0;
        this.overallConfidence = 0.0;
        this.extractedShape = null;
        this.report = "";
        this.timestamp = Date.now();
        this.processingTime = 0;
    }
    
    public addCommonFeature(feature: CommonFeature): void {
        this.commonFeatures.push(feature);
    }
    
    public calculateOverallConfidence(): void {
        if (this.commonFeatures.length === 0) {
            this.overallConfidence = 0.0;
            return;
        }
        
        let sum = 0.0;
        this.commonFeatures.forEach(feature => {
            sum += feature.occurrenceRate;
        });
        
        this.overallConfidence = sum / this.commonFeatures.length;
    }
    
    public generateReport(): string {
        let report = "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
        report += "ØªÙ‚Ø±ÙŠØ± Ø§Ø³ØªØ®Ù„Ø§Øµ Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ù…Ø´ØªØ±ÙƒØ©\n";
        report += "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
        
        report += `ğŸ“Š Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª:\n`;
        report += `  - Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ØµÙˆØ±: ${this.totalImages}\n`;
        report += `  - Ø§Ù„ØµÙˆØ± Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©: ${this.processedImages}\n`;
        report += `  - Ø§Ù„Ù…ÙŠØ²Ø§Øª Ø§Ù„Ù…Ø´ØªØ±ÙƒØ©: ${this.commonFeatures.length}\n`;
        report += `  - Ø§Ù„Ø«Ù‚Ø© Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠØ©: ${(this.overallConfidence * 100).toFixed(1)}%\n`;
        report += `  - ÙˆÙ‚Øª Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©: ${this.processingTime}ms\n\n`;
        
        report += `ğŸ” Ø§Ù„Ù…ÙŠØ²Ø§Øª Ø§Ù„Ù…Ø´ØªØ±ÙƒØ©:\n`;
        this.commonFeatures.forEach((feature, index) => {
            report += `  ${index + 1}. ${feature.getDescription()}\n`;
        });
        
        if (this.extractedShape) {
            report += `\nâœ… ØªÙ… Ø§Ø³ØªØ®Ù„Ø§Øµ Ø§Ù„Ø´ÙƒÙ„ Ø¨Ù†Ø¬Ø§Ø­!\n`;
        }
        
        report += "\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
        
        this.report = report;
        return report;
    }
}

/**
 * Ù…Ø³ØªØ®Ù„Øµ Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ù…Ø´ØªØ±ÙƒØ© Ù…Ù† Ø§Ù„ØµÙˆØ±
 */
export class ImageCommonFeaturesExtractor extends MotherEquation {
    public extractorId: string;
    public inferenceEngine: SigmoidInferenceEngine;
    public settings: ExtractionSettings;
    public inputImages: Array<InputImage>;
    public results: Array<ExtractionResult>;
    public statistics: Map<string, number>;
    
    constructor(extractorId: string = "extractor_001") {
        super();
        this.extractorId = extractorId;
        this.inferenceEngine = new SigmoidInferenceEngine("inference_engine_001");
        this.settings = new ExtractionSettings();
        this.inputImages = [];
        this.results = [];
        this.statistics = new Map();
        
        this.initializeStatistics();
    }
    
    private initializeStatistics(): void {
        this.statistics.set("totalExtractions", 0);
        this.statistics.set("totalImages", 0);
        this.statistics.set("successfulExtractions", 0);
        this.statistics.set("averageConfidence", 0.0);
    }
    
    public addImage(image: InputImage): void {
        this.inputImages.push(image);
        this.statistics.set("totalImages", this.inputImages.length);
    }
    
    public clearImages(): void {
        this.inputImages = [];
        this.statistics.set("totalImages", 0);
    }
    
    public extract(): ExtractionResult {
        const startTime = Date.now();
        const result = new ExtractionResult(`result_${Date.now()}`);
        result.totalImages = this.inputImages.length;
        
        console.log(`ğŸ” Ø¨Ø¯Ø¡ Ø§Ø³ØªØ®Ù„Ø§Øµ Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ù…Ø´ØªØ±ÙƒØ© Ù…Ù† ${this.inputImages.length} ØµÙˆØ±Ø©...`);
        
        // Ø§Ù„Ø®Ø·ÙˆØ© 1: Ø§Ø³ØªÙ†Ø¨Ø§Ø· Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ù„ÙƒÙ„ ØµÙˆØ±Ø©
        this.inferAllImages();
        result.processedImages = this.inputImages.length;
        
        // Ø§Ù„Ø®Ø·ÙˆØ© 2: Ø§Ø³ØªØ®Ù„Ø§Øµ Ø§Ù„Ù…ÙŠØ²Ø§Øª Ù…Ù† ÙƒÙ„ ØµÙˆØ±Ø©
        const allFeatures = this.extractFeaturesFromAllImages();
        
        // Ø§Ù„Ø®Ø·ÙˆØ© 3: Ø¥ÙŠØ¬Ø§Ø¯ Ø§Ù„Ù…ÙŠØ²Ø§Øª Ø§Ù„Ù…Ø´ØªØ±ÙƒØ©
        const commonFeatures = this.findCommonFeatures(allFeatures);
        
        // Ø§Ù„Ø®Ø·ÙˆØ© 4: ØªØµÙÙŠØ© Ø­Ø³Ø¨ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
        const filteredFeatures = this.filterFeatures(commonFeatures);
        
        // Ø§Ù„Ø®Ø·ÙˆØ© 5: Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…ÙŠØ²Ø§Øª Ø¥Ù„Ù‰ Ø§Ù„Ù†ØªÙŠØ¬Ø©
        filteredFeatures.forEach(feature => {
            feature.calculateConfidence(this.inputImages.length);
            result.addCommonFeature(feature);
        });
        
        // Ø§Ù„Ø®Ø·ÙˆØ© 6: Ø§Ø³ØªØ®Ù„Ø§Øµ Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ
        result.extractedShape = this.extractFinalShape(filteredFeatures);
        
        // Ø§Ù„Ø®Ø·ÙˆØ© 7: Ø­Ø³Ø§Ø¨ Ø§Ù„Ø«Ù‚Ø© Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠØ©
        result.calculateOverallConfidence();
        
        // Ø§Ù„Ø®Ø·ÙˆØ© 8: ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØªÙ‚Ø±ÙŠØ±
        result.processingTime = Date.now() - startTime;
        result.generateReport();
        
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
        this.updateStatistics(result);
        
        this.results.push(result);
        
        console.log(`âœ… Ø§ÙƒØªÙ…Ù„ Ø§Ù„Ø§Ø³ØªØ®Ù„Ø§Øµ! Ø§Ù„Ø«Ù‚Ø©: ${(result.overallConfidence * 100).toFixed(1)}%`);
        
        return result;
    }

    private inferAllImages(): void {
        console.log("ğŸ“ Ø§Ø³ØªÙ†Ø¨Ø§Ø· Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø§Ù„Ø£Ø´ÙƒØ§Ù„...");

        this.inputImages.forEach((image, index) => {
            console.log(`  Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø© ${index + 1}/${this.inputImages.length}: ${image.imageId}`);

            // Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ø³ØªÙ†Ø¨Ø§Ø· Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø© (ÙÙŠ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØŒ Ø§Ø³ØªØ®Ø¯Ø§Ù… inferenceEngine)
            // image.inferenceResult = this.inferenceEngine.inferFromImage(image.imageData);

            // Ù…Ø­Ø§ÙƒØ§Ø© Ù…Ø¤Ù‚ØªØ©
            const mockEquation = new SigmoidShapeEquation(`eq_${image.imageId}`);
            const mockResult = new InferenceResult(mockEquation);
            mockResult.confidence = 0.8 + Math.random() * 0.15;
            image.inferenceResult = mockResult;
        });
    }

    private extractFeaturesFromAllImages(): Map<string, Array<any>> {
        console.log("ğŸ”¬ Ø§Ø³ØªØ®Ù„Ø§Øµ Ø§Ù„Ù…ÙŠØ²Ø§Øª Ù…Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„ØµÙˆØ±...");

        const allFeatures = new Map<string, Array<any>>();

        this.inputImages.forEach(image => {
            if (!image.inferenceResult) return;

            const features = this.extractFeaturesFromImage(image);

            features.forEach((value, key) => {
                if (!allFeatures.has(key)) {
                    allFeatures.set(key, []);
                }
                allFeatures.get(key)!.push({
                    imageId: image.imageId,
                    value: value
                });
            });
        });

        return allFeatures;
    }

    private extractFeaturesFromImage(image: InputImage): Map<string, any> {
        const features = new Map<string, any>();

        if (!image.inferenceResult) return features;

        const result = image.inferenceResult;

        // Ø§Ø³ØªØ®Ù„Ø§Øµ Ø§Ù„Ù…ÙŠØ²Ø§Øª Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠØ©
        if (this.settings.featureTypes.has(FeatureType.GEOMETRIC)) {
            features.set("curvature", result.features.curvature);
            features.set("symmetry", result.features.symmetry);
            features.set("aspectRatio", result.features.aspectRatio);
            features.set("compactness", result.features.compactness);
        }

        // Ø§Ø³ØªØ®Ù„Ø§Øµ Ø§Ù„Ù…ÙŠØ²Ø§Øª Ø§Ù„Ø·ÙˆØ¨ÙˆÙ„ÙˆØ¬ÙŠØ©
        if (this.settings.featureTypes.has(FeatureType.TOPOLOGICAL)) {
            features.set("isClosed", result.features.isClosed);
            features.set("zeroCrossings", result.features.zeroCrossings);
        }

        // Ø§Ø³ØªØ®Ù„Ø§Øµ Ø§Ù„Ù…ÙŠØ²Ø§Øª Ø§Ù„Ù†Ø³ÙŠØ¬ÙŠØ©
        if (this.settings.featureTypes.has(FeatureType.TEXTURAL)) {
            features.set("complexity", result.features.complexity);
            features.set("entropy", result.features.entropy);
        }

        // Ø§Ø³ØªØ®Ù„Ø§Øµ Ø§Ù„Ù…ÙŠØ²Ø§Øª Ø§Ù„Ø·ÙŠÙÙŠØ©
        if (this.settings.featureTypes.has(FeatureType.SPECTRAL)) {
            features.set("periodicity", result.features.periodicity);
        }

        // Ø§Ø³ØªØ®Ù„Ø§Øµ Ø§Ù„Ù…ÙŠØ²Ø§Øª Ø§Ù„Ø¨Ù†ÙŠÙˆÙŠØ©
        if (this.settings.featureTypes.has(FeatureType.STRUCTURAL)) {
            features.set("extremaCount", result.features.extremaCount);
            features.set("inflectionPoints", result.features.inflectionPoints);
        }

        // Ø§Ø³ØªØ®Ù„Ø§Øµ Ø§Ù„Ù…ÙŠØ²Ø§Øª Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ©
        if (this.settings.featureTypes.has(FeatureType.STATISTICAL)) {
            features.set("variance", result.features.variance);
            features.set("area", result.features.area);
            features.set("perimeter", result.features.perimeter);
        }

        return features;
    }

    private findCommonFeatures(allFeatures: Map<string, Array<any>>): Array<CommonFeature> {
        console.log("ğŸ” Ø¥ÙŠØ¬Ø§Ø¯ Ø§Ù„Ù…ÙŠØ²Ø§Øª Ø§Ù„Ù…Ø´ØªØ±ÙƒØ©...");

        const commonFeatures: Array<CommonFeature> = [];

        allFeatures.forEach((occurrences, featureName) => {
            // ØªØ­Ø¯ÙŠØ¯ Ù†ÙˆØ¹ Ø§Ù„Ù…ÙŠØ²Ø©
            const featureType = this.determineFeatureType(featureName);

            // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…ØªÙˆØ³Ø·Ø©
            const values = occurrences.map(occ => occ.value);
            const avgValue = this.calculateAverage(values);

            // Ø­Ø³Ø§Ø¨ Ø§Ù„ØªØ¨Ø§ÙŠÙ†
            const variance = this.calculateVariance(values, avgValue);

            // ØªØ·Ø¨ÙŠÙ‚ Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„ØªØ¬Ø§ÙˆØ²
            const normalizedValue = this.applyInvariance(featureName, avgValue);

            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…ÙŠØ²Ø© Ø§Ù„Ù…Ø´ØªØ±ÙƒØ©
            const feature = new CommonFeature(
                `feature_${featureName}`,
                featureType,
                normalizedValue
            );

            feature.variance = variance;

            // Ø¥Ø¶Ø§ÙØ© Ù…Ø±Ø§Øª Ø§Ù„Ø¸Ù‡ÙˆØ±
            occurrences.forEach(occ => {
                feature.addOccurrence(occ.imageId);
            });

            commonFeatures.push(feature);
        });

        return commonFeatures;
    }

    private filterFeatures(features: Array<CommonFeature>): Array<CommonFeature> {
        console.log("ğŸ”¬ ØªØµÙÙŠØ© Ø§Ù„Ù…ÙŠØ²Ø§Øª...");

        return features.filter(feature => {
            // Ø­Ø³Ø§Ø¨ Ù†Ø³Ø¨Ø© Ø§Ù„Ø¸Ù‡ÙˆØ±
            const occurrenceRate = feature.occurrenceCount / this.inputImages.length;

            // ØªØµÙÙŠØ© Ø­Ø³Ø¨ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰
            if (occurrenceRate < this.settings.minOccurrenceRate) {
                return false;
            }

            // ØªØµÙÙŠØ© Ø­Ø³Ø¨ Ø§Ù„ØªØ¨Ø§ÙŠÙ† (Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ØªØ¨Ø§ÙŠÙ† ÙƒØ¨ÙŠØ± Ø¬Ø¯Ø§Ù‹ØŒ Ù‚Ø¯ ØªÙƒÙˆÙ† Ø§Ù„Ù…ÙŠØ²Ø© ØºÙŠØ± Ù…Ø´ØªØ±ÙƒØ©)
            if (feature.variance > this.settings.toleranceRate) {
                return false;
            }

            return true;
        });
    }

    private extractFinalShape(features: Array<CommonFeature>): SigmoidShapeEquation | null {
        console.log("ğŸ¨ Ø§Ø³ØªØ®Ù„Ø§Øµ Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ...");

        if (features.length === 0) {
            return null;
        }

        // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¹Ø§Ø¯Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù…ÙŠØ²Ø§Øª Ø§Ù„Ù…Ø´ØªØ±ÙƒØ©
        const finalEquation = new SigmoidShapeEquation("final_shape");

        // Ù‡Ù†Ø§ ÙŠÙ…ÙƒÙ† Ø¨Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø© Ù…Ù† Ø§Ù„Ù…ÙŠØ²Ø§Øª Ø§Ù„Ù…Ø´ØªØ±ÙƒØ©
        // ÙÙŠ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØŒ Ø³ÙŠØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…ÙŠØ²Ø§Øª Ù„Ø¨Ù†Ø§Ø¡ Ù…Ø¹Ø§Ø¯Ù„Ø© Ø¯Ù‚ÙŠÙ‚Ø©

        return finalEquation;
    }

    private determineFeatureType(featureName: string): FeatureType {
        const geometricFeatures = ["curvature", "symmetry", "aspectRatio", "compactness"];
        const topologicalFeatures = ["isClosed", "zeroCrossings"];
        const texturalFeatures = ["complexity", "entropy"];
        const spectralFeatures = ["periodicity"];
        const structuralFeatures = ["extremaCount", "inflectionPoints"];
        const statisticalFeatures = ["variance", "area", "perimeter"];

        if (geometricFeatures.includes(featureName)) return FeatureType.GEOMETRIC;
        if (topologicalFeatures.includes(featureName)) return FeatureType.TOPOLOGICAL;
        if (texturalFeatures.includes(featureName)) return FeatureType.TEXTURAL;
        if (spectralFeatures.includes(featureName)) return FeatureType.SPECTRAL;
        if (structuralFeatures.includes(featureName)) return FeatureType.STRUCTURAL;
        if (statisticalFeatures.includes(featureName)) return FeatureType.STATISTICAL;

        return FeatureType.GEOMETRIC;
    }

    private calculateAverage(values: Array<any>): number {
        if (values.length === 0) return 0.0;

        // Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ù…Ù†Ø·Ù‚ÙŠØ©
        if (typeof values[0] === 'boolean') {
            const trueCount = values.filter(v => v === true).length;
            return trueCount / values.length;
        }

        // Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ø¹Ø¯Ø¯ÙŠØ©
        const sum = values.reduce((acc, val) => acc + (typeof val === 'number' ? val : 0), 0);
        return sum / values.length;
    }

    private calculateVariance(values: Array<any>, average: number): number {
        if (values.length === 0) return 0.0;

        const squaredDiffs = values.map(val => {
            const numVal = typeof val === 'number' ? val : (val ? 1 : 0);
            return Math.pow(numVal - average, 2);
        });

        return squaredDiffs.reduce((acc, val) => acc + val, 0) / values.length;
    }

    private applyInvariance(featureName: string, value: any): any {
        // ØªØ·Ø¨ÙŠÙ‚ Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„ØªØ¬Ø§ÙˆØ²

        // ØªØ¬Ø§ÙˆØ² Ø§Ù„Ù…ÙˆÙ‚Ø¹
        if (this.settings.isInvarianceEnabled(InvarianceOption.POSITION)) {
            // ØªØ·Ø¨ÙŠØ¹ Ø§Ù„Ù…ÙˆÙ‚Ø¹ (Ø¥Ø²Ø§Ù„Ø© ØªØ£Ø«ÙŠØ± Ø§Ù„Ù…ÙˆÙ‚Ø¹)
            // ÙÙŠ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØŒ Ø³ÙŠØªÙ… ØªØ·Ø¨ÙŠØ¹ Ø§Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª
        }

        // ØªØ¬Ø§ÙˆØ² Ø§Ù„Ø­Ø¬Ù…
        if (this.settings.isInvarianceEnabled(InvarianceOption.SCALE)) {
            // ØªØ·Ø¨ÙŠØ¹ Ø§Ù„Ø­Ø¬Ù…
            if (featureName === "area" || featureName === "perimeter") {
                // ØªØ·Ø¨ÙŠØ¹ Ù†Ø³Ø¨ÙŠ
                return 1.0; // Ù‚ÙŠÙ…Ø© Ù…Ø·Ø¨Ø¹Ø©
            }
        }

        // ØªØ¬Ø§ÙˆØ² Ø§Ù„Ù„ÙˆÙ†
        if (this.settings.isInvarianceEnabled(InvarianceOption.COLOR)) {
            // ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ ØªØ¯Ø±Ø¬ Ø±Ù…Ø§Ø¯ÙŠ Ø£Ùˆ ØªØ¬Ø§Ù‡Ù„ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù„ÙˆÙ†
        }

        // ØªØ¬Ø§ÙˆØ² Ø§Ù„Ø¯ÙˆØ±Ø§Ù†
        if (this.settings.isInvarianceEnabled(InvarianceOption.ROTATION)) {
            // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…ÙŠØ²Ø§Øª ØºÙŠØ± Ø­Ø³Ø§Ø³Ø© Ù„Ù„Ø¯ÙˆØ±Ø§Ù†
        }

        // ØªØ¬Ø§ÙˆØ² Ø§Ù„Ø¥Ø¶Ø§Ø¡Ø©
        if (this.settings.isInvarianceEnabled(InvarianceOption.ILLUMINATION)) {
            // ØªØ·Ø¨ÙŠØ¹ Ø§Ù„Ø¥Ø¶Ø§Ø¡Ø©
        }

        return value;
    }

    private updateStatistics(result: ExtractionResult): void {
        const totalExtractions = this.statistics.get("totalExtractions")! + 1;
        this.statistics.set("totalExtractions", totalExtractions);

        if (result.overallConfidence > 0.5) {
            const successful = this.statistics.get("successfulExtractions")! + 1;
            this.statistics.set("successfulExtractions", successful);
        }

        // Ø­Ø³Ø§Ø¨ Ù…ØªÙˆØ³Ø· Ø§Ù„Ø«Ù‚Ø©
        const currentAvg = this.statistics.get("averageConfidence")!;
        const newAvg = (currentAvg * (totalExtractions - 1) + result.overallConfidence) / totalExtractions;
        this.statistics.set("averageConfidence", newAvg);
    }

    public getStatistics(): object {
        return {
            totalExtractions: this.statistics.get("totalExtractions"),
            totalImages: this.statistics.get("totalImages"),
            successfulExtractions: this.statistics.get("successfulExtractions"),
            averageConfidence: this.statistics.get("averageConfidence"),
            successRate: this.statistics.get("totalExtractions")! > 0
                ? this.statistics.get("successfulExtractions")! / this.statistics.get("totalExtractions")!
                : 0.0
        };
    }

    public getReport(): string {
        const stats = this.getStatistics();

        let report = "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
        report += "ØªÙ‚Ø±ÙŠØ± Ù…Ø³ØªØ®Ù„Øµ Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ù…Ø´ØªØ±ÙƒØ©\n";
        report += "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";

        report += `ğŸ“Š Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¹Ø§Ù…Ø©:\n`;
        report += `  - Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ø§Ø³ØªØ®Ù„Ø§Øµ: ${stats.totalExtractions}\n`;
        report += `  - Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ØµÙˆØ± Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©: ${stats.totalImages}\n`;
        report += `  - Ø§Ù„Ø§Ø³ØªØ®Ù„Ø§ØµØ§Øª Ø§Ù„Ù†Ø§Ø¬Ø­Ø©: ${stats.successfulExtractions}\n`;
        report += `  - Ù…Ø¹Ø¯Ù„ Ø§Ù„Ù†Ø¬Ø§Ø­: ${(stats.successRate * 100).toFixed(1)}%\n`;
        report += `  - Ù…ØªÙˆØ³Ø· Ø§Ù„Ø«Ù‚Ø©: ${(stats.averageConfidence * 100).toFixed(1)}%\n\n`;

        report += `âš™ï¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ©:\n`;
        report += `  - Ù†Ø³Ø¨Ø© Ø§Ù„Ø³Ù…Ø§Ø­: ${(this.settings.toleranceRate * 100).toFixed(1)}%\n`;
        report += `  - Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ù„Ø¸Ù‡ÙˆØ±: ${(this.settings.minOccurrenceRate * 100).toFixed(1)}%\n`;
        report += `  - Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„ØªØ¬Ø§ÙˆØ²: ${this.settings.invarianceOptions.size}\n`;
        report += `  - Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ù…ÙŠØ²Ø§Øª: ${this.settings.featureTypes.size}\n\n`;

        report += `ğŸ“‹ Ø¢Ø®Ø± ${Math.min(5, this.results.length)} Ù†ØªØ§Ø¦Ø¬:\n`;
        this.results.slice(-5).forEach((result, index) => {
            report += `  ${index + 1}. ${result.resultId}: ${result.commonFeatures.length} Ù…ÙŠØ²Ø© Ù…Ø´ØªØ±ÙƒØ© (${(result.overallConfidence * 100).toFixed(1)}%)\n`;
        });

        report += "\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";

        return report;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ø§Ù„ØªØµØ¯ÙŠØ±
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export {
    ImageCommonFeaturesExtractor,
    InputImage,
    CommonFeature,
    ExtractionSettings,
    ExtractionResult,
    InvarianceOption,
    FeatureType,
    ConfidenceLevel
};

