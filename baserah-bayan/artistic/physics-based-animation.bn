// ============================================================================
// physics-based-animation.bn
// نظام التحريك القائم على الفيزياء
// 
// هذا النظام يوفر محاكاة فيزيائية واقعية للحركة بناءً على:
// - الجاذبية (Gravity)
// - التسارع (Acceleration)
// - الاحتكاك (Friction)
// - التصادم (Collision)
// - القوى (Forces)
// 
// يتكامل مع الطبقة الفيزيائية من نواة التفكير
// ============================================================================

import { MotherEquation } from "../core/mother-equation.bn";
import { PhysicalThinkingLayer } from "../thinking/physical-thinking-layer.bn";

// ============================================================================
// التعدادات (Enums)
// ============================================================================

enum ForceType {
    GRAVITY = "gravity",
    FRICTION = "friction",
    DRAG = "drag",
    SPRING = "spring",
    MAGNETIC = "magnetic",
    CUSTOM = "custom"
}

enum CollisionType {
    ELASTIC = "elastic",           // تصادم مرن (يحفظ الطاقة)
    INELASTIC = "inelastic",       // تصادم غير مرن
    PERFECTLY_INELASTIC = "perfectly_inelastic", // تصادم غير مرن تماماً
    NONE = "none"
}

enum PhysicsState {
    STATIC = "static",             // ثابت (لا يتحرك)
    DYNAMIC = "dynamic",           // ديناميكي (يتحرك)
    KINEMATIC = "kinematic",       // حركي (يتحرك بدون تأثر بالقوى)
    SLEEPING = "sleeping"          // نائم (موفر للطاقة)
}

enum MaterialType {
    RUBBER = "rubber",             // مطاط (احتكاك عالي، مرونة عالية)
    METAL = "metal",               // معدن (احتكاك منخفض، مرونة منخفضة)
    WOOD = "wood",                 // خشب (احتكاك متوسط، مرونة متوسطة)
    ICE = "ice",                   // جليد (احتكاك منخفض جداً)
    STONE = "stone",               // حجر (احتكاك عالي، مرونة منخفضة)
    CUSTOM = "custom"
}

// ============================================================================
// Vector2D - متجه ثنائي الأبعاد
// ============================================================================

class Vector2D extends MotherEquation {
    public x: number;
    public y: number;

    constructor(x: number, y: number) {
        super("vector2d_" + Math.random().toString(36).substr(2, 9));
        
        this.x = x;
        this.y = y;

        // Φ: الخصائص الثابتة
        this.fixedProperties = {
            dimensions: 2,
            type: "vector"
        };

        // Ψ: الحالات الديناميكية
        this.dynamicStates = {
            x: x,
            y: y,
            magnitude: this.getMagnitude(),
            angle: this.getAngle()
        };
    }

    // الحصول على الطول (المقدار)
    public getMagnitude(): number {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }

    // الحصول على الزاوية
    public getAngle(): number {
        return Math.atan2(this.y, this.x);
    }

    // الجمع
    public add(other: Vector2D): Vector2D {
        return new Vector2D(this.x + other.x, this.y + other.y);
    }

    // الطرح
    public subtract(other: Vector2D): Vector2D {
        return new Vector2D(this.x - other.x, this.y - other.y);
    }

    // الضرب في عدد
    public multiply(scalar: number): Vector2D {
        return new Vector2D(this.x * scalar, this.y * scalar);
    }

    // القسمة على عدد
    public divide(scalar: number): Vector2D {
        if (scalar === 0) return new Vector2D(0, 0);
        return new Vector2D(this.x / scalar, this.y / scalar);
    }

    // التطبيع (جعل الطول = 1)
    public normalize(): Vector2D {
        let mag = this.getMagnitude();
        if (mag === 0) return new Vector2D(0, 0);
        return this.divide(mag);
    }

    // الضرب النقطي
    public dot(other: Vector2D): number {
        return this.x * other.x + this.y * other.y;
    }

    // نسخ
    public clone(): Vector2D {
        return new Vector2D(this.x, this.y);
    }
}

// ============================================================================
// PhysicsForce - قوة فيزيائية
// ============================================================================

class PhysicsForce extends MotherEquation {
    public forceId: string;
    public forceType: ForceType;
    public vector: Vector2D;
    public magnitude: number;
    public direction: number;
    public isActive: boolean;

    constructor(forceId: string, forceType: ForceType, vector: Vector2D) {
        super(forceId);
        
        this.forceId = forceId;
        this.forceType = forceType;
        this.vector = vector;
        this.magnitude = vector.getMagnitude();
        this.direction = vector.getAngle();
        this.isActive = true;

        // Φ: الخصائص الثابتة
        this.fixedProperties = {
            forceType: forceType,
            createdAt: Date.now()
        };

        // Ψ: الحالات الديناميكية
        this.dynamicStates = {
            vector: vector,
            magnitude: this.magnitude,
            direction: this.direction,
            isActive: this.isActive
        };
    }

    // تطبيق القوة
    public apply(mass: number, deltaTime: number): Vector2D {
        if (!this.isActive) return new Vector2D(0, 0);
        
        // F = ma => a = F/m
        let acceleration = this.vector.divide(mass);
        
        // v = a * t
        return acceleration.multiply(deltaTime);
    }
}

// ============================================================================
// PhysicsMaterial - مادة فيزيائية
// ============================================================================

class PhysicsMaterial extends MotherEquation {
    public materialId: string;
    public materialType: MaterialType;
    public density: number;          // الكثافة (kg/m³)
    public friction: number;         // معامل الاحتكاك (0-1)
    public restitution: number;      // معامل المرونة (0-1)
    public drag: number;             // مقاومة الهواء (0-1)

    constructor(materialId: string, materialType: MaterialType) {
        super(materialId);
        
        this.materialId = materialId;
        this.materialType = materialType;

        // تعيين الخصائص حسب نوع المادة
        switch (materialType) {
            case MaterialType.RUBBER:
                this.density = 1100;
                this.friction = 0.9;
                this.restitution = 0.8;
                this.drag = 0.3;
                break;
            case MaterialType.METAL:
                this.density = 7800;
                this.friction = 0.3;
                this.restitution = 0.2;
                this.drag = 0.1;
                break;
            case MaterialType.WOOD:
                this.density = 600;
                this.friction = 0.6;
                this.restitution = 0.4;
                this.drag = 0.2;
                break;
            case MaterialType.ICE:
                this.density = 917;
                this.friction = 0.05;
                this.restitution = 0.1;
                this.drag = 0.05;
                break;
            case MaterialType.STONE:
                this.density = 2500;
                this.friction = 0.8;
                this.restitution = 0.1;
                this.drag = 0.15;
                break;
            default:
                this.density = 1000;
                this.friction = 0.5;
                this.restitution = 0.5;
                this.drag = 0.2;
        }

        // Φ: الخصائص الثابتة
        this.fixedProperties = {
            materialType: materialType,
            density: this.density
        };

        // Ψ: الحالات الديناميكية
        this.dynamicStates = {
            friction: this.friction,
            restitution: this.restitution,
            drag: this.drag
        };
    }
}

// ============================================================================
// PhysicsBody - جسم فيزيائي
// ============================================================================

class PhysicsBody extends MotherEquation {
    public bodyId: string;
    public position: Vector2D;
    public velocity: Vector2D;
    public acceleration: Vector2D;
    public mass: number;
    public material: PhysicsMaterial;
    public state: PhysicsState;
    public forces: array<PhysicsForce>;
    public rotation: number;
    public angularVelocity: number;
    public width: number;
    public height: number;

    constructor(bodyId: string, position: Vector2D, mass: number, material: PhysicsMaterial) {
        super(bodyId);
        
        this.bodyId = bodyId;
        this.position = position;
        this.velocity = new Vector2D(0, 0);
        this.acceleration = new Vector2D(0, 0);
        this.mass = mass;
        this.material = material;
        this.state = PhysicsState.DYNAMIC;
        this.forces = [];
        this.rotation = 0;
        this.angularVelocity = 0;
        this.width = 50;
        this.height = 50;

        // Φ: الخصائص الثابتة
        this.fixedProperties = {
            bodyId: bodyId,
            mass: mass,
            material: material
        };

        // Ψ: الحالات الديناميكية
        this.dynamicStates = {
            position: position,
            velocity: this.velocity,
            acceleration: this.acceleration,
            rotation: this.rotation,
            state: this.state
        };
    }

    // إضافة قوة
    public addForce(force: PhysicsForce): void {
        this.forces.push(force);
    }

    // مسح جميع القوى
    public clearForces(): void {
        this.forces = [];
    }

    // تحديث الفيزياء
    public update(deltaTime: number): void {
        if (this.state !== PhysicsState.DYNAMIC) return;

        // حساب التسارع من جميع القوى
        this.acceleration = new Vector2D(0, 0);
        
        for (let i = 0; i < this.forces.length; i++) {
            let force = this.forces[i];
            let velocityChange = force.apply(this.mass, deltaTime);
            this.acceleration = this.acceleration.add(velocityChange.divide(deltaTime));
        }

        // تطبيق مقاومة الهواء
        let dragForce = this.velocity.multiply(-this.material.drag);
        this.acceleration = this.acceleration.add(dragForce);

        // تحديث السرعة
        this.velocity = this.velocity.add(this.acceleration.multiply(deltaTime));

        // تحديث الموقع
        this.position = this.position.add(this.velocity.multiply(deltaTime));

        // تحديث الدوران
        this.rotation += this.angularVelocity * deltaTime;

        // تحديث الحالات الديناميكية
        this.dynamicStates.position = this.position;
        this.dynamicStates.velocity = this.velocity;
        this.dynamicStates.acceleration = this.acceleration;
        this.dynamicStates.rotation = this.rotation;
    }
}

// ============================================================================
// CollisionDetector - كاشف التصادم
// ============================================================================

class CollisionDetector extends MotherEquation {
    public detectorId: string;

    constructor(detectorId: string) {
        super(detectorId);
        this.detectorId = detectorId;

        // Φ: الخصائص الثابتة
        this.fixedProperties = {
            detectorType: "AABB" // Axis-Aligned Bounding Box
        };

        // Ψ: الحالات الديناميكية
        this.dynamicStates = {
            lastCheck: Date.now(),
            collisionsDetected: 0
        };
    }

    // فحص التصادم بين جسمين (AABB)
    public checkCollision(body1: PhysicsBody, body2: PhysicsBody): boolean {
        let left1 = body1.position.x - body1.width / 2;
        let right1 = body1.position.x + body1.width / 2;
        let top1 = body1.position.y - body1.height / 2;
        let bottom1 = body1.position.y + body1.height / 2;

        let left2 = body2.position.x - body2.width / 2;
        let right2 = body2.position.x + body2.width / 2;
        let top2 = body2.position.y - body2.height / 2;
        let bottom2 = body2.position.y + body2.height / 2;

        return !(right1 < left2 || left1 > right2 || bottom1 < top2 || top1 > bottom2);
    }

    // حل التصادم
    public resolveCollision(body1: PhysicsBody, body2: PhysicsBody, collisionType: CollisionType): void {
        if (!this.checkCollision(body1, body2)) return;

        // حساب المتجه الطبيعي للتصادم
        let normal = body2.position.subtract(body1.position).normalize();

        // السرعة النسبية
        let relativeVelocity = body1.velocity.subtract(body2.velocity);

        // السرعة على طول المتجه الطبيعي
        let velocityAlongNormal = relativeVelocity.dot(normal);

        // لا تحل إذا كانت الأجسام تتباعد
        if (velocityAlongNormal > 0) return;

        // معامل المرونة (متوسط المادتين)
        let restitution = (body1.material.restitution + body2.material.restitution) / 2;

        if (collisionType === CollisionType.PERFECTLY_INELASTIC) {
            restitution = 0;
        } else if (collisionType === CollisionType.INELASTIC) {
            restitution *= 0.5;
        }

        // حساب الدفع (Impulse)
        let j = -(1 + restitution) * velocityAlongNormal;
        j /= (1 / body1.mass) + (1 / body2.mass);

        // تطبيق الدفع
        let impulse = normal.multiply(j);

        if (body1.state === PhysicsState.DYNAMIC) {
            body1.velocity = body1.velocity.add(impulse.divide(body1.mass));
        }

        if (body2.state === PhysicsState.DYNAMIC) {
            body2.velocity = body2.velocity.subtract(impulse.divide(body2.mass));
        }

        // فصل الأجسام المتداخلة
        this.separateBodies(body1, body2);

        this.dynamicStates.collisionsDetected++;
    }

    // فصل الأجسام المتداخلة
    private separateBodies(body1: PhysicsBody, body2: PhysicsBody): void {
        let overlap = this.calculateOverlap(body1, body2);
        if (overlap <= 0) return;

        let direction = body2.position.subtract(body1.position).normalize();
        let separation = direction.multiply(overlap / 2);

        if (body1.state === PhysicsState.DYNAMIC) {
            body1.position = body1.position.subtract(separation);
        }

        if (body2.state === PhysicsState.DYNAMIC) {
            body2.position = body2.position.add(separation);
        }
    }

    // حساب مقدار التداخل
    private calculateOverlap(body1: PhysicsBody, body2: PhysicsBody): number {
        let dx = Math.abs(body2.position.x - body1.position.x);
        let dy = Math.abs(body2.position.y - body1.position.y);

        let overlapX = (body1.width + body2.width) / 2 - dx;
        let overlapY = (body1.height + body2.height) / 2 - dy;

        return Math.min(overlapX, overlapY);
    }
}

// ============================================================================
// PhysicsWorld - العالم الفيزيائي
// ============================================================================

class PhysicsWorld extends MotherEquation {
    public worldId: string;
    public bodies: array<PhysicsBody>;
    public gravity: Vector2D;
    public collisionDetector: CollisionDetector;
    public physicalThinkingLayer: PhysicalThinkingLayer;
    public timeScale: number;
    public bounds: object;

    constructor(worldId: string, gravity: Vector2D) {
        super(worldId);

        this.worldId = worldId;
        this.bodies = [];
        this.gravity = gravity;
        this.collisionDetector = new CollisionDetector("collision_detector");
        this.physicalThinkingLayer = null; // سيتم ربطه لاحقاً
        this.timeScale = 1.0;
        this.bounds = {
            minX: -1000,
            maxX: 1000,
            minY: -1000,
            maxY: 1000
        };

        // Φ: الخصائص الثابتة
        this.fixedProperties = {
            worldId: worldId,
            createdAt: Date.now()
        };

        // Ψ: الحالات الديناميكية
        this.dynamicStates = {
            gravity: gravity,
            bodyCount: 0,
            timeScale: this.timeScale,
            simulationTime: 0
        };
    }

    // ربط طبقة التفكير الفيزيائية
    public connectPhysicalThinkingLayer(layer: PhysicalThinkingLayer): void {
        this.physicalThinkingLayer = layer;
    }

    // إضافة جسم
    public addBody(body: PhysicsBody): void {
        this.bodies.push(body);
        this.dynamicStates.bodyCount = this.bodies.length;
    }

    // إزالة جسم
    public removeBody(bodyId: string): void {
        this.bodies = this.bodies.filter(b => b.bodyId !== bodyId);
        this.dynamicStates.bodyCount = this.bodies.length;
    }

    // تطبيق الجاذبية على جميع الأجسام
    public applyGravity(): void {
        for (let i = 0; i < this.bodies.length; i++) {
            let body = this.bodies[i];
            if (body.state === PhysicsState.DYNAMIC) {
                let gravityForce = new PhysicsForce(
                    "gravity_" + body.bodyId,
                    ForceType.GRAVITY,
                    this.gravity.multiply(body.mass)
                );
                body.addForce(gravityForce);
            }
        }
    }

    // تحديث العالم
    public step(deltaTime: number): void {
        let scaledDeltaTime = deltaTime * this.timeScale;

        // استشارة طبقة التفكير الفيزيائية إذا كانت متصلة
        if (this.physicalThinkingLayer) {
            let physicsAdvice = this.physicalThinkingLayer.analyzePhysicalScenario({
                bodies: this.bodies,
                gravity: this.gravity,
                deltaTime: scaledDeltaTime
            });

            // تطبيق النصائح الفيزيائية
            if (physicsAdvice.adjustGravity) {
                this.gravity = physicsAdvice.suggestedGravity;
            }
        }

        // تطبيق الجاذبية
        this.applyGravity();

        // تحديث جميع الأجسام
        for (let i = 0; i < this.bodies.length; i++) {
            this.bodies[i].update(scaledDeltaTime);
            this.bodies[i].clearForces();
        }

        // فحص التصادمات
        for (let i = 0; i < this.bodies.length; i++) {
            for (let j = i + 1; j < this.bodies.length; j++) {
                this.collisionDetector.resolveCollision(
                    this.bodies[i],
                    this.bodies[j],
                    CollisionType.ELASTIC
                );
            }
        }

        // تطبيق الحدود
        this.applyBounds();

        this.dynamicStates.simulationTime += scaledDeltaTime;
    }

    // تطبيق حدود العالم
    private applyBounds(): void {
        for (let i = 0; i < this.bodies.length; i++) {
            let body = this.bodies[i];

            // الحد الأيسر
            if (body.position.x - body.width / 2 < this.bounds.minX) {
                body.position.x = this.bounds.minX + body.width / 2;
                body.velocity.x *= -body.material.restitution;
            }

            // الحد الأيمن
            if (body.position.x + body.width / 2 > this.bounds.maxX) {
                body.position.x = this.bounds.maxX - body.width / 2;
                body.velocity.x *= -body.material.restitution;
            }

            // الحد العلوي
            if (body.position.y - body.height / 2 < this.bounds.minY) {
                body.position.y = this.bounds.minY + body.height / 2;
                body.velocity.y *= -body.material.restitution;
            }

            // الحد السفلي
            if (body.position.y + body.height / 2 > this.bounds.maxY) {
                body.position.y = this.bounds.maxY - body.height / 2;
                body.velocity.y *= -body.material.restitution;
            }
        }
    }

    // الحصول على إحصائيات
    public getStatistics(): object {
        return {
            bodyCount: this.bodies.length,
            simulationTime: this.dynamicStates.simulationTime,
            collisionsDetected: this.collisionDetector.dynamicStates.collisionsDetected,
            gravity: this.gravity,
            timeScale: this.timeScale
        };
    }
}

export {
    Vector2D,
    PhysicsForce,
    PhysicsMaterial,
    PhysicsBody,
    CollisionDetector,
    PhysicsWorld,
    ForceType,
    CollisionType,
    PhysicsState,
    MaterialType
};

