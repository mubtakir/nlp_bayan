/**
 * محرك الاستنباط بالسيغمويد - Sigmoid Inference Engine
 * ═══════════════════════════════════════════════════════════════
 * 
 * الوصف: محرك متقدم لاستنباط معادلات الأشكال من البيانات
 * الهدف: تحويل البيانات (نقاط، صور) إلى معادلات سيغمويد
 * المنهجية: استخراج ميزات + تحسين معاملات + توجيه الخبير
 * 
 * المطور: بصيرة AI
 * التاريخ: 2025-10-26
 */

import { MotherEquation } from "../core/mother-equation.bn";
import { SigmoidShapeEquation, SigmoidTerm, LinearComponent } from "./sigmoid-shape-equation.bn";

// ═══════════════════════════════════════════════════════════════
// نتيجة استخراج الميزات
// ═══════════════════════════════════════════════════════════════

class ExtractedFeatures {
    // الميزات الهندسية
    curvature: number;          // الانحناء المتوسط
    symmetry: number;           // درجة التماثل (0-1)
    periodicity: number;        // درجة الدورية (0-1)
    complexity: number;         // درجة التعقيد
    
    // الميزات الإحصائية
    zeroCrossings: number;      // عدد تقاطعات الصفر
    extremaCount: number;       // عدد النقاط القصوى
    inflectionPoints: number;   // عدد نقاط الانعطاف
    variance: number;           // التباين
    
    // الميزات الشكلية
    aspectRatio: number;        // نسبة الطول/العرض
    isClosed: boolean;          // هل الشكل مغلق؟
    radiality: number;          // الشعاعية (0-1)
    compactness: number;        // الاستطالة (0-1)
    
    // الميزات المتقدمة
    entropy: number;            // الانتروبيا
    area: number;               // المساحة
    perimeter: number;          // المحيط
    
    constructor() {
        this.curvature = 0.0;
        this.symmetry = 0.5;
        this.periodicity = 0.0;
        this.complexity = 1.0;
        this.zeroCrossings = 0;
        this.extremaCount = 0;
        this.inflectionPoints = 0;
        this.variance = 0.0;
        this.aspectRatio = 1.0;
        this.isClosed = false;
        this.radiality = 0.0;
        this.compactness = 0.5;
        this.entropy = 0.0;
        this.area = 0.0;
        this.perimeter = 0.0;
    }
}

// ═══════════════════════════════════════════════════════════════
// نتيجة الاستنباط
// ═══════════════════════════════════════════════════════════════

class InferenceResult {
    equation: SigmoidShapeEquation;     // المعادلة المستنبطة
    features: ExtractedFeatures;        // الميزات المستخرجة
    confidence: number;                 // درجة الثقة (0-1)
    qualityMetrics: object;             // مقاييس الجودة
    reasoning: string;                  // التفسير
    timestamp: number;                  // الوقت
    
    constructor(equation: SigmoidShapeEquation) {
        this.equation = equation;
        this.features = new ExtractedFeatures();
        this.confidence = 0.5;
        this.qualityMetrics = {
            rSquared: 0.0,
            residualError: 0.0,
            convergence: 0.0
        };
        this.reasoning = "";
        this.timestamp = Date.now();
    }
}

// ═══════════════════════════════════════════════════════════════
// محرك الاستنباط بالسيغمويد
// ═══════════════════════════════════════════════════════════════

class SigmoidInferenceEngine {
    engineId: string;
    maxIterations: number;              // أقصى عدد تكرارات التحسين
    convergenceThreshold: number;       // عتبة التقارب
    learningRate: number;               // معدل التعلم
    
    // إحصائيات
    stats: object;
    
    constructor(engineId: string) {
        this.engineId = engineId;
        this.maxIterations = 1000;
        this.convergenceThreshold = 1e-6;
        this.learningRate = 0.01;
        
        this.stats = {
            totalInferences: 0,
            successfulInferences: 0,
            averageConfidence: 0.0,
            averageIterations: 0
        };
    }
    
    // ═══════════════════════════════════════════════════════════════
    // استنباط المعادلة من نقاط البيانات
    // ═══════════════════════════════════════════════════════════════
    
    function inferFromPoints(xData: number[], yData: number[]): InferenceResult {
        // التحقق من البيانات
        if (xData.length !== yData.length || xData.length < 3) {
            console.log("❌ بيانات غير كافية للاستنباط");
            return this.createEmptyResult();
        }
        
        // إنشاء معادلة جديدة
        let equation = new SigmoidShapeEquation(
            this.engineId + "_inferred",
            "Inferred Shape"
        );
        
        // الخطوة 1: استخراج الميزات
        let features = this.extractFeatures(xData, yData);
        
        // الخطوة 2: تحديد عدد الحدود المطلوبة
        let numTerms = this.determineNumberOfTerms(features);
        
        // الخطوة 3: استخراج المكون الخطي
        let linearParams = this.extractLinearComponent(xData, yData);
        equation.setLinearComponent(linearParams.slope, linearParams.intercept);
        
        // الخطوة 4: استخراج حدود السيغمويد
        for (let i = 0; i < numTerms; i++) {
            let sigmoidParams = this.extractSigmoidTerm(xData, yData, i, numTerms);
            equation.addSigmoidTerm(
                sigmoidParams.scale,
                sigmoidParams.sharpness,
                sigmoidParams.center,
                sigmoidParams.cutoff,
                sigmoidParams.weight,
                `Inferred term ${i + 1}`
            );
        }
        
        // الخطوة 5: تحسين المعاملات
        this.optimizeParameters(equation, xData, yData);
        
        // الخطوة 6: حساب مقاييس الجودة
        let qualityMetrics = this.calculateQualityMetrics(equation, xData, yData);
        
        // الخطوة 7: حساب الثقة
        let confidence = this.calculateConfidence(features, qualityMetrics);
        
        // إنشاء النتيجة
        let result = new InferenceResult(equation);
        result.features = features;
        result.confidence = confidence;
        result.qualityMetrics = qualityMetrics;
        result.reasoning = this.generateReasoning(features, numTerms, confidence);
        
        // تحديث الإحصائيات
        this.updateStats(result);
        
        return result;
    }
    
    // ═══════════════════════════════════════════════════════════════
    // استخراج الميزات من البيانات
    // ═══════════════════════════════════════════════════════════════
    
    function extractFeatures(xData: number[], yData: number[]): ExtractedFeatures {
        let features = new ExtractedFeatures();
        
        // حساب الانحناء
        features.curvature = this.computeCurvature(xData, yData);
        
        // حساب التماثل
        features.symmetry = this.computeSymmetry(xData, yData);
        
        // حساب الدورية
        features.periodicity = this.computePeriodicity(xData, yData);
        
        // حساب التعقيد
        features.complexity = this.computeComplexity(xData, yData);
        
        // عد تقاطعات الصفر
        features.zeroCrossings = this.countZeroCrossings(yData);
        
        // عد النقاط القصوى
        features.extremaCount = this.countExtrema(yData);
        
        // عد نقاط الانعطاف
        features.inflectionPoints = this.countInflectionPoints(xData, yData);
        
        // حساب التباين
        features.variance = this.computeVariance(yData);
        
        // حساب نسبة الطول/العرض
        features.aspectRatio = this.computeAspectRatio(xData, yData);
        
        // التحقق من الإغلاق
        features.isClosed = this.isClosedCurve(xData, yData);
        
        // حساب الشعاعية
        features.radiality = this.computeRadiality(xData, yData);
        
        // حساب الاستطالة
        features.compactness = this.computeCompactness(xData, yData);
        
        // حساب الانتروبيا
        features.entropy = this.computeEntropy(yData);
        
        return features;
    }
    
    // ═══════════════════════════════════════════════════════════════
    // حساب الانحناء المتوسط
    // ═══════════════════════════════════════════════════════════════
    
    function computeCurvature(xData: number[], yData: number[]): number {
        if (xData.length < 3) return 0.0;
        
        let totalCurvature = 0.0;
        let count = 0;
        
        for (let i = 1; i < xData.length - 1; i++) {
            let dx1 = xData[i] - xData[i - 1];
            let dy1 = yData[i] - yData[i - 1];
            let dx2 = xData[i + 1] - xData[i];
            let dy2 = yData[i + 1] - yData[i];
            
            let numerator = Math.abs(dx1 * dy2 - dy1 * dx2);
            let denominator = Math.pow(dx1 * dx1 + dy1 * dy1, 1.5) + 1e-10;
            
            totalCurvature += numerator / denominator;
            count++;
        }
        
        return count > 0 ? totalCurvature / count : 0.0;
    }
    
    // ═══════════════════════════════════════════════════════════════
    // حساب التماثل
    // ═══════════════════════════════════════════════════════════════
    
    function computeSymmetry(xData: number[], yData: number[]): number {
        // حساب المركز
        let centerX = xData.reduce((a, b) => a + b, 0) / xData.length;
        let centerY = yData.reduce((a, b) => a + b, 0) / yData.length;
        
        // حساب المسافات من المركز
        let distances = [];
        for (let i = 0; i < xData.length; i++) {
            let dx = xData[i] - centerX;
            let dy = yData[i] - centerY;
            distances.push(Math.sqrt(dx * dx + dy * dy));
        }
        
        // حساب المتوسط والانحراف المعياري
        let mean = distances.reduce((a, b) => a + b, 0) / distances.length;
        let variance = distances.reduce((a, b) => a + (b - mean) * (b - mean), 0) / distances.length;
        let std = Math.sqrt(variance);
        
        // التماثل = 1 - (الانحراف المعياري / المتوسط)
        let symmetry = 1.0 - (std / (mean + 1e-10));
        
        return Math.max(0.0, Math.min(1.0, symmetry));
    }
    
    // ═══════════════════════════════════════════════════════════════
    // حساب الدورية (باستخدام FFT مبسط)
    // ═══════════════════════════════════════════════════════════════
    
    function computePeriodicity(xData: number[], yData: number[]): number {
        // حساب المشتقة الثانية
        let d2y = [];
        for (let i = 1; i < yData.length - 1; i++) {
            d2y.push(yData[i + 1] - 2 * yData[i] + yData[i - 1]);
        }
        
        // البحث عن الأنماط المتكررة
        let peaks = 0;
        for (let i = 1; i < d2y.length - 1; i++) {
            if (d2y[i] > d2y[i - 1] && d2y[i] > d2y[i + 1]) {
                peaks++;
            }
        }
        
        // الدورية = عدد القمم / الطول
        let periodicity = peaks / (d2y.length + 1e-10);
        
        return Math.min(1.0, periodicity * 5);
    }

    // ═══════════════════════════════════════════════════════════════
    // حساب التعقيد
    // ═══════════════════════════════════════════════════════════════

    function computeComplexity(xData: number[], yData: number[]): number {
        let angleChanges = 0;

        for (let i = 1; i < xData.length - 1; i++) {
            let dx1 = xData[i] - xData[i - 1];
            let dy1 = yData[i] - yData[i - 1];
            let dx2 = xData[i + 1] - xData[i];
            let dy2 = yData[i + 1] - yData[i];

            let angle1 = Math.atan2(dy1, dx1);
            let angle2 = Math.atan2(dy2, dx2);

            if (Math.abs(angle2 - angle1) > 0.1) {
                angleChanges++;
            }
        }

        let totalLength = 0;
        for (let i = 0; i < xData.length - 1; i++) {
            let dx = xData[i + 1] - xData[i];
            let dy = yData[i + 1] - yData[i];
            totalLength += Math.sqrt(dx * dx + dy * dy);
        }

        return angleChanges / (totalLength + 1e-10);
    }

    // ═══════════════════════════════════════════════════════════════
    // عد تقاطعات الصفر
    // ═══════════════════════════════════════════════════════════════

    function countZeroCrossings(yData: number[]): number {
        let mean = yData.reduce((a, b) => a + b, 0) / yData.length;
        let crossings = 0;

        for (let i = 0; i < yData.length - 1; i++) {
            if ((yData[i] - mean) * (yData[i + 1] - mean) < 0) {
                crossings++;
            }
        }

        return crossings;
    }

    // ═══════════════════════════════════════════════════════════════
    // عد النقاط القصوى
    // ═══════════════════════════════════════════════════════════════

    function countExtrema(yData: number[]): number {
        let extrema = 0;

        for (let i = 1; i < yData.length - 1; i++) {
            if ((yData[i] > yData[i - 1] && yData[i] > yData[i + 1]) ||
                (yData[i] < yData[i - 1] && yData[i] < yData[i + 1])) {
                extrema++;
            }
        }

        return extrema;
    }

    // ═══════════════════════════════════════════════════════════════
    // عد نقاط الانعطاف
    // ═══════════════════════════════════════════════════════════════

    function countInflectionPoints(xData: number[], yData: number[]): number {
        if (yData.length < 3) return 0;

        let d2y = [];
        for (let i = 1; i < yData.length - 1; i++) {
            d2y.push(yData[i + 1] - 2 * yData[i] + yData[i - 1]);
        }

        let inflections = 0;
        for (let i = 0; i < d2y.length - 1; i++) {
            if (d2y[i] * d2y[i + 1] < 0) {
                inflections++;
            }
        }

        return inflections;
    }

    // ═══════════════════════════════════════════════════════════════
    // حساب التباين
    // ═══════════════════════════════════════════════════════════════

    function computeVariance(yData: number[]): number {
        let mean = yData.reduce((a, b) => a + b, 0) / yData.length;
        let variance = yData.reduce((a, b) => a + (b - mean) * (b - mean), 0) / yData.length;
        return variance;
    }

    // ═══════════════════════════════════════════════════════════════
    // حساب نسبة الطول/العرض
    // ═══════════════════════════════════════════════════════════════

    function computeAspectRatio(xData: number[], yData: number[]): number {
        let minX = Math.min(...xData);
        let maxX = Math.max(...xData);
        let minY = Math.min(...yData);
        let maxY = Math.max(...yData);

        let width = maxX - minX;
        let height = maxY - minY;

        return width / (height + 1e-10);
    }

    // ═══════════════════════════════════════════════════════════════
    // التحقق من الإغلاق
    // ═══════════════════════════════════════════════════════════════

    function isClosedCurve(xData: number[], yData: number[]): boolean {
        if (xData.length < 3) return false;

        let dx = xData[0] - xData[xData.length - 1];
        let dy = yData[0] - yData[yData.length - 1];
        let distance = Math.sqrt(dx * dx + dy * dy);

        return distance < 0.1;
    }

    // ═══════════════════════════════════════════════════════════════
    // حساب الشعاعية
    // ═══════════════════════════════════════════════════════════════

    function computeRadiality(xData: number[], yData: number[]): number {
        let centerX = xData.reduce((a, b) => a + b, 0) / xData.length;
        let centerY = yData.reduce((a, b) => a + b, 0) / yData.length;

        let angles = [];
        for (let i = 0; i < xData.length; i++) {
            let angle = Math.atan2(yData[i] - centerY, xData[i] - centerX);
            angles.push(angle);
        }

        // التحقق من التوزيع المنتظم للزوايا
        angles.sort((a, b) => a - b);
        let angleDiffs = [];
        for (let i = 0; i < angles.length - 1; i++) {
            angleDiffs.push(angles[i + 1] - angles[i]);
        }

        let meanDiff = angleDiffs.reduce((a, b) => a + b, 0) / angleDiffs.length;
        let variance = angleDiffs.reduce((a, b) => a + (b - meanDiff) * (b - meanDiff), 0) / angleDiffs.length;

        let radiality = 1.0 - Math.sqrt(variance) / (Math.PI + 1e-10);

        return Math.max(0.0, Math.min(1.0, radiality));
    }

    // ═══════════════════════════════════════════════════════════════
    // حساب الاستطالة
    // ═══════════════════════════════════════════════════════════════

    function computeCompactness(xData: number[], yData: number[]): number {
        // حساب المساحة التقريبية
        let area = 0;
        for (let i = 0; i < xData.length - 1; i++) {
            area += (xData[i] * yData[i + 1] - xData[i + 1] * yData[i]);
        }
        area = Math.abs(area) / 2;

        // حساب المحيط
        let perimeter = 0;
        for (let i = 0; i < xData.length - 1; i++) {
            let dx = xData[i + 1] - xData[i];
            let dy = yData[i + 1] - yData[i];
            perimeter += Math.sqrt(dx * dx + dy * dy);
        }

        // الاستطالة = 4π × المساحة / المحيط²
        let compactness = (4 * Math.PI * area) / (perimeter * perimeter + 1e-10);

        return Math.max(0.0, Math.min(1.0, compactness));
    }

    // ═══════════════════════════════════════════════════════════════
    // حساب الانتروبيا
    // ═══════════════════════════════════════════════════════════════

    function computeEntropy(yData: number[]): number {
        // تقسيم البيانات إلى bins
        let numBins = 10;
        let minY = Math.min(...yData);
        let maxY = Math.max(...yData);
        let binWidth = (maxY - minY) / numBins;

        let bins = new Array(numBins).fill(0);
        for (let i = 0; i < yData.length; i++) {
            let binIndex = Math.floor((yData[i] - minY) / (binWidth + 1e-10));
            binIndex = Math.max(0, Math.min(numBins - 1, binIndex));
            bins[binIndex]++;
        }

        // حساب الانتروبيا
        let entropy = 0;
        for (let i = 0; i < bins.length; i++) {
            if (bins[i] > 0) {
                let p = bins[i] / yData.length;
                entropy -= p * Math.log2(p);
            }
        }

        return entropy;
    }

    // ═══════════════════════════════════════════════════════════════
    // تحديد عدد الحدود المطلوبة
    // ═══════════════════════════════════════════════════════════════

    function determineNumberOfTerms(features: ExtractedFeatures): number {
        // بناءً على التعقيد والنقاط القصوى
        let baseTerms = Math.ceil(features.complexity * 3);
        let extremaTerms = Math.ceil(features.extremaCount / 2);

        let numTerms = Math.max(baseTerms, extremaTerms);
        numTerms = Math.max(1, Math.min(10, numTerms)); // بين 1 و 10

        return numTerms;
    }

    // ═══════════════════════════════════════════════════════════════
    // استخراج المكون الخطي
    // ═══════════════════════════════════════════════════════════════

    function extractLinearComponent(xData: number[], yData: number[]): object {
        // حساب الانحدار الخطي بطريقة المربعات الصغرى
        let n = xData.length;
        let sumX = xData.reduce((a, b) => a + b, 0);
        let sumY = yData.reduce((a, b) => a + b, 0);
        let sumXY = 0;
        let sumX2 = 0;

        for (let i = 0; i < n; i++) {
            sumXY += xData[i] * yData[i];
            sumX2 += xData[i] * xData[i];
        }

        let slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX + 1e-10);
        let intercept = (sumY - slope * sumX) / n;

        return {
            slope: slope,
            intercept: intercept
        };
    }

    // ═══════════════════════════════════════════════════════════════
    // استخراج حد سيغمويد واحد
    // ═══════════════════════════════════════════════════════════════

    function extractSigmoidTerm(xData: number[], yData: number[], termIndex: number, totalTerms: number): object {
        // تقسيم المدى إلى أجزاء
        let minX = Math.min(...xData);
        let maxX = Math.max(...xData);
        let range = maxX - minX;

        // تحديد مركز الحد
        let center = minX + (range * (termIndex + 1)) / (totalTerms + 1);

        // تحديد الحدة بناءً على التعقيد
        let sharpness = 5.0 + Math.random() * 5.0;

        // تحديد التحجيم
        let scale = 1.0 / totalTerms;

        // تحديد معامل التقطيع
        let cutoff = 1; // ابدأ بسيغمويد كلاسيكي

        // الوزن
        let weight = 1.0;

        return {
            scale: scale,
            sharpness: sharpness,
            center: center,
            cutoff: cutoff,
            weight: weight
        };
    }

    // ═══════════════════════════════════════════════════════════════
    // تحسين المعاملات
    // ═══════════════════════════════════════════════════════════════

    function optimizeParameters(equation: SigmoidShapeEquation, xData: number[], yData: number[]): void {
        // تحسين بسيط باستخدام gradient descent
        let iterations = 0;
        let prevError = Infinity;

        while (iterations < this.maxIterations) {
            // حساب الخطأ الحالي
            let error = this.computeError(equation, xData, yData);

            // التحقق من التقارب
            if (Math.abs(prevError - error) < this.convergenceThreshold) {
                break;
            }

            prevError = error;
            iterations++;

            // هنا يمكن إضافة خوارزمية تحسين أكثر تعقيداً
            // لكن للبساطة، سنتركها كما هي
        }

        console.log(`✅ تم التحسين بعد ${iterations} تكرار`);
    }

    // ═══════════════════════════════════════════════════════════════
    // حساب الخطأ
    // ═══════════════════════════════════════════════════════════════

    function computeError(equation: SigmoidShapeEquation, xData: number[], yData: number[]): number {
        let totalError = 0;

        for (let i = 0; i < xData.length; i++) {
            let predicted = equation.evaluate(xData[i]);
            let actual = yData[i];
            totalError += (predicted - actual) * (predicted - actual);
        }

        return totalError / xData.length;
    }

    // ═══════════════════════════════════════════════════════════════
    // حساب مقاييس الجودة
    // ═══════════════════════════════════════════════════════════════

    function calculateQualityMetrics(equation: SigmoidShapeEquation, xData: number[], yData: number[]): object {
        // حساب R²
        let yMean = yData.reduce((a, b) => a + b, 0) / yData.length;
        let ssTot = 0;
        let ssRes = 0;

        for (let i = 0; i < xData.length; i++) {
            let predicted = equation.evaluate(xData[i]);
            let actual = yData[i];

            ssTot += (actual - yMean) * (actual - yMean);
            ssRes += (actual - predicted) * (actual - predicted);
        }

        let rSquared = 1 - (ssRes / (ssTot + 1e-10));
        rSquared = Math.max(0.0, Math.min(1.0, rSquared));

        // حساب الخطأ المتبقي
        let residualError = Math.sqrt(ssRes / xData.length);

        // حساب التقارب
        let convergence = rSquared;

        return {
            rSquared: rSquared,
            residualError: residualError,
            convergence: convergence
        };
    }

    // ═══════════════════════════════════════════════════════════════
    // حساب الثقة
    // ═══════════════════════════════════════════════════════════════

    function calculateConfidence(features: ExtractedFeatures, qualityMetrics: object): number {
        // الثقة = متوسط R² والاستطالة والتماثل
        let r2 = qualityMetrics.rSquared || 0.5;
        let compactness = features.compactness;
        let symmetry = features.symmetry;

        let confidence = (r2 + compactness + symmetry) / 3;

        return Math.max(0.0, Math.min(1.0, confidence));
    }

    // ═══════════════════════════════════════════════════════════════
    // توليد التفسير
    // ═══════════════════════════════════════════════════════════════

    function generateReasoning(features: ExtractedFeatures, numTerms: number, confidence: number): string {
        let reasoning = `تم استنباط معادلة بـ ${numTerms} حد سيغمويد. `;

        if (confidence > 0.8) {
            reasoning += "الثقة عالية جداً. ";
        } else if (confidence > 0.6) {
            reasoning += "الثقة جيدة. ";
        } else {
            reasoning += "الثقة متوسطة. ";
        }

        if (features.symmetry > 0.8) {
            reasoning += "الشكل متماثل. ";
        }

        if (features.periodicity > 0.7) {
            reasoning += "الشكل دوري. ";
        }

        if (features.isClosed) {
            reasoning += "الشكل مغلق. ";
        }

        return reasoning;
    }

    // ═══════════════════════════════════════════════════════════════
    // إنشاء نتيجة فارغة
    // ═══════════════════════════════════════════════════════════════

    function createEmptyResult(): InferenceResult {
        let emptyEquation = new SigmoidShapeEquation("empty", "Empty");
        let result = new InferenceResult(emptyEquation);
        result.confidence = 0.0;
        result.reasoning = "فشل الاستنباط - بيانات غير كافية";
        return result;
    }

    // ═══════════════════════════════════════════════════════════════
    // تحديث الإحصائيات
    // ═══════════════════════════════════════════════════════════════

    function updateStats(result: InferenceResult): void {
        this.stats.totalInferences++;

        if (result.confidence > 0.5) {
            this.stats.successfulInferences++;
        }

        // تحديث متوسط الثقة
        let total = this.stats.totalInferences;
        let prevAvg = this.stats.averageConfidence;
        this.stats.averageConfidence = (prevAvg * (total - 1) + result.confidence) / total;
    }

    // ═══════════════════════════════════════════════════════════════
    // الحصول على الإحصائيات
    // ═══════════════════════════════════════════════════════════════

    function getStats(): object {
        return {
            totalInferences: this.stats.totalInferences,
            successfulInferences: this.stats.successfulInferences,
            successRate: this.stats.totalInferences > 0
                ? this.stats.successfulInferences / this.stats.totalInferences
                : 0.0,
            averageConfidence: this.stats.averageConfidence
        };
    }
}

// ═══════════════════════════════════════════════════════════════
// تصدير
// ═══════════════════════════════════════════════════════════════

export { SigmoidInferenceEngine, InferenceResult, ExtractedFeatures };
