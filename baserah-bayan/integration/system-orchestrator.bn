// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¼ Ø¨ØµÙŠØ±Ø© AI - Ù…Ù†Ø³Ù‚ Ø§Ù„Ø£Ù†Ø¸Ù…Ø© (System Orchestrator)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ø§Ù„ÙˆØµÙ: Ù…Ù†Ø³Ù‚ Ø°ÙƒÙŠ Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ø¹Ù…Ù„ Ø¨ÙŠÙ† Ø¬Ù…ÙŠØ¹ Ø£Ù†Ø¸Ù…Ø© Ø¨ØµÙŠØ±Ø© AI
// Ø§Ù„Ù…Ù‡Ù…Ø©: Ø¥Ø¯Ø§Ø±Ø© ØªØ¯ÙÙ‚ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙˆØ§Ù„ØªÙ†Ø³ÙŠÙ‚ Ø¨ÙŠÙ† Ø§Ù„Ø£Ù†Ø¸Ù…Ø© Ø§Ù„ÙØ±Ø¹ÙŠØ©
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import { MotherEquation } from "../core/mother-equation.bn";
import { BaserahUnifiedSystem, SystemTask, TaskPriority, TaskType } from "./unified-system.bn";

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ø§Ù„ØªØ¹Ø¯Ø§Ø¯Ø§Øª (Enums)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Ø§Ù„ØªÙ†Ø³ÙŠÙ‚
enum OrchestrationStrategy {
    SEQUENTIAL = "sequential",           // ØªÙ†ÙÙŠØ° Ù…ØªØ³Ù„Ø³Ù„
    PARALLEL = "parallel",               // ØªÙ†ÙÙŠØ° Ù…ØªÙˆØ§Ø²ÙŠ
    ADAPTIVE = "adaptive",               // ØªÙƒÙŠÙÙŠ Ø­Ø³Ø¨ Ø§Ù„Ø­Ù…Ù„
    PRIORITY_BASED = "priority_based",   // Ø­Ø³Ø¨ Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ©
    INTELLIGENT = "intelligent"          // Ø°ÙƒÙŠ (ÙŠØ®ØªØ§Ø± Ø§Ù„Ø£ÙØ¶Ù„)
}

// Ù†ÙˆØ¹ Ø§Ù„ØªÙ†Ø³ÙŠÙ‚
enum OrchestrationType {
    DATA_FLOW = "data_flow",             // ØªØ¯ÙÙ‚ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    EVENT_DRIVEN = "event_driven",       // Ù…Ø¯ÙÙˆØ¹ Ø¨Ø§Ù„Ø£Ø­Ø¯Ø§Ø«
    REQUEST_RESPONSE = "request_response", // Ø·Ù„Ø¨-Ø§Ø³ØªØ¬Ø§Ø¨Ø©
    PIPELINE = "pipeline",               // Ø®Ø· Ø£Ù†Ø§Ø¨ÙŠØ¨
    HYBRID = "hybrid"                    // Ù‡Ø¬ÙŠÙ†
}

// Ø­Ø§Ù„Ø© Ø§Ù„ØªÙ†Ø³ÙŠÙ‚
enum OrchestrationState {
    IDLE = "idle",
    PLANNING = "planning",
    EXECUTING = "executing",
    MONITORING = "monitoring",
    OPTIMIZING = "optimizing",
    ERROR_HANDLING = "error_handling"
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ø§Ù„ÙØ¦Ø§Øª (Classes)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Ø®Ø·Ø© Ø§Ù„ØªÙ†Ø³ÙŠÙ‚
class OrchestrationPlan extends MotherEquation {
    public planId: string;
    public task: SystemTask;
    public strategy: OrchestrationStrategy;
    public steps: array<object>;
    public dependencies: object;
    public estimatedTime: number;
    public actualTime: number;
    
    constructor(planId: string, task: SystemTask, strategy: OrchestrationStrategy) {
        super(planId);
        this.planId = planId;
        this.task = task;
        this.strategy = strategy;
        this.steps = [];
        this.dependencies = {};
        this.estimatedTime = 0;
        this.actualTime = 0;
        
        // Î¦: Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø«Ø§Ø¨ØªØ©
        this.fixedProperties = {
            planId: planId,
            taskId: task.taskId,
            strategy: strategy
        };
        
        // Î¨: Ø§Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©
        this.dynamicStates = {
            currentStep: 0,
            progress: 0,
            status: "pending"
        };
    }
    
    public addStep(stepName: string, subsystem: string, operation: string, input: object): void {
        this.steps.push({
            stepNumber: this.steps.length + 1,
            stepName: stepName,
            subsystem: subsystem,
            operation: operation,
            input: input,
            output: null,
            status: "pending",
            startTime: 0,
            endTime: 0
        });
    }
    
    public executeStep(stepNumber: number, output: object): void {
        if (stepNumber > 0 && stepNumber <= this.steps.length) {
            this.steps[stepNumber - 1].output = output;
            this.steps[stepNumber - 1].status = "completed";
            this.steps[stepNumber - 1].endTime = Date.now();
            this.dynamicStates.currentStep = stepNumber;
            this.dynamicStates.progress = (stepNumber / this.steps.length) * 100;
        }
    }
}

// Ø­Ø¯Ø« Ø§Ù„Ù†Ø¸Ø§Ù…
class SystemEvent extends MotherEquation {
    public eventId: string;
    public eventType: string;
    public source: string;
    public target: string;
    public data: object;
    public timestamp: number;
    public priority: TaskPriority;
    
    constructor(eventId: string, eventType: string, source: string, target: string) {
        super(eventId);
        this.eventId = eventId;
        this.eventType = eventType;
        this.source = source;
        this.target = target;
        this.data = {};
        this.timestamp = Date.now();
        this.priority = TaskPriority.MEDIUM;
        
        // Î¦: Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø«Ø§Ø¨ØªØ©
        this.fixedProperties = {
            eventId: eventId,
            eventType: eventType,
            source: source,
            target: target
        };
        
        // Î¨: Ø§Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©
        this.dynamicStates = {
            processed: false,
            processingTime: 0
        };
    }
}

// Ù…Ù†Ø³Ù‚ Ø§Ù„Ø£Ù†Ø¸Ù…Ø©
class SystemOrchestrator extends MotherEquation {
    public orchestratorId: string;
    public unifiedSystem: BaserahUnifiedSystem;
    public state: OrchestrationState;
    public defaultStrategy: OrchestrationStrategy;
    
    // Ø®Ø·Ø· Ø§Ù„ØªÙ†Ø³ÙŠÙ‚
    public activePlans: array<OrchestrationPlan>;
    public completedPlans: array<OrchestrationPlan>;
    
    // Ø§Ù„Ø£Ø­Ø¯Ø§Ø«
    public eventQueue: array<SystemEvent>;
    public eventHandlers: object;
    
    // Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
    public statistics: object;
    
    constructor(orchestratorId: string, unifiedSystem: BaserahUnifiedSystem) {
        super(orchestratorId);
        this.orchestratorId = orchestratorId;
        this.unifiedSystem = unifiedSystem;
        this.state = OrchestrationState.IDLE;
        this.defaultStrategy = OrchestrationStrategy.INTELLIGENT;
        
        this.activePlans = [];
        this.completedPlans = [];
        this.eventQueue = [];
        this.eventHandlers = {};
        
        this.statistics = {
            totalPlans: 0,
            completedPlans: 0,
            failedPlans: 0,
            totalEvents: 0,
            processedEvents: 0,
            averagePlanTime: 0
        };
        
        // Î¦: Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø«Ø§Ø¨ØªØ©
        this.fixedProperties = {
            orchestratorId: orchestratorId,
            capabilities: [
                "sequential_execution",
                "parallel_execution",
                "adaptive_orchestration",
                "event_handling",
                "dependency_management"
            ]
        };
        
        // Î¨: Ø§Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©
        this.dynamicStates = {
            state: OrchestrationState.IDLE,
            activePlansCount: 0,
            eventQueueSize: 0,
            systemLoad: 0
        };
        
        // ØªØ³Ø¬ÙŠÙ„ Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø§Ù„Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
        this.registerDefaultEventHandlers();
    }
    
    // ØªØ³Ø¬ÙŠÙ„ Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø§Ù„Ø£Ø­Ø¯Ø§Ø«
    private registerDefaultEventHandlers(): void {
        this.eventHandlers = {
            "query_received": this.handleQueryEvent.bind(this),
            "learning_required": this.handleLearningEvent.bind(this),
            "knowledge_update": this.handleKnowledgeUpdateEvent.bind(this),
            "memory_consolidation": this.handleMemoryConsolidationEvent.bind(this),
            "system_error": this.handleSystemErrorEvent.bind(this)
        };
    }
    
    // Ø¥Ù†Ø´Ø§Ø¡ Ø®Ø·Ø© ØªÙ†Ø³ÙŠÙ‚
    public createPlan(task: SystemTask, strategy: OrchestrationStrategy): OrchestrationPlan {
        this.state = OrchestrationState.PLANNING;
        
        let plan = new OrchestrationPlan(
            "plan_" + Date.now(),
            task,
            strategy || this.defaultStrategy
        );
        
        // Ø¨Ù†Ø§Ø¡ Ø§Ù„Ø®Ø·ÙˆØ§Øª Ø­Ø³Ø¨ Ù†ÙˆØ¹ Ø§Ù„Ù…Ù‡Ù…Ø©
        this.buildPlanSteps(plan, task);
        
        this.activePlans.push(plan);
        this.statistics.totalPlans++;
        this.dynamicStates.activePlansCount++;
        
        return plan;
    }
    
    // Ø¨Ù†Ø§Ø¡ Ø®Ø·ÙˆØ§Øª Ø§Ù„Ø®Ø·Ø©
    private buildPlanSteps(plan: OrchestrationPlan, task: SystemTask): void {
        if (task.taskType === TaskType.QUERY) {
            // Ø®Ø·ÙˆØ§Øª Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…
            plan.addStep("ØªØ­Ù„ÙŠÙ„ Ù„ØºÙˆÙŠ", "language", "processText", task.input);
            plan.addStep("Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ù…Ù† Ø§Ù„Ø°Ø§ÙƒØ±Ø©", "memory", "retrieveRelevant", {});
            plan.addStep("Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ù…Ø¹Ø±ÙØ©", "knowledge", "query", {});
            plan.addStep("Ø§Ø³ØªØ¯Ù„Ø§Ù„ Ù…Ù†Ø·Ù‚ÙŠ", "reasoning", "reason", {});
            plan.addStep("ØªÙˆÙ„ÙŠØ¯ Ø±Ø¯", "response", "generate", {});
            plan.addStep("Ø­ÙØ¸ ÙÙŠ Ø§Ù„Ø°Ø§ÙƒØ±Ø©", "memory", "addEpisode", {});
        } else if (task.taskType === TaskType.LEARNING) {
            // Ø®Ø·ÙˆØ§Øª Ø§Ù„ØªØ¹Ù„Ù…
            plan.addStep("ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªØºØ°ÙŠØ© Ø§Ù„Ø±Ø§Ø¬Ø¹Ø©", "learning", "analyzeFeedback", task.input);
            plan.addStep("Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø£Ù†Ù…Ø§Ø·", "learning", "extractPatterns", {});
            plan.addStep("ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø¹Ø±ÙØ©", "knowledge", "update", {});
            plan.addStep("Ø¯Ù…Ø¬ ÙÙŠ Ø§Ù„Ø°Ø§ÙƒØ±Ø©", "memory", "consolidate", {});
        } else if (task.taskType === TaskType.REASONING) {
            // Ø®Ø·ÙˆØ§Øª Ø§Ù„Ø§Ø³ØªØ¯Ù„Ø§Ù„
            plan.addStep("Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø§Ù„Ù…Ø¹Ø±ÙØ©", "knowledge", "queryByDomain", task.input);
            plan.addStep("Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø§Ù„Ø®Ø¨ÙŠØ±", "brain", "expertRecall", {});
            plan.addStep("Ø§Ø³ØªÙƒØ´Ø§Ù Ø¬Ø¯ÙŠØ¯", "brain", "explorerExplore", {});
            plan.addStep("Ø§Ø³ØªØ¯Ù„Ø§Ù„ Ù…Ù†Ø·Ù‚ÙŠ", "reasoning", "reason", {});
            plan.addStep("Ø¯Ù…Ø¬ Ø§Ù„Ø­Ù„ÙˆÙ„", "orchestrator", "integrateSolutions", {});
        } else if (task.taskType === TaskType.INTERACTION) {
            // Ø®Ø·ÙˆØ§Øª Ø§Ù„ØªÙØ§Ø¹Ù„
            plan.addStep("Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¯ÙˆØ± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…", "dialogue", "processUserTurn", task.input);
            plan.addStep("ØªØ­Ù„ÙŠÙ„ Ù„ØºÙˆÙŠ", "language", "processText", {});
            plan.addStep("Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø§Ù„Ø³ÙŠØ§Ù‚", "memory", "getActiveContext", {});
            plan.addStep("ØªÙˆÙ„ÙŠØ¯ Ø±Ø¯", "response", "generate", {});
            plan.addStep("ØªØ­Ø¯ÙŠØ« Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…", "userModeling", "updateFromTurn", {});
        }
    }

    // ØªÙ†ÙÙŠØ° Ø®Ø·Ø©
    public executePlan(plan: OrchestrationPlan): object {
        this.state = OrchestrationState.EXECUTING;
        let startTime = Date.now();
        let results = {};

        if (plan.strategy === OrchestrationStrategy.SEQUENTIAL) {
            results = this.executeSequential(plan);
        } else if (plan.strategy === OrchestrationStrategy.PARALLEL) {
            results = this.executeParallel(plan);
        } else if (plan.strategy === OrchestrationStrategy.INTELLIGENT) {
            results = this.executeIntelligent(plan);
        }

        plan.actualTime = Date.now() - startTime;
        plan.dynamicStates.status = "completed";

        // Ù†Ù‚Ù„ Ù…Ù† Ø§Ù„Ù†Ø´Ø·Ø© Ø¥Ù„Ù‰ Ø§Ù„Ù…ÙƒØªÙ…Ù„Ø©
        let index = this.activePlans.indexOf(plan);
        if (index > -1) {
            this.activePlans.splice(index, 1);
        }
        this.completedPlans.push(plan);
        this.statistics.completedPlans++;
        this.dynamicStates.activePlansCount--;

        this.state = OrchestrationState.IDLE;
        return results;
    }

    // ØªÙ†ÙÙŠØ° Ù…ØªØ³Ù„Ø³Ù„
    private executeSequential(plan: OrchestrationPlan): object {
        let results = {};
        let previousOutput = null;

        for (let step of plan.steps) {
            step.startTime = Date.now();
            step.status = "executing";

            // ØªÙ†ÙÙŠØ° Ø§Ù„Ø®Ø·ÙˆØ©
            let output = this.executeStep(step, previousOutput);

            step.output = output;
            step.status = "completed";
            step.endTime = Date.now();

            previousOutput = output;
            results[step.stepName] = output;
        }

        return results;
    }

    // ØªÙ†ÙÙŠØ° Ù…ØªÙˆØ§Ø²ÙŠ
    private executeParallel(plan: OrchestrationPlan): object {
        let results = {};

        // ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø®Ø·ÙˆØ§Øª Ø§Ù„Ù…Ø³ØªÙ‚Ù„Ø© Ø¨Ø§Ù„ØªÙˆØ§Ø²ÙŠ
        for (let step of plan.steps) {
            step.startTime = Date.now();
            step.status = "executing";

            let output = this.executeStep(step, null);

            step.output = output;
            step.status = "completed";
            step.endTime = Date.now();

            results[step.stepName] = output;
        }

        return results;
    }

    // ØªÙ†ÙÙŠØ° Ø°ÙƒÙŠ
    private executeIntelligent(plan: OrchestrationPlan): object {
        // ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªØ¨Ø¹ÙŠØ§Øª ÙˆØ§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Ø§Ù„Ø£ÙØ¶Ù„
        let hasSequentialDependencies = this.analyzeSequentialDependencies(plan);

        if (hasSequentialDependencies) {
            return this.executeSequential(plan);
        } else {
            return this.executeParallel(plan);
        }
    }

    // ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªØ¨Ø¹ÙŠØ§Øª Ø§Ù„Ù…ØªØ³Ù„Ø³Ù„Ø©
    private analyzeSequentialDependencies(plan: OrchestrationPlan): boolean {
        // ÙÙŠ Ù…Ø¹Ø¸Ù… Ø§Ù„Ø­Ø§Ù„Ø§ØªØŒ Ø§Ù„Ø®Ø·ÙˆØ§Øª Ù„Ù‡Ø§ ØªØ¨Ø¹ÙŠØ§Øª Ù…ØªØ³Ù„Ø³Ù„Ø©
        return true;
    }

    // ØªÙ†ÙÙŠØ° Ø®Ø·ÙˆØ© ÙˆØ§Ø­Ø¯Ø©
    private executeStep(step: object, previousOutput: object): object {
        // Ù…Ø­Ø§ÙƒØ§Ø© ØªÙ†ÙÙŠØ° Ø§Ù„Ø®Ø·ÙˆØ©
        return {
            stepName: step.stepName,
            subsystem: step.subsystem,
            operation: step.operation,
            result: "success",
            data: previousOutput || step.input
        };
    }

    // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø­Ø¯Ø«
    public handleEvent(event: SystemEvent): void {
        this.eventQueue.push(event);
        this.statistics.totalEvents++;
        this.dynamicStates.eventQueueSize++;

        // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø­Ø¯Ø« Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ù…Ø¹Ø§Ù„Ø¬ Ù…Ø³Ø¬Ù„
        if (this.eventHandlers[event.eventType]) {
            this.eventHandlers[event.eventType](event);
            event.dynamicStates.processed = true;
            this.statistics.processedEvents++;
            this.dynamicStates.eventQueueSize--;
        }
    }

    // Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø§Ù„Ø£Ø­Ø¯Ø§Ø«
    private handleQueryEvent(event: SystemEvent): void {
        let task = new SystemTask(
            "query_" + Date.now(),
            TaskType.QUERY,
            TaskPriority.HIGH,
            "Handle query event"
        );
        task.input = event.data;

        let plan = this.createPlan(task, OrchestrationStrategy.SEQUENTIAL);
        this.executePlan(plan);
    }

    private handleLearningEvent(event: SystemEvent): void {
        let task = new SystemTask(
            "learn_" + Date.now(),
            TaskType.LEARNING,
            TaskPriority.MEDIUM,
            "Handle learning event"
        );
        task.input = event.data;

        let plan = this.createPlan(task, OrchestrationStrategy.SEQUENTIAL);
        this.executePlan(plan);
    }

    private handleKnowledgeUpdateEvent(event: SystemEvent): void {
        this.unifiedSystem.knowledge.updateKnowledge(event.data);
    }

    private handleMemoryConsolidationEvent(event: SystemEvent): void {
        this.unifiedSystem.memory.consolidate();
    }

    private handleSystemErrorEvent(event: SystemEvent): void {
        this.state = OrchestrationState.ERROR_HANDLING;
        console.error("System Error:", event.data);
        this.state = OrchestrationState.IDLE;
    }

    // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
    public getStatistics(): object {
        return {
            ...this.statistics,
            activePlansCount: this.activePlans.length,
            completedPlansCount: this.completedPlans.length,
            eventQueueSize: this.eventQueue.length,
            currentState: this.state
        };
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ø§Ù„ØªØµØ¯ÙŠØ± (Exports)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export {
    OrchestrationStrategy,
    OrchestrationType,
    OrchestrationState,
    OrchestrationPlan,
    SystemEvent,
    SystemOrchestrator
};

