/**
 * Ù†Ø¸Ø§Ù… ØªØºØ°ÙŠØ© Ø§Ù„Ù…Ø¹Ø±ÙØ© - Knowledge Feeding System
 * 
 * ğŸ§  Ù†Ø¸Ø§Ù… Ø´Ø§Ù…Ù„ Ù„ØªØºØ°ÙŠØ© Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø¨Ø§Ù„Ù…Ø¹Ø±ÙØ© ÙˆØ§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
 * ğŸ“ ÙŠØ¯Ø¹Ù… Ø£Ù†ÙˆØ§Ø¹ Ù…Ù„ÙØ§Øª Ù…ØªØ¹Ø¯Ø¯Ø© ÙˆÙ…ØµØ§Ø¯Ø± Ù…Ø¹Ø±ÙØ© Ù…Ø®ØªÙ„ÙØ©
 * ğŸ”„ ØªØ­ÙˆÙŠÙ„ ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù„Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¥Ù„Ù‰ ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬
 * 
 * @author Ø¨Ø§Ø³Ù„ ÙŠØ­ÙŠÙ‰ Ø¹Ø¨Ø¯Ø§Ù„Ù„Ù‡
 * @version 1.0.0
 * @date 2025-10-27
 */

import { MotherEquation } from "../core/mother-equation.bn";

/**
 * Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø¯Ø¹ÙˆÙ…Ø©
 */
enum FileType {
    JSON = "json",
    CSV = "csv",
    TXT = "txt",
    XML = "xml",
    XLSX = "xlsx",
    SQL = "sql",
    MD = "md",
    PDF = "pdf",
    DOCX = "docx"
}

/**
 * ÙØ¦Ø§Øª Ø§Ù„Ù…Ø¹Ø±ÙØ©
 */
enum KnowledgeCategory {
    MATHEMATICAL = "mathematical",
    SCIENTIFIC = "scientific",
    LINGUISTIC = "linguistic",
    HISTORICAL = "historical",
    TECHNICAL = "technical",
    PHILOSOPHICAL = "philosophical",
    CULTURAL = "cultural",
    GENERAL = "general"
}

/**
 * Ù…ØµØ§Ø¯Ø± Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
 */
enum DataSource {
    FILE_IMPORT = "file_import",
    DATABASE_IMPORT = "database_import",
    WEB_SCRAPING = "web_scraping",
    MANUAL_INPUT = "manual_input",
    API_IMPORT = "api_import",
    BULK_UPLOAD = "bulk_upload"
}

/**
 * Ù…Ø³ØªÙˆÙŠØ§Øª Ø§Ù„Ù…Ø¹Ø±ÙØ©
 */
enum KnowledgeLevel {
    BASIC = "basic",
    INTERMEDIATE = "intermediate",
    ADVANCED = "advanced",
    EXPERT = "expert"
}

/**
 * ÙØ¦Ø© Ø¹Ù†ØµØ± Ø§Ù„Ù…Ø¹Ø±ÙØ© - KnowledgeItem
 */
class KnowledgeItem extends MotherEquation {
    public itemId: string;
    public title: string;
    public content: string;
    public category: KnowledgeCategory;
    public level: KnowledgeLevel;
    public tags: array<string>;
    public sourceFile: string;
    public sourceType: DataSource;
    public creationTime: Date;
    public lastModified: Date;
    public metadata: object;
    public relatedItems: array<string>;
    public confidence: number;  // 0.0 - 1.0
    
    constructor(
        title: string,
        content: string,
        category: KnowledgeCategory = KnowledgeCategory.GENERAL,
        level: KnowledgeLevel = KnowledgeLevel.BASIC
    ) {
        super(`knowledge_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`);
        
        this.itemId = this.id;
        this.title = title;
        this.content = content;
        this.category = category;
        this.level = level;
        this.tags = [];
        this.sourceFile = "";
        this.sourceType = DataSource.MANUAL_INPUT;
        this.creationTime = new Date();
        this.lastModified = new Date();
        this.metadata = {};
        this.relatedItems = [];
        this.confidence = 1.0;
    }
    
    /**
     * Ø¥Ø¶Ø§ÙØ© Ø¹Ù„Ø§Ù…Ø©
     */
    public addTag(tag: string): void {
        if (!this.tags.includes(tag)) {
            this.tags.push(tag);
        }
    }
    
    /**
     * Ø±Ø¨Ø· Ø¹Ù†ØµØ± Ù…Ø¹Ø±ÙÙŠ Ø¢Ø®Ø±
     */
    public linkRelatedItem(itemId: string): void {
        if (!this.relatedItems.includes(itemId)) {
            this.relatedItems.push(itemId);
        }
    }
    
    /**
     * ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø­ØªÙˆÙ‰
     */
    public updateContent(newContent: string): void {
        this.content = newContent;
        this.lastModified = new Date();
    }
}

/**
 * ÙØ¦Ø© Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© - ProcessingResult
 */
class ProcessingResult {
    public success: boolean;
    public filePath: string;
    public fileType: string;
    public category: string;
    public itemsExtracted: number;
    public itemsSaved: number;
    public errors: array<string>;
    public processingTime: Date;
    
    constructor(success: boolean, filePath: string) {
        this.success = success;
        this.filePath = filePath;
        this.fileType = "";
        this.category = "";
        this.itemsExtracted = 0;
        this.itemsSaved = 0;
        this.errors = [];
        this.processingTime = new Date();
    }
    
    public addError(error: string): void {
        this.errors.push(error);
    }
}

/**
 * ÙØ¦Ø© Ù†Ø¸Ø§Ù… ØªØºØ°ÙŠØ© Ø§Ù„Ù…Ø¹Ø±ÙØ© - KnowledgeFeedingSystem
 */
class KnowledgeFeedingSystem {
    private knowledgeBasePath: string;
    private knowledgeItems: Map<string, KnowledgeItem>;
    private processingLog: array<ProcessingResult>;
    private totalFilesProcessed: number;
    private totalKnowledgeItems: number;
    private processingErrors: number;
    private supportedFormats: array<FileType>;
    private creationTime: Date;
    
    /**
     * Ø§Ù„Ù…ÙÙ†Ø´Ø¦
     */
    constructor(knowledgeBasePath: string = "knowledge_base") {
        this.knowledgeBasePath = knowledgeBasePath;
        this.knowledgeItems = new Map();
        this.processingLog = [];
        this.totalFilesProcessed = 0;
        this.totalKnowledgeItems = 0;
        this.processingErrors = 0;
        this.supportedFormats = [
            FileType.JSON,
            FileType.CSV,
            FileType.TXT,
            FileType.XML,
            FileType.XLSX,
            FileType.MD
        ];
        this.creationTime = new Date();
        
        console.log("ğŸ§ ğŸ“š ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø¸Ø§Ù… ØªØºØ°ÙŠØ© Ø§Ù„Ù…Ø¹Ø±ÙØ©");
        console.log(`   ğŸ“ Ù…Ø³Ø§Ø± Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ù…Ø¹Ø±ÙØ©: ${knowledgeBasePath}`);
        console.log(`   ğŸ“‹ Ø§Ù„ØµÙŠØº Ø§Ù„Ù…Ø¯Ø¹ÙˆÙ…Ø©: ${this.supportedFormats.length}`);
    }
    
    /**
     * ÙƒØ´Ù Ù†ÙˆØ¹ Ø§Ù„Ù…Ù„Ù
     */
    public detectFileType(filePath: string): FileType | null {
        let extension = filePath.split('.').pop()?.toLowerCase();
        
        if (extension === "json") return FileType.JSON;
        if (extension === "csv") return FileType.CSV;
        if (extension === "txt") return FileType.TXT;
        if (extension === "xml") return FileType.XML;
        if (extension === "xlsx" || extension === "xls") return FileType.XLSX;
        if (extension === "md") return FileType.MD;
        if (extension === "sql") return FileType.SQL;
        if (extension === "pdf") return FileType.PDF;
        if (extension === "docx") return FileType.DOCX;
        
        return null;
    }
    
    /**
     * Ù…Ø¹Ø§Ù„Ø¬Ø© Ù…Ù„Ù
     */
    public processFile(
        filePath: string,
        fileContent: string,
        category: KnowledgeCategory = KnowledgeCategory.GENERAL,
        metadata: object = {}
    ): ProcessingResult {
        let result = new ProcessingResult(true, filePath);
        
        let fileType = this.detectFileType(filePath);
        if (!fileType) {
            result.success = false;
            result.addError("Ù†ÙˆØ¹ Ù…Ù„Ù ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ…");
            this.processingErrors++;
            return result;
        }
        
        result.fileType = fileType;
        result.category = category;
        
        console.log(`\nğŸ“ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…Ù„Ù: ${filePath}`);
        console.log(`   ğŸ“‹ Ø§Ù„Ù†ÙˆØ¹: ${fileType}`);
        console.log(`   ğŸ·ï¸ Ø§Ù„ÙØ¦Ø©: ${category}`);
        
        try {
            // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø­Ø³Ø¨ Ù†ÙˆØ¹ Ø§Ù„Ù…Ù„Ù
            let data: any;
            
            if (fileType === FileType.JSON) {
                data = this.processJsonContent(fileContent);
            } else if (fileType === FileType.CSV) {
                data = this.processCsvContent(fileContent);
            } else if (fileType === FileType.TXT || fileType === FileType.MD) {
                data = this.processTextContent(fileContent);
            } else if (fileType === FileType.XML) {
                data = this.processXmlContent(fileContent);
            } else {
                result.success = false;
                result.addError(`Ù…Ø¹Ø§Ù„Ø¬ ${fileType} ØºÙŠØ± Ù…Ø·Ø¨Ù‚ Ø¨Ø¹Ø¯`);
                return result;
            }
            
            // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¥Ù„Ù‰ Ø¹Ù†Ø§ØµØ± Ù…Ø¹Ø±ÙÙŠØ©
            let knowledgeItems = this.convertToKnowledge(data, category, filePath, metadata);
            result.itemsExtracted = knowledgeItems.length;
            
            // Ø­ÙØ¸ Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ù…Ø¹Ø±ÙÙŠØ©
            let savedCount = this.saveKnowledgeItems(knowledgeItems);
            result.itemsSaved = savedCount;
            
            this.totalFilesProcessed++;
            this.totalKnowledgeItems += savedCount;
            
            console.log(`   âœ… ØªÙ… Ø§Ø³ØªØ®Ø±Ø§Ø¬ ${knowledgeItems.length} Ø¹Ù†ØµØ± Ù…Ø¹Ø±ÙÙŠ`);
            console.log(`   ğŸ’¾ ØªÙ… Ø­ÙØ¸ ${savedCount} Ø¹Ù†ØµØ±`);
            
        } catch (error) {
            result.success = false;
            result.addError(error.toString());
            this.processingErrors++;
            console.log(`   âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©: ${error}`);
        }
        
        this.processingLog.push(result);
        return result;
    }
    
    /**
     * Ù…Ø¹Ø§Ù„Ø¬Ø© Ù…Ø­ØªÙˆÙ‰ JSON
     */
    private processJsonContent(content: string): any {
        try {
            return JSON.parse(content);
        } catch (error) {
            throw new Error(`Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù„ÙŠÙ„ JSON: ${error}`);
        }
    }
    
    /**
     * Ù…Ø¹Ø§Ù„Ø¬Ø© Ù…Ø­ØªÙˆÙ‰ CSV
     */
    private processCsvContent(content: string): array<object> {
        let lines = content.split('\n').filter(line => line.trim());
        if (lines.length === 0) return [];
        
        let headers = lines[0].split(',').map(h => h.trim());
        let data: array<object> = [];
        
        for (let i = 1; i < lines.length; i++) {
            let values = lines[i].split(',').map(v => v.trim());
            let row: any = {};
            
            for (let j = 0; j < headers.length; j++) {
                row[headers[j]] = values[j] || "";
            }
            
            data.push(row);
        }
        
        return data;
    }
    
    /**
     * Ù…Ø¹Ø§Ù„Ø¬Ø© Ù…Ø­ØªÙˆÙ‰ Ù†ØµÙŠ
     */
    private processTextContent(content: string): object {
        let paragraphs = content.split('\n\n').filter(p => p.trim());
        let lines = content.split('\n');
        let words = content.split(/\s+/);

        return {
            content: content,
            paragraphs: paragraphs,
            lineCount: lines.length,
            wordCount: words.length,
            charCount: content.length
        };
    }

    /**
     * Ù…Ø¹Ø§Ù„Ø¬Ø© Ù…Ø­ØªÙˆÙ‰ XML (Ø¨Ø³ÙŠØ·)
     */
    private processXmlContent(content: string): object {
        // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¨Ø³ÙŠØ·Ø© Ù„Ù€ XML
        // ÙÙŠ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØŒ Ø§Ø³ØªØ®Ø¯Ù… Ù…ÙƒØªØ¨Ø© XML parser
        return {
            content: content,
            type: "xml",
            note: "XML parsing requires external library"
        };
    }

    /**
     * ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¥Ù„Ù‰ Ø¹Ù†Ø§ØµØ± Ù…Ø¹Ø±ÙÙŠØ©
     */
    private convertToKnowledge(
        data: any,
        category: KnowledgeCategory,
        sourceFile: string,
        metadata: object
    ): array<KnowledgeItem> {
        let items: array<KnowledgeItem> = [];

        if (Array.isArray(data)) {
            // Ù…Ø¹Ø§Ù„Ø¬Ø© Ù…ØµÙÙˆÙØ© Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
            for (let i = 0; i < data.length; i++) {
                let itemData = data[i];
                let item = this.createKnowledgeItemFromData(itemData, category, sourceFile, metadata);
                if (item) items.push(item);
            }
        } else if (typeof data === 'object' && data !== null) {
            // Ù…Ø¹Ø§Ù„Ø¬Ø© ÙƒØ§Ø¦Ù† ÙˆØ§Ø­Ø¯
            if (data.content || data.paragraphs) {
                // Ù…Ø­ØªÙˆÙ‰ Ù†ØµÙŠ
                if (data.paragraphs && Array.isArray(data.paragraphs)) {
                    for (let para of data.paragraphs) {
                        let item = new KnowledgeItem(
                            `ÙÙ‚Ø±Ø© Ù…Ù† ${sourceFile}`,
                            para,
                            category,
                            this.determineKnowledgeLevel(para)
                        );
                        item.sourceFile = sourceFile;
                        item.sourceType = DataSource.FILE_IMPORT;
                        item.metadata = metadata;
                        items.push(item);
                    }
                } else if (data.content) {
                    let item = new KnowledgeItem(
                        `Ù…Ø­ØªÙˆÙ‰ Ù…Ù† ${sourceFile}`,
                        data.content,
                        category,
                        this.determineKnowledgeLevel(data.content)
                    );
                    item.sourceFile = sourceFile;
                    item.sourceType = DataSource.FILE_IMPORT;
                    item.metadata = metadata;
                    items.push(item);
                }
            } else {
                // Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù†Ø¸Ù…Ø©
                let item = this.createKnowledgeItemFromData(data, category, sourceFile, metadata);
                if (item) items.push(item);
            }
        }

        // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø¹Ù„Ø§Ù…Ø§Øª Ù„ÙƒÙ„ Ø¹Ù†ØµØ±
        for (let item of items) {
            this.extractAndAddTags(item);
        }

        return items;
    }

    /**
     * Ø¥Ù†Ø´Ø§Ø¡ Ø¹Ù†ØµØ± Ù…Ø¹Ø±ÙÙŠ Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
     */
    private createKnowledgeItemFromData(
        data: any,
        category: KnowledgeCategory,
        sourceFile: string,
        metadata: object
    ): KnowledgeItem | null {
        if (!data) return null;

        let title = data.title || data.name || `Ø¹Ù†ØµØ± Ù…Ù† ${sourceFile}`;
        let content = data.content || data.description || JSON.stringify(data);

        let item = new KnowledgeItem(
            title,
            content,
            category,
            this.determineKnowledgeLevel(content)
        );

        item.sourceFile = sourceFile;
        item.sourceType = DataSource.FILE_IMPORT;
        item.metadata = {...metadata, ...data};

        return item;
    }

    /**
     * ØªØ­Ø¯ÙŠØ¯ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ù…Ø¹Ø±ÙØ©
     */
    private determineKnowledgeLevel(content: string): KnowledgeLevel {
        let length = content.length;

        if (length > 2000) return KnowledgeLevel.EXPERT;
        if (length > 1000) return KnowledgeLevel.ADVANCED;
        if (length > 300) return KnowledgeLevel.INTERMEDIATE;
        return KnowledgeLevel.BASIC;
    }

    /**
     * Ø§Ø³ØªØ®Ø±Ø§Ø¬ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø¹Ù„Ø§Ù…Ø§Øª
     */
    private extractAndAddTags(item: KnowledgeItem): void {
        // Ø¥Ø¶Ø§ÙØ© Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ÙØ¦Ø©
        item.addTag(item.category);

        // ÙƒÙ„Ù…Ø§Øª Ù…ÙØªØ§Ø­ÙŠØ© Ø´Ø§Ø¦Ø¹Ø©
        let text = (item.title + " " + item.content).toLowerCase();

        // Ø±ÙŠØ§Ø¶ÙŠØ§Øª
        if (text.includes('Ù…Ø¹Ø§Ø¯Ù„Ø©') || text.includes('Ø­Ø³Ø§Ø¨') || text.includes('Ø±Ù‚Ù…')) {
            item.addTag('Ø±ÙŠØ§Ø¶ÙŠØ§Øª');
        }

        // Ø¹Ù„ÙˆÙ…
        if (text.includes('ØªØ¬Ø±Ø¨Ø©') || text.includes('Ù†Ø¸Ø±ÙŠØ©') || text.includes('Ù‚Ø§Ù†ÙˆÙ†')) {
            item.addTag('Ø¹Ù„ÙˆÙ…');
        }

        // ØªÙ‚Ù†ÙŠØ©
        if (text.includes('Ø¨Ø±Ù…Ø¬Ø©') || text.includes('Ù†Ø¸Ø§Ù…') || text.includes('ØªØ·Ø¨ÙŠÙ‚')) {
            item.addTag('ØªÙ‚Ù†ÙŠØ©');
        }

        // ÙÙ„Ø³ÙØ©
        if (text.includes('ÙÙƒØ±') || text.includes('Ù…ÙÙ‡ÙˆÙ…') || text.includes('ØªØ£Ù…Ù„')) {
            item.addTag('ÙÙ„Ø³ÙØ©');
        }
    }

    /**
     * Ø­ÙØ¸ Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ù…Ø¹Ø±ÙÙŠØ©
     */
    private saveKnowledgeItems(items: array<KnowledgeItem>): number {
        let savedCount = 0;

        for (let item of items) {
            try {
                this.knowledgeItems.set(item.itemId, item);
                savedCount++;
            } catch (error) {
                console.log(`   âš ï¸ Ø®Ø·Ø£ ÙÙŠ Ø­ÙØ¸ Ø§Ù„Ø¹Ù†ØµØ±: ${error}`);
            }
        }

        return savedCount;
    }

    /**
     * Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø¹Ù†Ø§ØµØ± Ù…Ø¹Ø±ÙÙŠØ©
     */
    public search(query: string, category: KnowledgeCategory | null = null): array<KnowledgeItem> {
        let results: array<KnowledgeItem> = [];
        let queryLower = query.toLowerCase();

        for (let [id, item] of this.knowledgeItems) {
            // ØªØµÙÙŠØ© Ø­Ø³Ø¨ Ø§Ù„ÙØ¦Ø©
            if (category && item.category !== category) continue;

            // Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ø¹Ù†ÙˆØ§Ù† ÙˆØ§Ù„Ù…Ø­ØªÙˆÙ‰
            if (item.title.toLowerCase().includes(queryLower) ||
                item.content.toLowerCase().includes(queryLower) ||
                item.tags.some(tag => tag.toLowerCase().includes(queryLower))) {
                results.push(item);
            }
        }

        return results;
    }

    /**
     * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¹Ù†ØµØ± Ù…Ø¹Ø±ÙÙŠ
     */
    public getKnowledgeItem(itemId: string): KnowledgeItem | null {
        return this.knowledgeItems.get(itemId) || null;
    }

    /**
     * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø­Ø³Ø¨ Ø§Ù„ÙØ¦Ø©
     */
    public getItemsByCategory(category: KnowledgeCategory): array<KnowledgeItem> {
        let items: array<KnowledgeItem> = [];

        for (let [id, item] of this.knowledgeItems) {
            if (item.category === category) {
                items.push(item);
            }
        }

        return items;
    }

    /**
     * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
     */
    public getStatistics(): object {
        let categoryCounts: any = {};

        for (let [id, item] of this.knowledgeItems) {
            let cat = item.category;
            categoryCounts[cat] = (categoryCounts[cat] || 0) + 1;
        }

        return {
            totalFilesProcessed: this.totalFilesProcessed,
            totalKnowledgeItems: this.totalKnowledgeItems,
            currentItemsInMemory: this.knowledgeItems.size,
            processingErrors: this.processingErrors,
            successRate: this.totalFilesProcessed > 0
                ? ((this.totalFilesProcessed - this.processingErrors) / this.totalFilesProcessed * 100).toFixed(2) + '%'
                : '0%',
            supportedFormats: this.supportedFormats,
            categoryCounts: categoryCounts,
            creationTime: this.creationTime
        };
    }

    /**
     * Ù…Ø³Ø­ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ù…Ø¹Ø±ÙÙŠØ©
     */
    public clearAll(): void {
        this.knowledgeItems.clear();
        console.log("ğŸ§¹ ØªÙ… Ù…Ø³Ø­ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ù…Ø¹Ø±ÙÙŠØ©");
    }
}

// ØªØµØ¯ÙŠØ± Ø§Ù„ÙØ¦Ø§Øª
export {
    KnowledgeItem,
    KnowledgeFeedingSystem,
    ProcessingResult,
    FileType,
    KnowledgeCategory,
    DataSource,
    KnowledgeLevel
};
