/**
 * نظام التعرف على الأنماط
 * Pattern Recognition System
 * 
 * نظام ذكي للتعرف على الأنماط واستخراجها من البيانات
 * يستخدم خوارزميات متقدمة لاكتشاف الأنماط المتكررة
 * 
 * @author Basel Yahya Abdullah
 * @version 1.0.0
 */

import { MotherEquation } from '../core/mother-equation.bn';
import { LearningType } from './learning-engine.bn';

// ============================================================================
// التعدادات (Enums)
// ============================================================================

/**
 * أنواع الأنماط
 */
enum PatternType {
    SEQUENTIAL = "sequential",          // نمط تسلسلي
    REPETITIVE = "repetitive",          // نمط متكرر
    CONDITIONAL = "conditional",        // نمط شرطي
    TEMPORAL = "temporal",              // نمط زمني
    BEHAVIORAL = "behavioral",          // نمط سلوكي
    LINGUISTIC = "linguistic",          // نمط لغوي
    CONTEXTUAL = "contextual"           // نمط سياقي
}

/**
 * مستوى تعقيد النمط
 */
enum PatternComplexity {
    SIMPLE = "simple",                  // بسيط
    MODERATE = "moderate",              // متوسط
    COMPLEX = "complex",                // معقد
    VERY_COMPLEX = "very_complex"       // معقد جداً
}

// ============================================================================
// الفئات الأساسية (Core Classes)
// ============================================================================

/**
 * نمط مكتشف
 * يمثل نمطاً تم اكتشافه من البيانات
 */
class DiscoveredPattern extends MotherEquation {
    public patternId: string;
    public patternType: PatternType;
    public complexity: PatternComplexity;
    public description: string;
    public signature: string;               // التوقيع الفريد للنمط
    public occurrences: number;             // عدد مرات الظهور
    public confidence: number;              // 0.0 - 1.0
    public features: array<string>;         // الخصائص المميزة
    public examples: array<object>;         // أمثلة على النمط
    public firstSeen: Date;
    public lastSeen: Date;
    public metadata: object;
    
    /**
     * المنشئ
     */
    constructor(
        patternId: string,
        patternType: PatternType,
        signature: string,
        description: string
    ) {
        super(patternId);
        
        this.patternId = patternId;
        this.patternType = patternType;
        this.signature = signature;
        this.description = description;
        this.complexity = PatternComplexity.SIMPLE;
        this.occurrences = 1;
        this.confidence = 0.5;
        this.features = [];
        this.examples = [];
        this.firstSeen = new Date();
        this.lastSeen = new Date();
        this.metadata = {};
        
        // تحديث المعادلة الأم
        this.updateMotherEquation();
    }
    
    /**
     * تحديث المعادلة الأم
     */
    private updateMotherEquation(): void {
        // Φ (Phi) - الخصائص الثابتة
        this.staticProperties = {
            patternId: this.patternId,
            patternType: this.patternType,
            signature: this.signature,
            description: this.description,
            firstSeen: this.firstSeen
        };
        
        // Ψ(t) (Psi) - الخصائص الديناميكية
        this.dynamicProperties = {
            occurrences: this.occurrences,
            confidence: this.confidence,
            complexity: this.complexity,
            lastSeen: this.lastSeen
        };
        
        // Γ (Gamma) - دالة الشكل
        this.shapeFunction = (t: number) => {
            return this.confidence * Math.log(1 + this.occurrences) * Math.exp(-0.01 * t);
        };
    }
    
    /**
     * تسجيل ظهور جديد
     */
    public recordOccurrence(example: object): void {
        this.occurrences++;
        this.lastSeen = new Date();
        this.examples.push(example);
        
        // الاحتفاظ بآخر 20 مثال
        if (this.examples.length > 20) {
            this.examples.shift();
        }
        
        // تحديث الثقة بناءً على عدد الظهورات
        this.updateConfidence();
        this.updateMotherEquation();
    }
    
    /**
     * تحديث مستوى الثقة
     */
    private updateConfidence(): void {
        // الثقة تزداد مع عدد الظهورات
        if (this.occurrences < 3) {
            this.confidence = 0.3;
        } else if (this.occurrences < 10) {
            this.confidence = 0.5 + (this.occurrences / 20);
        } else if (this.occurrences < 50) {
            this.confidence = 0.7 + (this.occurrences / 200);
        } else {
            this.confidence = Math.min(0.95, 0.8 + (this.occurrences / 500));
        }
    }
    
    /**
     * تحديد مستوى التعقيد
     */
    public determineComplexity(): void {
        const featureCount = this.features.length;
        
        if (featureCount <= 2) {
            this.complexity = PatternComplexity.SIMPLE;
        } else if (featureCount <= 5) {
            this.complexity = PatternComplexity.MODERATE;
        } else if (featureCount <= 10) {
            this.complexity = PatternComplexity.COMPLEX;
        } else {
            this.complexity = PatternComplexity.VERY_COMPLEX;
        }
    }
    
    /**
     * إضافة خاصية مميزة
     */
    public addFeature(feature: string): void {
        if (!this.features.includes(feature)) {
            this.features.push(feature);
            this.determineComplexity();
        }
    }
    
    /**
     * تحويل إلى JSON
     */
    public toJSON(): object {
        return {
            patternId: this.patternId,
            patternType: this.patternType,
            complexity: this.complexity,
            description: this.description,
            signature: this.signature,
            occurrences: this.occurrences,
            confidence: this.confidence,
            features: this.features,
            exampleCount: this.examples.length,
            firstSeen: this.firstSeen,
            lastSeen: this.lastSeen,
            metadata: this.metadata
        };
    }
}

/**
 * نتيجة التعرف على النمط
 */
class PatternRecognitionResult {
    public patterns: array<DiscoveredPattern>;
    public totalPatternsFound: number;
    public highConfidencePatterns: number;
    public processingTime: number;          // بالميلي ثانية
    public dataPointsAnalyzed: number;
    
    constructor() {
        this.patterns = [];
        this.totalPatternsFound = 0;
        this.highConfidencePatterns = 0;
        this.processingTime = 0;
        this.dataPointsAnalyzed = 0;
    }
    
    /**
     * إضافة نمط
     */
    public addPattern(pattern: DiscoveredPattern): void {
        this.patterns.push(pattern);
        this.totalPatternsFound++;
        
        if (pattern.confidence > 0.7) {
            this.highConfidencePatterns++;
        }
    }
    
    /**
     * ترتيب الأنماط حسب الثقة
     */
    public sortByConfidence(): void {
        this.patterns.sort((a, b) => b.confidence - a.confidence);
    }
    
    /**
     * تحويل إلى JSON
     */
    public toJSON(): object {
        return {
            totalPatternsFound: this.totalPatternsFound,
            highConfidencePatterns: this.highConfidencePatterns,
            processingTime: this.processingTime,
            dataPointsAnalyzed: this.dataPointsAnalyzed,
            patterns: this.patterns.map(p => p.toJSON())
        };
    }
}

/**
 * نظام التعرف على الأنماط
 * النظام الرئيسي لاكتشاف الأنماط
 */
class PatternRecognitionSystem extends MotherEquation {
    private discoveredPatterns: Map<string, DiscoveredPattern>;
    private patternsByType: Map<PatternType, Set<string>>;
    private minOccurrencesForPattern: number;
    private minConfidenceThreshold: number;
    
    // إحصائيات
    private totalAnalyses: number;
    private totalPatternsDiscovered: number;
    
    /**
     * المنشئ
     */
    constructor(
        minOccurrences: number = 3,
        minConfidence: number = 0.5
    ) {
        super("pattern-recognition-system");
        
        this.discoveredPatterns = new Map();
        this.patternsByType = new Map();
        this.minOccurrencesForPattern = minOccurrences;
        this.minConfidenceThreshold = minConfidence;
        
        // تهيئة الفهارس
        for (const type of Object.values(PatternType)) {
            this.patternsByType.set(type as PatternType, new Set());
        }
        
        // إحصائيات
        this.totalAnalyses = 0;
        this.totalPatternsDiscovered = 0;
        
        console.log("✅ تم تهيئة نظام التعرف على الأنماط");
    }
    
    /**
     * تحليل البيانات واكتشاف الأنماط
     */
    public analyzeData(data: array<object>): PatternRecognitionResult {
        const startTime = Date.now();
        this.totalAnalyses++;
        
        const result = new PatternRecognitionResult();
        result.dataPointsAnalyzed = data.length;
        
        // 1. اكتشاف الأنماط التسلسلية
        const sequentialPatterns = this.findSequentialPatterns(data);
        sequentialPatterns.forEach(p => result.addPattern(p));
        
        // 2. اكتشاف الأنماط المتكررة
        const repetitivePatterns = this.findRepetitivePatterns(data);
        repetitivePatterns.forEach(p => result.addPattern(p));
        
        // 3. اكتشاف الأنماط الشرطية
        const conditionalPatterns = this.findConditionalPatterns(data);
        conditionalPatterns.forEach(p => result.addPattern(p));
        
        // 4. اكتشاف الأنماط الزمنية
        const temporalPatterns = this.findTemporalPatterns(data);
        temporalPatterns.forEach(p => result.addPattern(p));
        
        // ترتيب النتائج
        result.sortByConfidence();
        
        // حساب وقت المعالجة
        result.processingTime = Date.now() - startTime;
        
        return result;
    }
    
    /**
     * اكتشاف الأنماط التسلسلية
     */
    private findSequentialPatterns(data: array<object>): array<DiscoveredPattern> {
        const patterns: array<DiscoveredPattern> = [];
        
        // البحث عن تسلسلات متكررة
        for (let i = 0; i < data.length - 1; i++) {
            const current = data[i];
            const next = data[i + 1];
            
            // إنشاء توقيع للتسلسل
            const signature = this.createSequenceSignature(current, next);
            
            if (this.discoveredPatterns.has(signature)) {
                // نمط موجود
                const pattern = this.discoveredPatterns.get(signature)!;
                pattern.recordOccurrence({ current, next });
            } else {
                // نمط جديد
                const pattern = new DiscoveredPattern(
                    this.generateId("seq"),
                    PatternType.SEQUENTIAL,
                    signature,
                    "نمط تسلسلي مكتشف"
                );
                
                pattern.addFeature("sequential_order");
                this.discoveredPatterns.set(signature, pattern);
                this.patternsByType.get(PatternType.SEQUENTIAL)!.add(signature);
                this.totalPatternsDiscovered++;
            }
        }
        
        // إرجاع الأنماط ذات الثقة العالية
        for (const [signature, pattern] of this.discoveredPatterns.entries()) {
            if (pattern.patternType === PatternType.SEQUENTIAL &&
                pattern.occurrences >= this.minOccurrencesForPattern &&
                pattern.confidence >= this.minConfidenceThreshold) {
                patterns.push(pattern);
            }
        }
        
        return patterns;
    }
    
    /**
     * اكتشاف الأنماط المتكررة
     */
    private findRepetitivePatterns(data: array<object>): array<DiscoveredPattern> {
        const patterns: array<DiscoveredPattern> = [];
        const frequencyMap: Map<string, number> = new Map();
        
        // حساب تكرار كل عنصر
        for (const item of data) {
            const signature = this.createItemSignature(item);
            frequencyMap.set(signature, (frequencyMap.get(signature) || 0) + 1);
        }
        
        // إنشاء أنماط للعناصر المتكررة
        for (const [signature, frequency] of frequencyMap.entries()) {
            if (frequency >= this.minOccurrencesForPattern) {
                if (this.discoveredPatterns.has(signature)) {
                    const pattern = this.discoveredPatterns.get(signature)!;
                    pattern.occurrences = frequency;
                } else {
                    const pattern = new DiscoveredPattern(
                        this.generateId("rep"),
                        PatternType.REPETITIVE,
                        signature,
                        `نمط متكرر (${frequency} مرة)`
                    );
                    
                    pattern.occurrences = frequency;
                    pattern.addFeature("high_frequency");
                    
                    this.discoveredPatterns.set(signature, pattern);
                    this.patternsByType.get(PatternType.REPETITIVE)!.add(signature);
                    this.totalPatternsDiscovered++;
                    
                    if (pattern.confidence >= this.minConfidenceThreshold) {
                        patterns.push(pattern);
                    }
                }
            }
        }
        
        return patterns;
    }
    
    /**
     * اكتشاف الأنماط الشرطية
     */
    private findConditionalPatterns(data: array<object>): array<DiscoveredPattern> {
        const patterns: array<DiscoveredPattern> = [];
        
        // البحث عن علاقات شرطية (if A then B)
        for (let i = 0; i < data.length - 1; i++) {
            const condition = data[i];
            const result = data[i + 1];
            
            if (this.hasConditionalRelation(condition, result)) {
                const signature = `if_${this.createItemSignature(condition)}_then_${this.createItemSignature(result)}`;
                
                if (this.discoveredPatterns.has(signature)) {
                    const pattern = this.discoveredPatterns.get(signature)!;
                    pattern.recordOccurrence({ condition, result });
                } else {
                    const pattern = new DiscoveredPattern(
                        this.generateId("cond"),
                        PatternType.CONDITIONAL,
                        signature,
                        "نمط شرطي مكتشف"
                    );
                    
                    pattern.addFeature("conditional_logic");
                    this.discoveredPatterns.set(signature, pattern);
                    this.patternsByType.get(PatternType.CONDITIONAL)!.add(signature);
                    this.totalPatternsDiscovered++;
                }
            }
        }
        
        return patterns;
    }
    
    /**
     * اكتشاف الأنماط الزمنية
     */
    private findTemporalPatterns(data: array<object>): array<DiscoveredPattern> {
        const patterns: array<DiscoveredPattern> = [];
        
        // البحث عن أنماط زمنية (أحداث في أوقات محددة)
        const timeBasedGroups: Map<string, array<object>> = new Map();
        
        for (const item of data) {
            if (item['timestamp']) {
                const timeKey = this.extractTimePattern(item['timestamp']);
                if (!timeBasedGroups.has(timeKey)) {
                    timeBasedGroups.set(timeKey, []);
                }
                timeBasedGroups.get(timeKey)!.push(item);
            }
        }
        
        // إنشاء أنماط للمجموعات الزمنية
        for (const [timeKey, items] of timeBasedGroups.entries()) {
            if (items.length >= this.minOccurrencesForPattern) {
                const signature = `temporal_${timeKey}`;
                
                const pattern = new DiscoveredPattern(
                    this.generateId("temp"),
                    PatternType.TEMPORAL,
                    signature,
                    `نمط زمني: ${timeKey}`
                );
                
                pattern.occurrences = items.length;
                pattern.addFeature("time_based");
                
                if (pattern.confidence >= this.minConfidenceThreshold) {
                    patterns.push(pattern);
                }
            }
        }
        
        return patterns;
    }
    
    /**
     * إنشاء توقيع للتسلسل
     */
    private createSequenceSignature(item1: object, item2: object): string {
        const sig1 = this.createItemSignature(item1);
        const sig2 = this.createItemSignature(item2);
        return `seq_${sig1}_${sig2}`;
    }
    
    /**
     * إنشاء توقيع للعنصر
     */
    private createItemSignature(item: object): string {
        // إنشاء توقيع بسيط بناءً على الخصائص الرئيسية
        const keys = Object.keys(item).sort();
        const values = keys.map(k => String(item[k])).join('_');
        return values.substring(0, 50); // أول 50 حرف
    }
    
    /**
     * التحقق من وجود علاقة شرطية
     */
    private hasConditionalRelation(condition: object, result: object): boolean {
        // منطق بسيط للتحقق من العلاقة الشرطية
        return condition['type'] !== undefined && result['type'] !== undefined;
    }
    
    /**
     * استخراج نمط زمني
     */
    private extractTimePattern(timestamp: any): string {
        if (timestamp instanceof Date) {
            const hour = timestamp.getHours();
            if (hour < 6) return "night";
            if (hour < 12) return "morning";
            if (hour < 18) return "afternoon";
            return "evening";
        }
        return "unknown";
    }
    
    /**
     * الحصول على الأنماط حسب النوع
     */
    public getPatternsByType(type: PatternType): array<DiscoveredPattern> {
        const patterns: array<DiscoveredPattern> = [];
        const patternIds = this.patternsByType.get(type)!;
        
        for (const id of patternIds) {
            const pattern = this.discoveredPatterns.get(id);
            if (pattern && pattern.confidence >= this.minConfidenceThreshold) {
                patterns.push(pattern);
            }
        }
        
        return patterns;
    }
    
    /**
     * الحصول على إحصائيات
     */
    public getStatistics(): object {
        const patternsByType: object = {};
        for (const [type, ids] of this.patternsByType.entries()) {
            patternsByType[type] = ids.size;
        }
        
        return {
            totalAnalyses: this.totalAnalyses,
            totalPatternsDiscovered: this.totalPatternsDiscovered,
            currentPatterns: this.discoveredPatterns.size,
            patternsByType: patternsByType,
            highConfidencePatterns: Array.from(this.discoveredPatterns.values())
                .filter(p => p.confidence > 0.7).length
        };
    }
    
    /**
     * مسح جميع الأنماط
     */
    public clearAll(): void {
        this.discoveredPatterns.clear();
        for (const type of Object.values(PatternType)) {
            this.patternsByType.get(type as PatternType)!.clear();
        }
    }
    
    /**
     * توليد معرف فريد
     */
    private generateId(prefix: string): string {
        return `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
}

// ============================================================================
// تصدير
// ============================================================================

export {
    PatternType,
    PatternComplexity,
    DiscoveredPattern,
    PatternRecognitionResult,
    PatternRecognitionSystem
};

