/**
 * Ù†Ø¸Ø§Ù… Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø§Ù„Ù…ØªÙƒÙŠÙØ© - Adaptive Equation Extraction System
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *
 * Ø§Ù„Ù…Ø·ÙˆØ±: Ø¨Ø§Ø³Ù„ ÙŠØ­ÙŠÙ‰ Ø¹Ø¨Ø¯Ø§Ù„Ù„Ù‡
 * Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£ÙÙƒØ§Ø± ÙˆØ§Ù„Ù†Ø¸Ø±ÙŠØ§Øª Ù…Ù† Ø¥Ø¨Ø¯Ø§Ø¹ Ø¨Ø§Ø³Ù„ ÙŠØ­ÙŠÙ‰ Ø¹Ø¨Ø¯Ø§Ù„Ù„Ù‡
 *
 * Ø§Ù„ÙˆØµÙ:
 * -------
 * Ù†Ø¸Ø§Ù… Ù…ØªÙ‚Ø¯Ù… Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬ ÙˆØ§Ø³ØªÙ†Ø¨Ø§Ø· Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª:
 * - Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø¯ÙˆØ§Ù„ Ø§Ù„Ø³ÙŠØºÙ…ÙˆÙŠØ¯
 * - Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø§Ù„Ø®Ø·ÙŠØ©
 * - ØªÙƒÙŠÙ Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ù…Ø¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
 * - ØªÙˆÙ„ÙŠØ¯ Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø±ÙŠØ§Ø¶ÙŠØ© Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„Ù‚Ø±Ø§Ø¡Ø©
 *
 * Ø§Ù„Ù‡Ø¯Ù:
 * ------
 * - ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø£Ø´ÙƒØ§Ù„ Ø§Ù„Ø¨ØµØ±ÙŠØ© Ø¥Ù„Ù‰ Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø±ÙŠØ§Ø¶ÙŠØ© Ø¯Ù‚ÙŠÙ‚Ø©
 * - Ø§Ø³ØªØ®Ø¯Ø§Ù… sigmoid + linear ÙÙ‚Ø·
 * - ØªÙˆÙÙŠØ± Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ù…ØªÙƒÙŠÙØ© ØªØªØ·ÙˆØ± Ù…Ø¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
 */

import { AdaptiveRevolutionaryEquation, AdaptationType } from "./adaptive-equations-core.bn";

// ==================== Ø§Ù„Ø£Ù†ÙˆØ§Ø¹ ====================

enum EquationType {
    SIGMOID = "sigmoid",
    LINEAR = "linear",
    SIGMOID_LINEAR_COMBINATION = "sigmoid_linear_combination",
    ADAPTIVE = "adaptive"
}

// ==================== Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø§Ù„Ø³ÙŠØºÙ…ÙˆÙŠØ¯ ====================

class SigmoidParameters {
    alpha: number;  // Ø§Ù„Ø³Ø¹Ø©
    k: number;      // Ø§Ù„Ø§Ù†Ø­Ø¯Ø§Ø±
    x0: number;     // Ø§Ù„Ø¥Ø²Ø§Ø­Ø© Ø§Ù„Ø£ÙÙ‚ÙŠØ©
    n: number;      // Ø¹Ø§Ù…Ù„ Ø§Ù„ØªÙƒÙ…ÙŠÙ…

    constructor(alpha: number = 1.0, k: number = 1.0, x0: number = 0.0, n: number = 1.0) {
        this.alpha = alpha;
        this.k = k;
        this.x0 = x0;
        this.n = n;
    }

    function toDict(): object {
        return {
            alpha: this.alpha,
            k: this.k,
            x0: this.x0,
            n: this.n
        };
    }
}

// ==================== Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø§Ù„Ø®Ø· Ø§Ù„Ù…Ø³ØªÙ‚ÙŠÙ… ====================

class LinearParameters {
    beta: number;   // Ø§Ù„Ù…ÙŠÙ„
    gamma: number;  // Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ø«Ø§Ø¨Øª
    n: number;      // Ø¹Ø§Ù…Ù„ Ø§Ù„ØªÙƒÙ…ÙŠÙ…

    constructor(beta: number = 1.0, gamma: number = 0.0, n: number = 1.0) {
        this.beta = beta;
        this.gamma = gamma;
        this.n = n;
    }

    function toDict(): object {
        return {
            beta: this.beta,
            gamma: this.gamma,
            n: this.n
        };
    }
}

// ==================== Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø±Ø¬Ø© ====================

class ExtractedEquation {
    equationType: EquationType;
    sigmoidParams: SigmoidParameters;
    linearParams: LinearParameters;
    sigmoidWeight: number;
    linearWeight: number;

    // Ø¬ÙˆØ¯Ø© Ø§Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬
    fitQuality: number;
    residualError: number;
    rSquared: number;

    // Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ©
    equationString: string;
    timestamp: Date;
    processingTime: number;

    constructor() {
        this.equationType = EquationType.ADAPTIVE;
        this.sigmoidParams = new SigmoidParameters();
        this.linearParams = new LinearParameters();
        this.sigmoidWeight = 0.5;
        this.linearWeight = 0.5;

        this.fitQuality = 0.0;
        this.residualError = 0.0;
        this.rSquared = 0.0;

        this.equationString = "";
        this.timestamp = new Date();
        this.processingTime = 0.0;
    }
}

// ==================== Ù†Ø¸Ø§Ù… Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø§Ù„Ù…ØªÙƒÙŠÙØ© ====================

class AdaptiveEquationExtractor {
    creator: string;
    methodology: string;

    // Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø§Ù„ØªØ­Ø³ÙŠÙ†
    learningRate: number;
    maxIterations: number;
    convergenceThreshold: number;

    // Ø³Ø¬Ù„ Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø±Ø¬Ø©
    extractionHistory: ExtractedEquation[];

    constructor() {
        this.creator = "Ø¨Ø§Ø³Ù„ ÙŠØ­ÙŠÙ‰ Ø¹Ø¨Ø¯Ø§Ù„Ù„Ù‡";
        this.methodology = "Adaptive Sigmoid + Linear Equation Extraction";

        // Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø§Ù„ØªØ­Ø³ÙŠÙ†
        this.learningRate = 0.01;
        this.maxIterations = 1000;
        this.convergenceThreshold = 1e-6;

        // Ø³Ø¬Ù„ Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø±Ø¬Ø©
        this.extractionHistory = [];

        console.log("ğŸ§¬ ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø¸Ø§Ù… Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø§Ù„Ù…ØªÙƒÙŠÙØ©");
    }

    // ==================== Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø© ====================

    function extractEquation(x: number[], y: number[]): ExtractedEquation {
        let startTime = Date.now();

        let equation = new ExtractedEquation();

        try {
            // Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø§Ù„Ø³ÙŠØºÙ…ÙˆÙŠØ¯
            equation.sigmoidParams = this.extractSigmoidParameters(x, y);

            // Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø§Ù„Ø®Ø· Ø§Ù„Ù…Ø³ØªÙ‚ÙŠÙ…
            equation.linearParams = this.extractLinearParameters(x, y);

            // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø£ÙˆØ²Ø§Ù† Ø§Ù„Ù…Ø«Ù„Ù‰
            let weights = this.optimizeWeights(x, y, equation.sigmoidParams, equation.linearParams);
            equation.sigmoidWeight = weights.sigmoid;
            equation.linearWeight = weights.linear;

            // Ø­Ø³Ø§Ø¨ Ø¬ÙˆØ¯Ø© Ø§Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬
            let quality = this.evaluateFit(x, y, equation.sigmoidParams, equation.linearParams,
                                          equation.sigmoidWeight, equation.linearWeight);
            equation.fitQuality = quality.fitQuality;
            equation.residualError = quality.residualError;
            equation.rSquared = quality.rSquared;

            // ØªÙˆÙ„ÙŠØ¯ Ù†Øµ Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø©
            equation.equationString = this.generateEquationString(
                equation.sigmoidParams, equation.linearParams,
                equation.sigmoidWeight, equation.linearWeight
            );

            equation.processingTime = (Date.now() - startTime) / 1000.0;

            this.extractionHistory.push(equation);

            console.log("âœ… ØªÙ… Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø© Ø¨Ù†Ø¬Ø§Ø­");
            console.log("   ğŸ“Š Ø¬ÙˆØ¯Ø© Ø§Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬: " + equation.fitQuality.toFixed(3));
            console.log("   ğŸ“ˆ RÂ²: " + equation.rSquared.toFixed(3));

        } catch (e) {
            console.log("âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø©: " + e);
        }

        return equation;
    }

    // ==================== Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø§Ù„Ø³ÙŠØºÙ…ÙˆÙŠØ¯ ====================

    function extractSigmoidParameters(x: number[], y: number[]): SigmoidParameters {
        let params = new SigmoidParameters();

        try {
            // ØªÙ‚Ø¯ÙŠØ± Ø§Ù„Ø³Ø¹Ø©
            let yMin = Math.min(...y);
            let yMax = Math.max(...y);
            params.alpha = (yMax - yMin) / 2.0;

            // ØªÙ‚Ø¯ÙŠØ± Ø§Ù„Ø¥Ø²Ø§Ø­Ø© Ø§Ù„Ø£ÙÙ‚ÙŠØ©
            let yMean = (yMin + yMax) / 2.0;
            let closestIdx = 0;
            let minDiff = Math.abs(y[0] - yMean);
            for (let i = 1; i < y.length; i++) {
                let diff = Math.abs(y[i] - yMean);
                if (diff < minDiff) {
                    minDiff = diff;
                    closestIdx = i;
                }
            }
            params.x0 = x[closestIdx];

            // ØªÙ‚Ø¯ÙŠØ± Ø§Ù„Ø§Ù†Ø­Ø¯Ø§Ø± Ù…Ù† Ø§Ù„Ù…Ø´ØªÙ‚Ø©
            let slopes: number[] = [];
            for (let i = 1; i < x.length; i++) {
                let dy = y[i] - y[i - 1];
                let dx = x[i] - x[i - 1];
                if (Math.abs(dx) > 1e-10) {
                    slopes.push(Math.abs(dy / dx));
                }
            }

            if (slopes.length > 0) {
                let maxSlope = Math.max(...slopes);
                params.k = maxSlope / (params.alpha + 1e-10);
            }

            // ØªØ­Ø³ÙŠÙ† Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø§Øª
            params = this.refineSigmoidParameters(x, y, params);

        } catch (e) {
            console.log("âš ï¸ Ø®Ø·Ø£ ÙÙŠ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø§Ù„Ø³ÙŠØºÙ…ÙˆÙŠØ¯: " + e);
        }

        return params;
    }

    // ==================== Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø§Ù„Ø®Ø· Ø§Ù„Ù…Ø³ØªÙ‚ÙŠÙ… ====================

    function extractLinearParameters(x: number[], y: number[]): LinearParameters {
        let params = new LinearParameters();

        try {
            // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…Ø±Ø¨Ø¹Ø§Øª Ø§Ù„ØµØºØ±Ù‰
            let n = x.length;
            let sumX = x.reduce((a, b) => a + b, 0);
            let sumY = y.reduce((a, b) => a + b, 0);
            let sumXY = 0.0;
            let sumX2 = 0.0;

            for (let i = 0; i < n; i++) {
                sumXY += x[i] * y[i];
                sumX2 += x[i] * x[i];
            }

            let denominator = n * sumX2 - sumX * sumX;
            if (Math.abs(denominator) > 1e-10) {
                params.beta = (n * sumXY - sumX * sumY) / denominator;
                params.gamma = (sumY - params.beta * sumX) / n;
            }

        } catch (e) {
            console.log("âš ï¸ Ø®Ø·Ø£ ÙÙŠ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø§Ù„Ø®Ø· Ø§Ù„Ù…Ø³ØªÙ‚ÙŠÙ…: " + e);
        }

        return params;
    }



    // ==================== ØªØ­Ø³ÙŠÙ† Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø§Ù„Ø³ÙŠØºÙ…ÙˆÙŠØ¯ ====================

    function refineSigmoidParameters(x: number[], y: number[], params: SigmoidParameters): SigmoidParameters {
        try {
            for (let iter = 0; iter < this.maxIterations; iter++) {
                // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ù…ØªÙ†Ø¨Ø£ Ø¨Ù‡Ø§
                let yPred = this.sigmoidFunction(x, params);

                // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø®Ø·Ø£
                let error: number[] = [];
                let mse = 0.0;
                for (let i = 0; i < y.length; i++) {
                    error.push(y[i] - yPred[i]);
                    mse += error[i] * error[i];
                }
                mse /= y.length;

                // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø§Øª
                let gradAlpha = 0.0;
                let gradK = 0.0;
                let gradX0 = 0.0;

                for (let i = 0; i < y.length; i++) {
                    gradAlpha += error[i] * this.sigmoidDerivativeAlpha(x[i], params);
                    gradK += error[i] * this.sigmoidDerivativeK(x[i], params);
                    gradX0 += error[i] * this.sigmoidDerivativeX0(x[i], params);
                }

                gradAlpha /= y.length;
                gradK /= y.length;
                gradX0 /= y.length;

                params.alpha += this.learningRate * gradAlpha;
                params.k += this.learningRate * gradK;
                params.x0 += this.learningRate * gradX0;

                if (mse < this.convergenceThreshold) {
                    break;
                }
            }
        } catch (e) {
            console.log("âš ï¸ Ø®Ø·Ø£ ÙÙŠ ØªØ­Ø³ÙŠÙ† Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø§Ù„Ø³ÙŠØºÙ…ÙˆÙŠØ¯: " + e);
        }

        return params;
    }

    // ==================== Ø¯Ø§Ù„Ø© Ø§Ù„Ø³ÙŠØºÙ…ÙˆÙŠØ¯ ====================

    function sigmoidFunction(x: number[], params: SigmoidParameters): number[] {
        let result: number[] = [];

        try {
            for (let i = 0; i < x.length; i++) {
                let quantizedX = params.n > 0 ? Math.round(x[i] * params.n) / params.n : x[i];
                let expTerm = Math.exp(-params.k * (quantizedX - params.x0));
                result.push(params.alpha / (1 + expTerm));
            }
        } catch (e) {
            result = new Array(x.length).fill(0);
        }

        return result;
    }

    // ==================== Ù…Ø´ØªÙ‚Ø§Øª Ø§Ù„Ø³ÙŠØºÙ…ÙˆÙŠØ¯ ====================

    function sigmoidDerivativeAlpha(x: number, params: SigmoidParameters): number {
        try {
            let quantizedX = params.n > 0 ? Math.round(x * params.n) / params.n : x;
            let expTerm = Math.exp(-params.k * (quantizedX - params.x0));
            return 1 / (1 + expTerm);
        } catch (e) {
            return 0.0;
        }
    }

    function sigmoidDerivativeK(x: number, params: SigmoidParameters): number {
        try {
            let quantizedX = params.n > 0 ? Math.round(x * params.n) / params.n : x;
            let expTerm = Math.exp(-params.k * (quantizedX - params.x0));
            let sigmoid = params.alpha / (1 + expTerm);
            return sigmoid * (1 - sigmoid / params.alpha) * (quantizedX - params.x0);
        } catch (e) {
            return 0.0;
        }
    }

    function sigmoidDerivativeX0(x: number, params: SigmoidParameters): number {
        try {
            let quantizedX = params.n > 0 ? Math.round(x * params.n) / params.n : x;
            let expTerm = Math.exp(-params.k * (quantizedX - params.x0));
            let sigmoid = params.alpha / (1 + expTerm);
            return sigmoid * (1 - sigmoid / params.alpha) * params.k;
        } catch (e) {
            return 0.0;
        }
    }

    // ==================== ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£ÙˆØ²Ø§Ù† ====================

    function optimizeWeights(x: number[], y: number[],
                            sigmoidParams: SigmoidParameters,
                            linearParams: LinearParameters): object {
        try {
            // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
            let ySigmoid = this.sigmoidFunction(x, sigmoidParams);
            let yLinear: number[] = [];
            for (let i = 0; i < x.length; i++) {
                yLinear.push(linearParams.beta * x[i] + linearParams.gamma);
            }

            let errorSigmoid = 0.0;
            let errorLinear = 0.0;
            for (let i = 0; i < y.length; i++) {
                errorSigmoid += Math.pow(y[i] - ySigmoid[i], 2);
                errorLinear += Math.pow(y[i] - yLinear[i], 2);
            }
            errorSigmoid /= y.length;
            errorLinear /= y.length;

            // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø£ÙˆØ²Ø§Ù† Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
            let totalError = errorSigmoid + errorLinear + 1e-10;
            let sigmoidWeight = 1.0 - (errorSigmoid / totalError);
            let linearWeight = 1.0 - (errorLinear / totalError);

            // ØªØ·Ø¨ÙŠØ¹ Ø§Ù„Ø£ÙˆØ²Ø§Ù†
            let totalWeight = sigmoidWeight + linearWeight;
            sigmoidWeight /= totalWeight;
            linearWeight /= totalWeight;

            return { sigmoid: sigmoidWeight, linear: linearWeight };

        } catch (e) {
            console.log("âš ï¸ Ø®Ø·Ø£ ÙÙŠ ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£ÙˆØ²Ø§Ù†: " + e);
            return { sigmoid: 0.5, linear: 0.5 };
        }
    }

    // ==================== ØªÙ‚ÙŠÙŠÙ… Ø¬ÙˆØ¯Ø© Ø§Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬ ====================

    function evaluateFit(x: number[], y: number[],
                        sigmoidParams: SigmoidParameters,
                        linearParams: LinearParameters,
                        sigmoidWeight: number,
                        linearWeight: number): object {
        try {
            // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ù…ØªÙ†Ø¨Ø£ Ø¨Ù‡Ø§
            let ySigmoid = this.sigmoidFunction(x, sigmoidParams);
            let yPred: number[] = [];

            for (let i = 0; i < x.length; i++) {
                let yLinear = linearParams.beta * x[i] + linearParams.gamma;
                yPred.push(sigmoidWeight * ySigmoid[i] + linearWeight * yLinear);
            }

            // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
            let residuals: number[] = [];
            let ssRes = 0.0;
            for (let i = 0; i < y.length; i++) {
                let residual = y[i] - yPred[i];
                residuals.push(residual);
                ssRes += residual * residual;
            }

            let residualError = Math.sqrt(ssRes / y.length);

            // Ø­Ø³Ø§Ø¨ RÂ²
            let yMean = y.reduce((a, b) => a + b, 0) / y.length;
            let ssTot = 0.0;
            for (let i = 0; i < y.length; i++) {
                ssTot += Math.pow(y[i] - yMean, 2);
            }

            let rSquared = 1.0 - (ssRes / (ssTot + 1e-10));

            // Ø­Ø³Ø§Ø¨ Ø¬ÙˆØ¯Ø© Ø§Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬
            let fitQuality = Math.max(0.0, Math.min(1.0, rSquared));

            return {
                fitQuality: fitQuality,
                residualError: residualError,
                rSquared: rSquared
            };

        } catch (e) {
            console.log("âš ï¸ Ø®Ø·Ø£ ÙÙŠ ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬: " + e);
            return {
                fitQuality: 0.0,
                residualError: Infinity,
                rSquared: 0.0
            };
        }
    }

    // ==================== ØªÙˆÙ„ÙŠØ¯ Ù†Øµ Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø© ====================

    function generateEquationString(sigmoidParams: SigmoidParameters,
                                    linearParams: LinearParameters,
                                    sigmoidWeight: number,
                                    linearWeight: number): string {
        try {
            let equation = "y = ";

            if (sigmoidWeight > 0.01) {
                equation += sigmoidWeight.toFixed(2) + " Ã— Sigmoid(";
                equation += "Î±=" + sigmoidParams.alpha.toFixed(2) + ", ";
                equation += "k=" + sigmoidParams.k.toFixed(2) + ", ";
                equation += "xâ‚€=" + sigmoidParams.x0.toFixed(2) + ")";
            }

            if (linearWeight > 0.01) {
                if (sigmoidWeight > 0.01) {
                    equation += " + ";
                }
                equation += linearWeight.toFixed(2) + " Ã— (";
                equation += linearParams.beta.toFixed(2) + "Ã—x + ";
                equation += linearParams.gamma.toFixed(2) + ")";
            }

            return equation;

        } catch (e) {
            console.log("âš ï¸ Ø®Ø·Ø£ ÙÙŠ ØªÙˆÙ„ÙŠØ¯ Ù†Øµ Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø©: " + e);
            return "Ù…Ø¹Ø§Ø¯Ù„Ø© Ù…ØªÙƒÙŠÙØ©";
        }
    }

    // ==================== ØªÙƒÙŠÙ Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø© ====================

    function adaptEquation(equation: ExtractedEquation,
                          newX: number[], newY: number[]): ExtractedEquation {
        try {
            console.log("ğŸ”„ ØªÙƒÙŠÙ Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø© Ù…Ø¹ Ø¨ÙŠØ§Ù†Ø§Øª Ø¬Ø¯ÙŠØ¯Ø©...");

            // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ø¹Ø§Ø¯Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
            let newEquation = this.extractEquation(newX, newY);

            // Ø¯Ù…Ø¬ Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„ØªÙŠÙ† Ø¨Ø£ÙˆØ²Ø§Ù†
            let adaptedEquation = new ExtractedEquation();

            // Ù…ØªÙˆØ³Ø· Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø§Øª
            adaptedEquation.sigmoidParams.alpha = (equation.sigmoidParams.alpha + newEquation.sigmoidParams.alpha) / 2;
            adaptedEquation.sigmoidParams.k = (equation.sigmoidParams.k + newEquation.sigmoidParams.k) / 2;
            adaptedEquation.sigmoidParams.x0 = (equation.sigmoidParams.x0 + newEquation.sigmoidParams.x0) / 2;

            adaptedEquation.linearParams.beta = (equation.linearParams.beta + newEquation.linearParams.beta) / 2;
            adaptedEquation.linearParams.gamma = (equation.linearParams.gamma + newEquation.linearParams.gamma) / 2;

            // Ù…ØªÙˆØ³Ø· Ø§Ù„Ø£ÙˆØ²Ø§Ù†
            adaptedEquation.sigmoidWeight = (equation.sigmoidWeight + newEquation.sigmoidWeight) / 2;
            adaptedEquation.linearWeight = (equation.linearWeight + newEquation.linearWeight) / 2;

            // Ø¥Ø¹Ø§Ø¯Ø© ØªÙ‚ÙŠÙŠÙ…
            let quality = this.evaluateFit(newX, newY, adaptedEquation.sigmoidParams, adaptedEquation.linearParams,
                                          adaptedEquation.sigmoidWeight, adaptedEquation.linearWeight);
            adaptedEquation.fitQuality = quality.fitQuality;
            adaptedEquation.residualError = quality.residualError;
            adaptedEquation.rSquared = quality.rSquared;

            adaptedEquation.equationString = this.generateEquationString(
                adaptedEquation.sigmoidParams, adaptedEquation.linearParams,
                adaptedEquation.sigmoidWeight, adaptedEquation.linearWeight
            );

            console.log("âœ… ØªÙ… ØªÙƒÙŠÙ Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø© Ø¨Ù†Ø¬Ø§Ø­");

            return adaptedEquation;

        } catch (e) {
            console.log("âŒ Ø®Ø·Ø£ ÙÙŠ ØªÙƒÙŠÙ Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø©: " + e);
            return equation;
        }
    }
}

// ==================== Ø§Ù„ØªØµØ¯ÙŠØ± ====================

export { EquationType, SigmoidParameters, LinearParameters, ExtractedEquation, AdaptiveEquationExtractor };
