#!/usr/bin/env bayan
/**
 * Ù†Ø¸Ø§Ù… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø¹Ø§Ø¬Ù… Ø§Ù„Ø±Ù‚Ù…ÙŠØ© - Digital Lexicon Loader
 * Ù†Ø¸Ø§Ù… Ø¨ØµÙŠØ±Ø© Ø§Ù„Ø«ÙˆØ±ÙŠ
 * 
 * ğŸ“š ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø¹Ø§Ø¬Ù… Ø§Ù„Ø±Ù‚Ù…ÙŠØ© Ù…Ù† Ù…ØµØ§Ø¯Ø± Ù…Ø®ØªÙ„ÙØ©
 * ğŸ” Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„ÙƒÙ„Ù…Ø§Øª ÙˆØ§Ù„Ù…Ø¹Ø§Ù†ÙŠ
 * ğŸ§  ØªÙƒØ§Ù…Ù„ Ù…Ø¹ Ù†Ø¸Ø§Ù… Ø³ÙŠÙ…Ø§Ø¡ Ø§Ù„Ø­Ø±ÙˆÙ
 * âš¡ Ø¯Ø¹Ù… Ù„ØºØ§Øª Ù…ØªØ¹Ø¯Ø¯Ø©
 * 
 * Ø§Ù„Ù…Ø·ÙˆØ±: Ø¨Ø§Ø³Ù„ ÙŠØ­ÙŠÙ‰ Ø¹Ø¨Ø¯Ø§Ù„Ù„Ù‡
 * Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£ÙÙƒØ§Ø± ÙˆØ§Ù„Ù†Ø¸Ø±ÙŠØ§Øª Ù…Ù† Ø¥Ø¨Ø¯Ø§Ø¹ Ø¨Ø§Ø³Ù„ ÙŠØ­ÙŠÙ‰ Ø¹Ø¨Ø¯Ø§Ù„Ù„Ù‡
 */

import { MotherEquation } from "../core/mother-equation.bn";

// ==================== Ø§Ù„ØªØ¹Ø¯Ø§Ø¯Ø§Øª ====================

enum LexiconSource {
    MANUAL = "ÙŠØ¯ÙˆÙŠ",           // Ø¥Ø¯Ø®Ø§Ù„ ÙŠØ¯ÙˆÙŠ
    FILE = "Ù…Ù„Ù",              // Ù…Ù† Ù…Ù„Ù
    DATABASE = "Ù‚Ø§Ø¹Ø¯Ø©_Ø¨ÙŠØ§Ù†Ø§Øª",  // Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª
    INTERNET = "Ø¥Ù†ØªØ±Ù†Øª",        // Ù…Ù† Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª
    EXTRACTED = "Ù…Ø³ØªØ®Ø±Ø¬",       // Ù…Ø³ØªØ®Ø±Ø¬ Ù…Ù† Ù†ØµÙˆØµ
    ARRAMOOZ = "Ø§Ù„Ø±Ø§Ù…ÙˆØ²"        // Ù…Ø¹Ø¬Ù… Ø§Ù„Ø±Ø§Ù…ÙˆØ²
}

enum PartOfSpeech {
    NOUN = "Ø§Ø³Ù…",
    VERB = "ÙØ¹Ù„",
    ADJECTIVE = "ØµÙØ©",
    ADVERB = "Ø¸Ø±Ù",
    PRONOUN = "Ø¶Ù…ÙŠØ±",
    PREPOSITION = "Ø­Ø±Ù_Ø¬Ø±",
    CONJUNCTION = "Ø­Ø±Ù_Ø¹Ø·Ù",
    PARTICLE = "Ø£Ø¯Ø§Ø©",
    UNKNOWN = "ØºÙŠØ±_Ù…Ø¹Ø±ÙˆÙ"
}

enum Language {
    ARABIC = "ar",
    ENGLISH = "en",
    FRENCH = "fr",
    SPANISH = "es",
    GERMAN = "de",
    MIXED = "mixed"
}

// ==================== Ø§Ù„ÙØ¦Ø§Øª ====================

class LexiconEntry extends MotherEquation {
    public word: string;
    public meaning: string;
    public partOfSpeech: PartOfSpeech;
    public root: string;
    public frequency: number;
    public source: LexiconSource;
    public language: Language;
    public metadata: object;
    
    constructor(
        word: string,
        meaning: string,
        partOfSpeech: PartOfSpeech = PartOfSpeech.UNKNOWN,
        root: string = "",
        source: LexiconSource = LexiconSource.MANUAL,
        language: Language = Language.ARABIC
    ) {
        super(`lexicon_entry_${word}`);
        
        this.word = word;
        this.meaning = meaning;
        this.partOfSpeech = partOfSpeech;
        this.root = root;
        this.frequency = 1;
        this.source = source;
        this.language = language;
        this.metadata = {};
        
        // Î¦: Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø«Ø§Ø¨ØªØ©
        this.fixedProperties = {
            word: word,
            root: root,
            language: language,
            source: source
        };
        
        // Î¨: Ø§Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©
        this.dynamicStates = {
            meaning: meaning,
            frequency: 1,
            partOfSpeech: partOfSpeech,
            lastAccessed: Date.now()
        };
    }
    
    public incrementFrequency(): void {
        this.frequency++;
        this.dynamicStates.frequency = this.frequency;
        this.dynamicStates.lastAccessed = Date.now();
    }
    
    public updateMeaning(newMeaning: string): void {
        this.meaning = newMeaning;
        this.dynamicStates.meaning = newMeaning;
    }
    
    public addMetadata(key: string, value: any): void {
        this.metadata[key] = value;
    }
    
    public toJSON(): object {
        return {
            word: this.word,
            meaning: this.meaning,
            partOfSpeech: this.partOfSpeech,
            root: this.root,
            frequency: this.frequency,
            source: this.source,
            language: this.language,
            metadata: this.metadata
        };
    }
}

class CharacterMeaning extends MotherEquation {
    public character: string;
    public meanings: Array<{meaning: string, strength: number}>;
    public relatedWords: Array<string>;
    public frequency: number;
    public confidence: number;
    
    constructor(character: string) {
        super(`char_meaning_${character}`);
        
        this.character = character;
        this.meanings = [];
        this.relatedWords = [];
        this.frequency = 0;
        this.confidence = 0.0;
        
        // Î¦: Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø«Ø§Ø¨ØªØ©
        this.fixedProperties = {
            character: character
        };
        
        // Î¨: Ø§Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©
        this.dynamicStates = {
            meanings: [],
            frequency: 0,
            confidence: 0.0,
            lastUpdated: Date.now()
        };
    }
    
    public addMeaning(meaning: string, strength: number): void {
        this.meanings.push({ meaning, strength });
        this.dynamicStates.meanings = this.meanings;
        this.dynamicStates.lastUpdated = Date.now();
    }
    
    public addRelatedWord(word: string): void {
        if (!this.relatedWords.includes(word)) {
            this.relatedWords.push(word);
        }
    }
    
    public updateConfidence(confidence: number): void {
        this.confidence = confidence;
        this.dynamicStates.confidence = confidence;
    }
    
    public getTopMeanings(topN: number = 5): Array<{meaning: string, strength: number}> {
        return this.meanings
            .sort((a, b) => b.strength - a.strength)
            .slice(0, topN);
    }
}

class DigitalLexiconLoader extends MotherEquation {
    public lexicon: Map<string, LexiconEntry>;
    public characterMeanings: Map<string, CharacterMeaning>;
    public wordGroups: Map<string, Array<string>>;
    public statistics: object;
    
    constructor(loaderId: string = "lexicon_loader_1") {
        super(loaderId);
        
        this.lexicon = new Map();
        this.characterMeanings = new Map();
        this.wordGroups = new Map();
        this.statistics = {
            totalWords: 0,
            totalCharacters: 0,
            languages: new Set(),
            sources: {}
        };
        
        // Î¦: Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø«Ø§Ø¨ØªØ©
        this.fixedProperties = {
            loaderId: loaderId,
            createdAt: Date.now()
        };
        
        // Î¨: Ø§Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©
        this.dynamicStates = {
            totalWords: 0,
            totalCharacters: 0,
            lastUpdate: Date.now()
        };
    }
    
    public addWord(
        word: string,
        meaning: string,
        partOfSpeech: PartOfSpeech = PartOfSpeech.UNKNOWN,
        root: string = "",
        source: LexiconSource = LexiconSource.MANUAL,
        language: Language = Language.ARABIC,
        metadata: object = {}
    ): boolean {
        // ØªØ¬Ø§Ù‡Ù„ Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù‚ØµÙŠØ±Ø© Ø¬Ø¯Ø§Ù‹
        if (!word || word.length < 1) {
            return false;
        }
        
        // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„ÙƒÙ„Ù…Ø© Ù…ÙˆØ¬ÙˆØ¯Ø©ØŒ Ø²ÙŠØ§Ø¯Ø© Ø§Ù„ØªÙƒØ±Ø§Ø±
        if (this.lexicon.has(word)) {
            this.lexicon.get(word).incrementFrequency();
            return false;
        }
        
        // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¯Ø®Ù„ Ø¬Ø¯ÙŠØ¯
        let entry = new LexiconEntry(word, meaning, partOfSpeech, root, source, language);
        
        // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙˆØµÙÙŠØ©
        for (let key in metadata) {
            entry.addMetadata(key, metadata[key]);
        }
        
        this.lexicon.set(word, entry);
        
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
        this.statistics.totalWords++;
        this.statistics.languages.add(language);
        
        if (!this.statistics.sources[source]) {
            this.statistics.sources[source] = 0;
        }
        this.statistics.sources[source]++;
        
        this.dynamicStates.totalWords = this.statistics.totalWords;
        this.dynamicStates.lastUpdate = Date.now();
        
        return true;
    }
    
    public loadFromDict(
        data: object,
        source: LexiconSource = LexiconSource.MANUAL,
        language: Language = Language.ARABIC
    ): number {
        let count = 0;
        for (let word in data) {
            if (this.addWord(word, data[word], PartOfSpeech.UNKNOWN, "", source, language)) {
                count++;
            }
        }
        return count;
    }
    
    public getWord(word: string): LexiconEntry | null {
        return this.lexicon.get(word) || null;
    }
    
    public searchWords(pattern: string): Array<string> {
        let results = [];
        for (let [word, entry] of this.lexicon) {
            if (word.includes(pattern)) {
                results.push(word);
            }
        }
        return results;
    }
    
    public getWordsByCharacter(char: string): Array<string> {
        let results = [];
        for (let [word, entry] of this.lexicon) {
            if (word.includes(char)) {
                results.push(word);
            }
        }
        return results;
    }
    
    public getCharacterFrequency(): Map<string, number> {
        let freq = new Map();
        for (let [word, entry] of this.lexicon) {
            let uniqueChars = new Set(word.split(''));
            for (let char of uniqueChars) {
                freq.set(char, (freq.get(char) || 0) + 1);
            }
        }
        return freq;
    }
    
    public getStatistics(): object {
        let avgWordLength = 0;
        if (this.lexicon.size > 0) {
            let totalLength = 0;
            for (let [word, entry] of this.lexicon) {
                totalLength += word.length;
            }
            avgWordLength = totalLength / this.lexicon.size;
        }
        
        return {
            totalWords: this.statistics.totalWords,
            totalCharacters: this.characterMeanings.size,
            languages: Array.from(this.statistics.languages),
            sources: this.statistics.sources,
            averageWordLength: avgWordLength
        };
    }
    
    public exportToJSON(): object {
        let data = {};
        for (let [word, entry] of this.lexicon) {
            data[word] = entry.meaning;
        }
        return data;
    }
    
    public clear(): void {
        this.lexicon.clear();
        this.characterMeanings.clear();
        this.wordGroups.clear();
        this.statistics = {
            totalWords: 0,
            totalCharacters: 0,
            languages: new Set(),
            sources: {}
        };
        this.dynamicStates.totalWords = 0;
        this.dynamicStates.totalCharacters = 0;
        this.dynamicStates.lastUpdate = Date.now();
    }
}

export { 
    LexiconSource, 
    PartOfSpeech, 
    Language,
    LexiconEntry, 
    CharacterMeaning, 
    DigitalLexiconLoader 
};

