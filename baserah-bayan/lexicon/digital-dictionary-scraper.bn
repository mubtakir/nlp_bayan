#!/usr/bin/env bayan
/**
 * Ù†Ø¸Ø§Ù… Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù…Ø¹Ø§Ù†ÙŠ Ù…Ù† Ø§Ù„Ù‚ÙˆØ§Ù…ÙŠØ³ Ø§Ù„Ø±Ù‚Ù…ÙŠØ© - Digital Dictionary Scraper
 * Ù†Ø¸Ø§Ù… Ø¨ØµÙŠØ±Ø© Ø§Ù„Ø«ÙˆØ±ÙŠ
 * 
 * ğŸŒ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù…Ø¹Ø§Ù†ÙŠ Ù…Ù† almaany.com ÙˆÙ‚ÙˆØ§Ù…ÙŠØ³ Ø£Ø®Ø±Ù‰
 * ğŸ” Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† ÙƒÙ„Ù…Ø§Øª ØªØ´ØªØ±Ùƒ ÙÙŠ Ø­Ø±Ù
 * ğŸ§  Ø¥ÙŠØ¬Ø§Ø¯ Ø§Ù„Ù…Ø¹Ù†Ù‰ Ø§Ù„Ø¹Ø§Ù… Ù…Ù† Ø§Ù„Ø­Ø±Ù Ø§Ù„Ù…Ø´ØªØ±Ùƒ
 * ğŸ’¾ Ø­ÙØ¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
 * 
 * Ø§Ù„Ù…Ø·ÙˆØ±: Ø¨Ø§Ø³Ù„ ÙŠØ­ÙŠÙ‰ Ø¹Ø¨Ø¯Ø§Ù„Ù„Ù‡
 * Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£ÙÙƒØ§Ø± ÙˆØ§Ù„Ù†Ø¸Ø±ÙŠØ§Øª Ù…Ù† Ø¥Ø¨Ø¯Ø§Ø¹ Ø¨Ø§Ø³Ù„ ÙŠØ­ÙŠÙ‰ Ø¹Ø¨Ø¯Ø§Ù„Ù„Ù‡
 */

import { MotherEquation } from "../core/mother-equation.bn";
import { DictionaryDatabaseManager } from "./dictionary-database-manager.bn";

// ==================== Ø§Ù„ØªØ¹Ø¯Ø§Ø¯Ø§Øª ====================

enum DictionarySource {
    ALMAANY = "Ø§Ù„Ù…Ø¹Ø§Ù†ÙŠ",
    ALQAMOOS = "Ø§Ù„Ù‚Ø§Ù…ÙˆØ³",
    LISAAN_ALARAB = "Ù„Ø³Ø§Ù†_Ø§Ù„Ø¹Ø±Ø¨",
    ARRAMOOZ = "Ø§Ù„Ø±Ø§Ù…ÙˆØ²",
    CUSTOM = "Ù…Ø®ØµØµ",
    OFFLINE = "ØºÙŠØ±_Ù…ØªØµÙ„"
}

enum ScrapingStatus {
    IDLE = "Ø®Ø§Ù…Ù„",
    SCRAPING = "ÙŠØ³ØªØ®Ø±Ø¬",
    SUCCESS = "Ù†Ø¬Ø­",
    FAILED = "ÙØ´Ù„",
    RATE_LIMITED = "Ù…Ø­Ø¯ÙˆØ¯",
    TIMEOUT = "Ø§Ù†ØªÙ‡Øª_Ø§Ù„Ù…Ù‡Ù„Ø©"
}

enum WordType {
    NOUN = "Ø§Ø³Ù…",
    VERB = "ÙØ¹Ù„",
    ADJECTIVE = "ØµÙØ©",
    ADVERB = "Ø¸Ø±Ù",
    MIXED = "Ù…Ø®ØªÙ„Ø·",
    UNKNOWN = "ØºÙŠØ±_Ù…Ø¹Ø±ÙˆÙ"
}

// ==================== Ø§Ù„ÙØ¦Ø§Øª ====================

class WordMeaning extends MotherEquation {
    public word: string;
    public meaning: string;
    public sharedLetter: string;
    public generalMeaning: string;
    public source: DictionarySource;
    public wordType: WordType;
    public timestamp: number;
    public confidence: number;
    
    constructor(
        word: string,
        meaning: string,
        source: DictionarySource = DictionarySource.OFFLINE
    ) {
        super(`word_meaning_${word}`);
        
        this.word = word;
        this.meaning = meaning;
        this.sharedLetter = "";
        this.generalMeaning = "";
        this.source = source;
        this.wordType = WordType.UNKNOWN;
        this.timestamp = Date.now();
        this.confidence = 0.0;
        
        // Î¦: Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø«Ø§Ø¨ØªØ©
        this.fixedProperties = {
            word: word,
            source: source
        };
        
        // Î¨: Ø§Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©
        this.dynamicStates = {
            meaning: meaning,
            confidence: 0.0,
            timestamp: this.timestamp
        };
    }
    
    public setSharedLetter(letter: string, generalMeaning: string): void {
        this.sharedLetter = letter;
        this.generalMeaning = generalMeaning;
    }
    
    public setWordType(wordType: WordType): void {
        this.wordType = wordType;
    }
    
    public setConfidence(confidence: number): void {
        this.confidence = confidence;
        this.dynamicStates.confidence = confidence;
    }
}

class ScrapingResult extends MotherEquation {
    public word: string;
    public status: ScrapingStatus;
    public meaning: string;
    public source: DictionarySource;
    public errorMessage: string;
    public timestamp: number;
    public responseTime: number;
    
    constructor(word: string, source: DictionarySource) {
        super(`scraping_result_${word}_${Date.now()}`);
        
        this.word = word;
        this.status = ScrapingStatus.IDLE;
        this.meaning = "";
        this.source = source;
        this.errorMessage = "";
        this.timestamp = Date.now();
        this.responseTime = 0;
        
        // Î¦: Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø«Ø§Ø¨ØªØ©
        this.fixedProperties = {
            word: word,
            source: source,
            startTime: Date.now()
        };
        
        // Î¨: Ø§Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©
        this.dynamicStates = {
            status: ScrapingStatus.IDLE,
            responseTime: 0
        };
    }
    
    public setSuccess(meaning: string, responseTime: number): void {
        this.status = ScrapingStatus.SUCCESS;
        this.meaning = meaning;
        this.responseTime = responseTime;
        this.dynamicStates.status = ScrapingStatus.SUCCESS;
        this.dynamicStates.responseTime = responseTime;
    }
    
    public setFailed(errorMessage: string): void {
        this.status = ScrapingStatus.FAILED;
        this.errorMessage = errorMessage;
        this.dynamicStates.status = ScrapingStatus.FAILED;
    }
}

class DigitalDictionaryScraper extends MotherEquation {
    public dbManager: DictionaryDatabaseManager;
    public scrapingHistory: Array<ScrapingResult>;
    public rateLimitDelay: number;
    public maxRetries: number;
    public timeout: number;
    public userAgent: string;
    public lastScrapeTime: number;
    
    constructor(dbPath: string = "databases/digital_dictionary.db") {
        super("dict_scraper");
        
        this.dbManager = new DictionaryDatabaseManager(dbPath);
        this.scrapingHistory = [];
        this.rateLimitDelay = 1000; // 1 Ø«Ø§Ù†ÙŠØ© Ø¨ÙŠÙ† Ø§Ù„Ø·Ù„Ø¨Ø§Øª
        this.maxRetries = 3;
        this.timeout = 10000; // 10 Ø«ÙˆØ§Ù†ÙŠ
        this.userAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36";
        this.lastScrapeTime = 0;
        
        // Î¦: Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø«Ø§Ø¨ØªØ©
        this.fixedProperties = {
            createdAt: Date.now(),
            userAgent: this.userAgent
        };
        
        // Î¨: Ø§Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©
        this.dynamicStates = {
            totalScraped: 0,
            successCount: 0,
            failedCount: 0,
            lastScrapeTime: 0
        };
    }
    
    public async scrapeAlmaany(word: string): Promise<string | null> {
        // Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ù† Ø§Ù„Ù…Ø¹Ø§Ù†ÙŠ (ÙÙŠ Ø§Ù„ÙˆØ§Ù‚Ø¹ ÙŠØ­ØªØ§Ø¬ fetch API)
        // Ù‡Ù†Ø§ Ù†Ø³ØªØ®Ø¯Ù… Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­Ù„ÙŠØ©
        
        let startTime = Date.now();
        let result = new ScrapingResult(word, DictionarySource.ALMAANY);
        
        try {
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªØ£Ø®ÙŠØ±
            let now = Date.now();
            if (now - this.lastScrapeTime < this.rateLimitDelay) {
                await this._sleep(this.rateLimitDelay - (now - this.lastScrapeTime));
            }
            
            // Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­Ù„ÙŠØ© Ø£ÙˆÙ„Ø§Ù‹
            let entry = this.dbManager.searchWord(word);
            if (entry) {
                let responseTime = Date.now() - startTime;
                result.setSuccess(entry.meaning, responseTime);
                this.scrapingHistory.push(result);
                this.lastScrapeTime = Date.now();
                this.dynamicStates.successCount++;
                this.dynamicStates.totalScraped++;
                this.dynamicStates.lastScrapeTime = this.lastScrapeTime;
                return entry.meaning;
            }
            
            // ÙÙŠ Ø­Ø§Ù„Ø© Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ Ø§Ù„ÙƒÙ„Ù…Ø©
            result.setFailed("Ø§Ù„ÙƒÙ„Ù…Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø© ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­Ù„ÙŠØ©");
            this.scrapingHistory.push(result);
            this.dynamicStates.failedCount++;
            this.dynamicStates.totalScraped++;
            
            return null;
            
        } catch (error) {
            result.setFailed(error.toString());
            this.scrapingHistory.push(result);
            this.dynamicStates.failedCount++;
            this.dynamicStates.totalScraped++;
            return null;
        }
    }
    
    private async _sleep(ms: number): Promise<void> {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    public async scrapeMultipleWords(words: Array<string>): Promise<Map<string, string>> {
        let results = new Map();
        
        for (let word of words) {
            let meaning = await this.scrapeAlmaany(word);
            if (meaning) {
                results.set(word, meaning);
            }
        }
        
        return results;
    }
    
    public findWordsWithSharedLetter(letter: string, minWords: number = 3): Array<string> {
        let words = this.dbManager.searchByCharacter(letter);
        let wordList = words.map(entry => entry.word);
        
        if (wordList.length >= minWords) {
            return wordList;
        }
        
        return [];
    }
    
    public extractGeneralMeaning(letter: string, words: Array<string>): string {
        // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù…Ø¹Ù†Ù‰ Ø§Ù„Ø¹Ø§Ù… Ù…Ù† Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…Ø´ØªØ±ÙƒØ©
        let meanings = [];
        
        for (let word of words) {
            let entry = this.dbManager.searchWord(word);
            if (entry) {
                meanings.push(entry.meaning);
            }
        }
        
        if (meanings.length === 0) {
            return "";
        }
        
        // ØªØ­Ù„ÙŠÙ„ Ø¨Ø³ÙŠØ·: Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…Ø´ØªØ±ÙƒØ© ÙÙŠ Ø§Ù„Ù…Ø¹Ø§Ù†ÙŠ
        let allWords = meanings.join(' ').split(/\s+/);
        let wordFreq = new Map();
        
        for (let word of allWords) {
            if (word.length > 2) {
                wordFreq.set(word, (wordFreq.get(word) || 0) + 1);
            }
        }
        
        // Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ø£ÙƒØ«Ø± ØªÙƒØ±Ø§Ø±Ø§Ù‹
        let sorted = Array.from(wordFreq.entries())
            .sort((a, b) => b[1] - a[1])
            .slice(0, 3);
        
        return sorted.map(([word, freq]) => word).join('ØŒ ');
    }

    public analyzeCharacterMeanings(letter: string): object {
        let words = this.findWordsWithSharedLetter(letter, 3);

        if (words.length === 0) {
            return {
                letter: letter,
                totalWords: 0,
                generalMeaning: "",
                confidence: 0.0,
                words: []
            };
        }

        let generalMeaning = this.extractGeneralMeaning(letter, words);
        let confidence = Math.min(words.length / 10, 1.0); // ÙƒÙ„Ù…Ø§ Ø²Ø§Ø¯Øª Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø²Ø§Ø¯Øª Ø§Ù„Ø«Ù‚Ø©

        return {
            letter: letter,
            totalWords: words.length,
            generalMeaning: generalMeaning,
            confidence: confidence,
            words: words.slice(0, 10) // Ø£ÙˆÙ„ 10 ÙƒÙ„Ù…Ø§Øª
        };
    }

    public saveCharacterMeaning(letter: string, generalMeaning: string, words: Array<string>): boolean {
        // Ø­ÙØ¸ Ù…Ø¹Ù†Ù‰ Ø§Ù„Ø­Ø±Ù ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        // ÙŠÙ…ÙƒÙ† ØªÙˆØ³ÙŠØ¹ Ù‡Ø°Ø§ Ù„Ø­ÙØ¸ ÙÙŠ Ø¬Ø¯ÙˆÙ„ Ù…Ù†ÙØµÙ„

        for (let word of words) {
            let entry = this.dbManager.searchWord(word);
            if (entry) {
                entry.addSharedLetter(letter);
                entry.addGeneralMeaning(letter, generalMeaning);
            }
        }

        return true;
    }

    public batchAnalyzeCharacters(letters: Array<string>): Map<string, object> {
        let results = new Map();

        for (let letter of letters) {
            let analysis = this.analyzeCharacterMeanings(letter);
            results.set(letter, analysis);

            // Ø­ÙØ¸ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø«Ù‚Ø© Ø¹Ø§Ù„ÙŠØ©
            if (analysis.confidence >= 0.5) {
                this.saveCharacterMeaning(letter, analysis.generalMeaning, analysis.words);
            }
        }

        return results;
    }

    public getScrapingStatistics(): object {
        let totalTime = 0;
        let successCount = 0;
        let failedCount = 0;

        for (let result of this.scrapingHistory) {
            totalTime += result.responseTime;
            if (result.status === ScrapingStatus.SUCCESS) {
                successCount++;
            } else if (result.status === ScrapingStatus.FAILED) {
                failedCount++;
            }
        }

        let avgResponseTime = this.scrapingHistory.length > 0
            ? totalTime / this.scrapingHistory.length
            : 0;

        return {
            totalScraped: this.scrapingHistory.length,
            successCount: successCount,
            failedCount: failedCount,
            successRate: this.scrapingHistory.length > 0
                ? (successCount / this.scrapingHistory.length) * 100
                : 0,
            averageResponseTime: avgResponseTime,
            lastScrapeTime: this.lastScrapeTime
        };
    }

    public clearHistory(): void {
        this.scrapingHistory = [];
        this.dynamicStates.totalScraped = 0;
        this.dynamicStates.successCount = 0;
        this.dynamicStates.failedCount = 0;
    }

    public exportResults(): object {
        let data = {
            statistics: this.getScrapingStatistics(),
            history: this.scrapingHistory.map(result => ({
                word: result.word,
                status: result.status,
                meaning: result.meaning,
                source: result.source,
                responseTime: result.responseTime,
                timestamp: result.timestamp
            }))
        };

        return data;
    }
}

export {
    DictionarySource,
    ScrapingStatus,
    WordType,
    WordMeaning,
    ScrapingResult,
    DigitalDictionaryScraper
};

