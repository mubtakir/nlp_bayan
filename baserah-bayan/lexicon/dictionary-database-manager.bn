#!/usr/bin/env bayan
/**
 * Ù†Ø¸Ø§Ù… Ø¥Ø¯Ø§Ø±Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø¹Ø¬Ù… - Dictionary Database Manager
 * Ù†Ø¸Ø§Ù… Ø¨ØµÙŠØ±Ø© Ø§Ù„Ø«ÙˆØ±ÙŠ
 * 
 * ğŸ’¾ Ø¥Ø¯Ø§Ø±Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø¹Ø¬Ù… Ø§Ù„Ø±Ù‚Ù…ÙŠ
 * ğŸ” Ø§Ù„Ø¨Ø­Ø« ÙˆØ§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ù…ØªÙ‚Ø¯Ù…
 * ğŸ“Š Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª ÙˆØ§Ù„ØªÙ‚Ø§Ø±ÙŠØ±
 * ğŸ”„ Ø§Ù„ØªØ­Ø¯ÙŠØ« ÙˆØ§Ù„Ø­Ø°Ù
 * 
 * Ø§Ù„Ù…Ø·ÙˆØ±: Ø¨Ø§Ø³Ù„ ÙŠØ­ÙŠÙ‰ Ø¹Ø¨Ø¯Ø§Ù„Ù„Ù‡
 * Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£ÙÙƒØ§Ø± ÙˆØ§Ù„Ù†Ø¸Ø±ÙŠØ§Øª Ù…Ù† Ø¥Ø¨Ø¯Ø§Ø¹ Ø¨Ø§Ø³Ù„ ÙŠØ­ÙŠÙ‰ Ø¹Ø¨Ø¯Ø§Ù„Ù„Ù‡
 */

import { MotherEquation } from "../core/mother-equation.bn";
import { LexiconEntry, LexiconSource } from "./digital-lexicon-loader.bn";
import { CharacterAnalysis } from "./character-meaning-extractor.bn";

// ==================== Ø§Ù„ØªØ¹Ø¯Ø§Ø¯Ø§Øª ====================

enum DatabaseOperation {
    INSERT = "Ø¥Ø¯Ø±Ø§Ø¬",
    UPDATE = "ØªØ­Ø¯ÙŠØ«",
    DELETE = "Ø­Ø°Ù",
    SELECT = "Ø§Ø³ØªØ¹Ù„Ø§Ù…",
    SEARCH = "Ø¨Ø­Ø«"
}

enum SearchType {
    EXACT = "Ù…Ø·Ø§Ø¨Ù‚_ØªÙ…Ø§Ù…Ø§Ù‹",
    CONTAINS = "ÙŠØ­ØªÙˆÙŠ",
    STARTS_WITH = "ÙŠØ¨Ø¯Ø£_Ø¨Ù€",
    ENDS_WITH = "ÙŠÙ†ØªÙ‡ÙŠ_Ø¨Ù€",
    PATTERN = "Ù†Ù…Ø·",
    REGEX = "ØªØ¹Ø¨ÙŠØ±_Ù†Ù…Ø·ÙŠ"
}

enum SortOrder {
    ASC = "ØªØµØ§Ø¹Ø¯ÙŠ",
    DESC = "ØªÙ†Ø§Ø²Ù„ÙŠ"
}

// ==================== Ø§Ù„ÙØ¦Ø§Øª ====================

class DatabaseEntry extends MotherEquation {
    public id: number;
    public word: string;
    public meaning: string;
    public sharedLetters: Array<string>;
    public generalMeanings: object;
    public source: string;
    public timestamp: number;
    
    constructor(
        id: number,
        word: string,
        meaning: string,
        source: string = "manual",
        sharedLetters: Array<string> = [],
        generalMeanings: object = {}
    ) {
        super(`db_entry_${id}`);
        
        this.id = id;
        this.word = word;
        this.meaning = meaning;
        this.sharedLetters = sharedLetters;
        this.generalMeanings = generalMeanings;
        this.source = source;
        this.timestamp = Date.now();
        
        // Î¦: Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø«Ø§Ø¨ØªØ©
        this.fixedProperties = {
            id: id,
            word: word,
            source: source
        };
        
        // Î¨: Ø§Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©
        this.dynamicStates = {
            meaning: meaning,
            timestamp: this.timestamp
        };
    }
    
    public updateMeaning(newMeaning: string): void {
        this.meaning = newMeaning;
        this.timestamp = Date.now();
        this.dynamicStates.meaning = newMeaning;
        this.dynamicStates.timestamp = this.timestamp;
    }
    
    public addSharedLetter(letter: string): void {
        if (!this.sharedLetters.includes(letter)) {
            this.sharedLetters.push(letter);
        }
    }
    
    public addGeneralMeaning(letter: string, meaning: string): void {
        this.generalMeanings[letter] = meaning;
    }
}

class SearchQuery extends MotherEquation {
    public searchTerm: string;
    public searchType: SearchType;
    public filters: object;
    public sortBy: string;
    public sortOrder: SortOrder;
    public limit: number;
    public offset: number;
    
    constructor(
        searchTerm: string,
        searchType: SearchType = SearchType.CONTAINS
    ) {
        super(`search_query_${Date.now()}`);
        
        this.searchTerm = searchTerm;
        this.searchType = searchType;
        this.filters = {};
        this.sortBy = "word";
        this.sortOrder = SortOrder.ASC;
        this.limit = 100;
        this.offset = 0;
        
        // Î¦: Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø«Ø§Ø¨ØªØ©
        this.fixedProperties = {
            searchTerm: searchTerm,
            searchType: searchType
        };
        
        // Î¨: Ø§Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©
        this.dynamicStates = {
            limit: 100,
            offset: 0
        };
    }
    
    public addFilter(key: string, value: any): void {
        this.filters[key] = value;
    }
    
    public setSort(sortBy: string, sortOrder: SortOrder = SortOrder.ASC): void {
        this.sortBy = sortBy;
        this.sortOrder = sortOrder;
    }
    
    public setPagination(limit: number, offset: number = 0): void {
        this.limit = limit;
        this.offset = offset;
        this.dynamicStates.limit = limit;
        this.dynamicStates.offset = offset;
    }
}

class DatabaseStatistics extends MotherEquation {
    public totalWords: number;
    public totalCharacters: number;
    public totalSources: number;
    public averageWordLength: number;
    public mostCommonCharacters: Array<{char: string, count: number}>;
    public sourceDistribution: object;
    
    constructor() {
        super(`db_stats_${Date.now()}`);
        
        this.totalWords = 0;
        this.totalCharacters = 0;
        this.totalSources = 0;
        this.averageWordLength = 0;
        this.mostCommonCharacters = [];
        this.sourceDistribution = {};
        
        // Î¦: Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø«Ø§Ø¨ØªØ©
        this.fixedProperties = {
            createdAt: Date.now()
        };
        
        // Î¨: Ø§Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©
        this.dynamicStates = {
            totalWords: 0,
            totalCharacters: 0,
            lastUpdated: Date.now()
        };
    }
    
    public update(data: object): void {
        for (let key in data) {
            if (this.hasOwnProperty(key)) {
                this[key] = data[key];
            }
        }
        this.dynamicStates.lastUpdated = Date.now();
    }
}

class DictionaryDatabaseManager extends MotherEquation {
    public dbPath: string;
    public entries: Map<number, DatabaseEntry>;
    public wordIndex: Map<string, number>;
    public characterIndex: Map<string, Array<number>>;
    public statistics: DatabaseStatistics;
    public lastOperation: DatabaseOperation | null;
    
    constructor(dbPath: string = "databases/digital_dictionary.db") {
        super("dict_db_manager");
        
        this.dbPath = dbPath;
        this.entries = new Map();
        this.wordIndex = new Map();
        this.characterIndex = new Map();
        this.statistics = new DatabaseStatistics();
        this.lastOperation = null;
        
        // Î¦: Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø«Ø§Ø¨ØªØ©
        this.fixedProperties = {
            dbPath: dbPath,
            createdAt: Date.now()
        };
        
        // Î¨: Ø§Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©
        this.dynamicStates = {
            totalEntries: 0,
            lastOperation: null,
            lastUpdate: Date.now()
        };
    }
    
    public insertWord(
        word: string,
        meaning: string,
        source: string = "manual",
        sharedLetters: Array<string> = [],
        generalMeanings: object = {}
    ): number {
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„ÙƒÙ„Ù…Ø©
        if (this.wordIndex.has(word)) {
            return -1; // Ø§Ù„ÙƒÙ„Ù…Ø© Ù…ÙˆØ¬ÙˆØ¯Ø© Ø¨Ø§Ù„ÙØ¹Ù„
        }
        
        let id = this.entries.size + 1;
        let entry = new DatabaseEntry(id, word, meaning, source, sharedLetters, generalMeanings);
        
        this.entries.set(id, entry);
        this.wordIndex.set(word, id);
        
        // ØªØ­Ø¯ÙŠØ« ÙÙ‡Ø±Ø³ Ø§Ù„Ø­Ø±ÙˆÙ
        let uniqueChars = new Set(word.split(''));
        for (let char of uniqueChars) {
            if (!this.characterIndex.has(char)) {
                this.characterIndex.set(char, []);
            }
            this.characterIndex.get(char).push(id);
        }
        
        this.lastOperation = DatabaseOperation.INSERT;
        this.dynamicStates.totalEntries = this.entries.size;
        this.dynamicStates.lastOperation = DatabaseOperation.INSERT;
        this.dynamicStates.lastUpdate = Date.now();
        
        return id;
    }
    
    public searchWord(word: string): DatabaseEntry | null {
        let id = this.wordIndex.get(word);
        if (id === undefined) {
            return null;
        }
        
        this.lastOperation = DatabaseOperation.SELECT;
        this.dynamicStates.lastOperation = DatabaseOperation.SELECT;
        
        return this.entries.get(id) || null;
    }
    
    public searchByPattern(pattern: string, searchType: SearchType = SearchType.CONTAINS): Array<DatabaseEntry> {
        let results = [];
        
        for (let [word, id] of this.wordIndex) {
            let match = false;
            
            switch (searchType) {
                case SearchType.EXACT:
                    match = word === pattern;
                    break;
                case SearchType.CONTAINS:
                    match = word.includes(pattern);
                    break;
                case SearchType.STARTS_WITH:
                    match = word.startsWith(pattern);
                    break;
                case SearchType.ENDS_WITH:
                    match = word.endsWith(pattern);
                    break;
                case SearchType.PATTERN:
                    // Ù†Ù…Ø· Ø¨Ø³ÙŠØ·: % = Ø£ÙŠ Ø´ÙŠØ¡ØŒ _ = Ø­Ø±Ù ÙˆØ§Ø­Ø¯
                    let regex = pattern.replace(/%/g, '.*').replace(/_/g, '.');
                    match = new RegExp(`^${regex}$`).test(word);
                    break;
            }
            
            if (match) {
                let entry = this.entries.get(id);
                if (entry) {
                    results.push(entry);
                }
            }
        }
        
        this.lastOperation = DatabaseOperation.SEARCH;
        this.dynamicStates.lastOperation = DatabaseOperation.SEARCH;
        
        return results;
    }

    public searchByCharacter(char: string): Array<DatabaseEntry> {
        let results = [];
        let ids = this.characterIndex.get(char) || [];

        for (let id of ids) {
            let entry = this.entries.get(id);
            if (entry) {
                results.push(entry);
            }
        }

        this.lastOperation = DatabaseOperation.SEARCH;
        this.dynamicStates.lastOperation = DatabaseOperation.SEARCH;

        return results;
    }

    public searchBySharedCharacters(chars: Array<string>): Array<DatabaseEntry> {
        if (chars.length === 0) {
            return [];
        }

        // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„ØªÙŠ ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø±ÙˆÙ
        let firstChar = chars[0];
        let candidates = this.searchByCharacter(firstChar);

        let results = candidates.filter(entry => {
            for (let char of chars) {
                if (!entry.word.includes(char)) {
                    return false;
                }
            }
            return true;
        });

        return results;
    }

    public updateWord(word: string, newMeaning: string): boolean {
        let id = this.wordIndex.get(word);
        if (id === undefined) {
            return false;
        }

        let entry = this.entries.get(id);
        if (entry) {
            entry.updateMeaning(newMeaning);
            this.lastOperation = DatabaseOperation.UPDATE;
            this.dynamicStates.lastOperation = DatabaseOperation.UPDATE;
            this.dynamicStates.lastUpdate = Date.now();
            return true;
        }

        return false;
    }

    public deleteWord(word: string): boolean {
        let id = this.wordIndex.get(word);
        if (id === undefined) {
            return false;
        }

        let entry = this.entries.get(id);
        if (entry) {
            // Ø­Ø°Ù Ù…Ù† Ø§Ù„ÙÙ‡Ø§Ø±Ø³
            this.entries.delete(id);
            this.wordIndex.delete(word);

            // Ø­Ø°Ù Ù…Ù† ÙÙ‡Ø±Ø³ Ø§Ù„Ø­Ø±ÙˆÙ
            let uniqueChars = new Set(word.split(''));
            for (let char of uniqueChars) {
                let ids = this.characterIndex.get(char) || [];
                this.characterIndex.set(char, ids.filter(i => i !== id));
            }

            this.lastOperation = DatabaseOperation.DELETE;
            this.dynamicStates.totalEntries = this.entries.size;
            this.dynamicStates.lastOperation = DatabaseOperation.DELETE;
            this.dynamicStates.lastUpdate = Date.now();

            return true;
        }

        return false;
    }

    public calculateStatistics(): DatabaseStatistics {
        this.statistics.totalWords = this.entries.size;
        this.statistics.totalCharacters = this.characterIndex.size;

        // Ø­Ø³Ø§Ø¨ Ù…ØªÙˆØ³Ø· Ø·ÙˆÙ„ Ø§Ù„ÙƒÙ„Ù…Ø©
        let totalLength = 0;
        let sources = new Map();

        for (let [id, entry] of this.entries) {
            totalLength += entry.word.length;
            sources.set(entry.source, (sources.get(entry.source) || 0) + 1);
        }

        this.statistics.averageWordLength = this.entries.size > 0
            ? totalLength / this.entries.size
            : 0;

        this.statistics.totalSources = sources.size;
        this.statistics.sourceDistribution = Object.fromEntries(sources);

        // Ø£ÙƒØ«Ø± Ø§Ù„Ø­Ø±ÙˆÙ Ø´ÙŠÙˆØ¹Ø§Ù‹
        let charCounts = [];
        for (let [char, ids] of this.characterIndex) {
            charCounts.push({ char, count: ids.length });
        }
        charCounts.sort((a, b) => b.count - a.count);
        this.statistics.mostCommonCharacters = charCounts.slice(0, 10);

        this.statistics.update({
            totalWords: this.statistics.totalWords,
            totalCharacters: this.statistics.totalCharacters
        });

        return this.statistics;
    }

    public getStatistics(): object {
        return {
            totalWords: this.entries.size,
            totalCharacters: this.characterIndex.size,
            totalSources: this.statistics.totalSources,
            averageWordLength: this.statistics.averageWordLength,
            mostCommonCharacters: this.statistics.mostCommonCharacters.slice(0, 5),
            sourceDistribution: this.statistics.sourceDistribution
        };
    }

    public exportToJSON(): object {
        let data = {};
        for (let [id, entry] of this.entries) {
            data[entry.word] = {
                meaning: entry.meaning,
                source: entry.source,
                sharedLetters: entry.sharedLetters,
                generalMeanings: entry.generalMeanings,
                timestamp: entry.timestamp
            };
        }
        return data;
    }

    public importFromJSON(data: object): number {
        let count = 0;
        for (let word in data) {
            let item = data[word];
            let id = this.insertWord(
                word,
                item.meaning || "",
                item.source || "imported",
                item.sharedLetters || [],
                item.generalMeanings || {}
            );
            if (id > 0) {
                count++;
            }
        }
        return count;
    }

    public clear(): void {
        this.entries.clear();
        this.wordIndex.clear();
        this.characterIndex.clear();
        this.statistics = new DatabaseStatistics();
        this.lastOperation = null;
        this.dynamicStates.totalEntries = 0;
        this.dynamicStates.lastOperation = null;
        this.dynamicStates.lastUpdate = Date.now();
    }

    public executeQuery(query: SearchQuery): Array<DatabaseEntry> {
        let results = this.searchByPattern(query.searchTerm, query.searchType);

        // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ÙÙ„Ø§ØªØ±
        if (Object.keys(query.filters).length > 0) {
            results = results.filter(entry => {
                for (let key in query.filters) {
                    if (entry[key] !== query.filters[key]) {
                        return false;
                    }
                }
                return true;
            });
        }

        // Ø§Ù„ØªØ±ØªÙŠØ¨
        if (query.sortBy) {
            results.sort((a, b) => {
                let aVal = a[query.sortBy];
                let bVal = b[query.sortBy];

                if (query.sortOrder === SortOrder.ASC) {
                    return aVal > bVal ? 1 : -1;
                } else {
                    return aVal < bVal ? 1 : -1;
                }
            });
        }

        // Ø§Ù„ØªÙ‚Ø³ÙŠÙ… Ø¥Ù„Ù‰ ØµÙØ­Ø§Øª
        return results.slice(query.offset, query.offset + query.limit);
    }
}

export {
    DatabaseOperation,
    SearchType,
    SortOrder,
    DatabaseEntry,
    SearchQuery,
    DatabaseStatistics,
    DictionaryDatabaseManager
};

