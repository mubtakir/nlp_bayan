#!/usr/bin/env bayan
/**
 * Ù†Ø¸Ø§Ù… Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ø¹Ø§Ù†ÙŠ Ø§Ù„Ø­Ø±ÙˆÙ - Character Meaning Extractor
 * Ù†Ø¸Ø§Ù… Ø¨ØµÙŠØ±Ø© Ø§Ù„Ø«ÙˆØ±ÙŠ
 * 
 * ğŸ”¤ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ø¹Ø§Ù†ÙŠ Ø§Ù„Ø­Ø±ÙˆÙ Ù…Ù† Ø§Ù„Ù…Ø¹Ø¬Ù…
 * ğŸ§¬ ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªØ´Ø§Ø¨Ù‡ Ø¨ÙŠÙ† Ø§Ù„ÙƒÙ„Ù…Ø§Øª
 * âš¡ Ø­Ø³Ø§Ø¨ Ù‚ÙˆØ© Ø§Ù„Ù…Ø¹Ø§Ù†ÙŠ
 * ğŸ¯ ØªÙƒØ§Ù…Ù„ Ù…Ø¹ Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ø³ÙŠÙ…Ø§Ø¡ Ø§Ù„Ø­Ø±ÙˆÙ
 * 
 * Ø§Ù„Ù…Ø·ÙˆØ±: Ø¨Ø§Ø³Ù„ ÙŠØ­ÙŠÙ‰ Ø¹Ø¨Ø¯Ø§Ù„Ù„Ù‡
 * Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£ÙÙƒØ§Ø± ÙˆØ§Ù„Ù†Ø¸Ø±ÙŠØ§Øª Ù…Ù† Ø¥Ø¨Ø¯Ø§Ø¹ Ø¨Ø§Ø³Ù„ ÙŠØ­ÙŠÙ‰ Ø¹Ø¨Ø¯Ø§Ù„Ù„Ù‡
 */

import { MotherEquation } from "../core/mother-equation.bn";
import { LexiconEntry, CharacterMeaning } from "./digital-lexicon-loader.bn";

// ==================== Ø§Ù„ØªØ¹Ø¯Ø§Ø¯Ø§Øª ====================

enum ExtractionMethod {
    SINGLE_CHARACTER = "Ø­Ø±Ù_ÙˆØ§Ø­Ø¯",           // ÙƒÙ„Ù…Ø§Øª ØªØ´ØªØ±Ùƒ ÙÙŠ Ø­Ø±Ù ÙˆØ§Ø­Ø¯
    TWO_CONSECUTIVE = "Ø­Ø±ÙØ§Ù†_Ù…ØªØªØ§Ø¨Ø¹Ø§Ù†",      // Ø­Ø±ÙØ§Ù† Ù…ØªØªØ§Ø¨Ø¹Ø§Ù†
    TWO_WITH_GAP = "Ø­Ø±ÙØ§Ù†_Ø¨ÙŠÙ†Ù‡Ù…Ø§_Ø­Ø±Ù",      // Ø­Ø±ÙØ§Ù† Ø¨ÙŠÙ†Ù‡Ù…Ø§ Ø­Ø±Ù
    THREE_CHARACTERS = "Ø«Ù„Ø§Ø«Ø©_Ø£Ø­Ø±Ù",         // Ø«Ù„Ø§Ø«Ø© Ø£Ø­Ø±Ù Ù…Ø´ØªØ±ÙƒØ©
    ROOT_BASED = "Ø¬Ø°Ø±_Ù„ØºÙˆÙŠ",                 // Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø¬Ø°Ø± Ø§Ù„Ù„ØºÙˆÙŠ
    PATTERN_BASED = "Ù†Ù…Ø·_Ù„ØºÙˆÙŠ"               // Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù†Ù…Ø·
}

enum AnalysisQuality {
    LOW = "Ù…Ù†Ø®ÙØ¶Ø©",
    MEDIUM = "Ù…ØªÙˆØ³Ø·Ø©",
    HIGH = "Ø¹Ø§Ù„ÙŠØ©",
    EXCELLENT = "Ù…Ù…ØªØ§Ø²Ø©"
}

// ==================== Ø§Ù„ÙØ¦Ø§Øª ====================

class CharacterAnalysis extends MotherEquation {
    public character: string;
    public totalWords: number;
    public totalMeanings: number;
    public meaningScores: Map<string, number>;
    public relatedWords: Array<string>;
    public confidence: number;
    public extractionMethods: Array<ExtractionMethod>;
    
    constructor(character: string) {
        super(`char_analysis_${character}`);
        
        this.character = character;
        this.totalWords = 0;
        this.totalMeanings = 0;
        this.meaningScores = new Map();
        this.relatedWords = [];
        this.confidence = 0.0;
        this.extractionMethods = [];
        
        // Î¦: Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø«Ø§Ø¨ØªØ©
        this.fixedProperties = {
            character: character
        };
        
        // Î¨: Ø§Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©
        this.dynamicStates = {
            totalWords: 0,
            totalMeanings: 0,
            confidence: 0.0,
            lastAnalyzed: Date.now()
        };
    }
    
    public addMeaning(meaning: string, score: number, method: ExtractionMethod): void {
        if (!this.meaningScores.has(meaning)) {
            this.meaningScores.set(meaning, 0);
        }
        this.meaningScores.set(meaning, this.meaningScores.get(meaning) + score);
        
        if (!this.extractionMethods.includes(method)) {
            this.extractionMethods.push(method);
        }
        
        this.totalMeanings = this.meaningScores.size;
        this.dynamicStates.totalMeanings = this.totalMeanings;
        this.dynamicStates.lastAnalyzed = Date.now();
    }
    
    public addRelatedWord(word: string): void {
        if (!this.relatedWords.includes(word)) {
            this.relatedWords.push(word);
            this.totalWords = this.relatedWords.length;
            this.dynamicStates.totalWords = this.totalWords;
        }
    }
    
    public calculateConfidence(): void {
        if (this.meaningScores.size === 0) {
            this.confidence = 0.0;
            return;
        }
        
        let totalScore = 0;
        for (let [meaning, score] of this.meaningScores) {
            totalScore += score;
        }
        
        this.confidence = totalScore / this.meaningScores.size;
        this.dynamicStates.confidence = this.confidence;
    }
    
    public getTopMeanings(topN: number = 5): Array<{meaning: string, score: number}> {
        let sorted = Array.from(this.meaningScores.entries())
            .map(([meaning, score]) => ({ meaning, score }))
            .sort((a, b) => b.score - a.score);
        
        return sorted.slice(0, topN);
    }
    
    public getQuality(): AnalysisQuality {
        if (this.confidence >= 0.8 && this.totalWords >= 10) {
            return AnalysisQuality.EXCELLENT;
        } else if (this.confidence >= 0.6 && this.totalWords >= 5) {
            return AnalysisQuality.HIGH;
        } else if (this.confidence >= 0.4 && this.totalWords >= 3) {
            return AnalysisQuality.MEDIUM;
        } else {
            return AnalysisQuality.LOW;
        }
    }
}

class WordGroup extends MotherEquation {
    public sharedCharacters: Array<string>;
    public words: Array<string>;
    public commonMeanings: Array<{meaning: string, frequency: number}>;
    public groupStrength: number;
    
    constructor(sharedChars: Array<string>, words: Array<string>) {
        super(`word_group_${sharedChars.join('_')}`);
        
        this.sharedCharacters = sharedChars;
        this.words = words;
        this.commonMeanings = [];
        this.groupStrength = 0.0;
        
        // Î¦: Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø«Ø§Ø¨ØªØ©
        this.fixedProperties = {
            sharedCharacters: sharedChars
        };
        
        // Î¨: Ø§Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©
        this.dynamicStates = {
            wordCount: words.length,
            groupStrength: 0.0
        };
    }
    
    public addCommonMeaning(meaning: string, frequency: number): void {
        this.commonMeanings.push({ meaning, frequency });
    }
    
    public calculateStrength(): void {
        if (this.commonMeanings.length === 0) {
            this.groupStrength = 0.0;
            return;
        }
        
        let totalFreq = 0;
        for (let cm of this.commonMeanings) {
            totalFreq += cm.frequency;
        }
        
        this.groupStrength = totalFreq / this.words.length;
        this.dynamicStates.groupStrength = this.groupStrength;
    }
}

class CharacterMeaningExtractor extends MotherEquation {
    public lexicon: Map<string, LexiconEntry>;
    public characterAnalyses: Map<string, CharacterAnalysis>;
    public wordGroups: Array<WordGroup>;
    public commonWords: Set<string>;
    public minFrequency: number;
    
    constructor(extractorId: string = "char_extractor_1") {
        super(extractorId);
        
        this.lexicon = new Map();
        this.characterAnalyses = new Map();
        this.wordGroups = [];
        this.commonWords = this._getCommonWords();
        this.minFrequency = 0.1;
        
        // Î¦: Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø«Ø§Ø¨ØªØ©
        this.fixedProperties = {
            extractorId: extractorId,
            createdAt: Date.now()
        };
        
        // Î¨: Ø§Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©
        this.dynamicStates = {
            totalAnalyses: 0,
            lastExtraction: 0
        };
    }
    
    private _getCommonWords(): Set<string> {
        return new Set([
            'ÙÙŠ', 'Ù…Ù†', 'Ø¹Ù„Ù‰', 'Ø¥Ù„Ù‰', 'Ø£Ù†', 'Ù…Ø§', 'Ù‡Ø°Ø§', 'Ù‡Ø°Ù‡', 'ÙƒØ§Ù†',
            'ÙŠÙƒÙˆÙ†', 'Ø°Ù„Ùƒ', 'ÙƒÙ„', 'Ù…Ø¹', 'Ù‡Ùˆ', 'Ù‡ÙŠ', 'Ù‡Ù…', 'ÙƒØ°Ù„Ùƒ', 'Ø£ÙŠØ¶Ø§',
            'Ùˆ', 'Ø£Ùˆ', 'Ù„Ø§', 'Ù†Ø¹Ù…', 'Ù‡Ù†Ø§', 'Ù‡Ù†Ø§Ùƒ', 'Ù‡Ù†Ø§Ù„Ùƒ', 'Ø­ÙŠØ«', 'ÙƒÙŠÙ',
            'Ù„ÙƒÙ†', 'Ø¨Ù„', 'Ø«Ù…', 'Ø¥Ø°Ø§', 'Ù„Ùˆ', 'Ù‚Ø¯', 'Ù„Ù…', 'Ù„Ù†', 'Ù„ÙŠØ³'
        ]);
    }
    
    public loadLexicon(lexicon: Map<string, LexiconEntry>): number {
        let count = 0;
        for (let [word, entry] of lexicon) {
            if (word.length >= 2 && !this.commonWords.has(word)) {
                this.lexicon.set(word, entry);
                count++;
            }
        }
        return count;
    }
    
    public extractMeaningKeywords(meaning: string): Array<string> {
        // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ø´Ø§Ø¦Ø¹Ø© ÙˆØ§Ù„Ø¹Ù„Ø§Ù…Ø§Øª
        let words = meaning.match(/\b\w+\b/g) || [];
        let filtered = words.filter(w => w.length > 2 && !this.commonWords.has(w));
        return filtered;
    }
    
    public findSharedCharacterGroups(minShared: number = 2): Array<WordGroup> {
        let groups = new Map();
        let words = Array.from(this.lexicon.keys());
        
        for (let i = 0; i < words.length; i++) {
            for (let j = i + 1; j < words.length; j++) {
                let word1 = words[i];
                let word2 = words[j];
                
                let chars1 = new Set(word1.split(''));
                let chars2 = new Set(word2.split(''));
                
                let shared = Array.from(chars1).filter(c => chars2.has(c));
                
                if (shared.length >= minShared) {
                    let key = shared.sort().join('_');
                    if (!groups.has(key)) {
                        groups.set(key, new Set());
                    }
                    groups.get(key).add(word1);
                    groups.get(key).add(word2);
                }
            }
        }
        
        // ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ WordGroup
        let wordGroups = [];
        for (let [key, wordSet] of groups) {
            let sharedChars = key.split('_');
            let wordArray = Array.from(wordSet);
            
            if (wordArray.length >= 3) {
                wordGroups.push(new WordGroup(sharedChars, wordArray));
            }
        }
        
        return wordGroups;
    }
    
    public analyzeSharedMeanings(words: Array<string>): Map<string, number> {
        let allKeywords = [];
        
        for (let word of words) {
            let entry = this.lexicon.get(word);
            if (entry) {
                let keywords = this.extractMeaningKeywords(entry.meaning);
                allKeywords.push(...keywords);
            }
        }
        
        if (allKeywords.length === 0) {
            return new Map();
        }
        
        // Ø­Ø³Ø§Ø¨ Ø§Ù„ØªÙƒØ±Ø§Ø±
        let freq = new Map();
        for (let keyword of allKeywords) {
            freq.set(keyword, (freq.get(keyword) || 0) + 1);
        }
        
        // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù†Ø³Ø¨Ø© Ø§Ù„Ù…Ø¦ÙˆÙŠØ©
        let total = allKeywords.length;
        let scores = new Map();
        for (let [keyword, count] of freq) {
            scores.set(keyword, count / total);
        }
        
        return scores;
    }

    public extractCharacterMeanings(minFrequency: number = 0.1): Map<string, CharacterAnalysis> {
        this.minFrequency = minFrequency;

        // Ø§Ù„Ø®Ø·ÙˆØ© 1: Ø¥ÙŠØ¬Ø§Ø¯ Ù…Ø¬Ù…ÙˆØ¹Ø§Øª Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…ØªØ´Ø§Ø¨Ù‡Ø©
        this.wordGroups = this.findSharedCharacterGroups(2);

        // Ø§Ù„Ø®Ø·ÙˆØ© 2: ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ø¹Ø§Ù†ÙŠ Ø§Ù„Ù…Ø´ØªØ±ÙƒØ©
        for (let group of this.wordGroups) {
            let meanings = this.analyzeSharedMeanings(group.words);

            for (let char of group.sharedCharacters) {
                if (!this.characterAnalyses.has(char)) {
                    this.characterAnalyses.set(char, new CharacterAnalysis(char));
                }

                let analysis = this.characterAnalyses.get(char);

                for (let [meaning, score] of meanings) {
                    analysis.addMeaning(meaning, score, ExtractionMethod.TWO_CONSECUTIVE);
                }

                for (let word of group.words) {
                    analysis.addRelatedWord(word);
                }
            }
        }

        // Ø§Ù„Ø®Ø·ÙˆØ© 3: ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø­Ø±ÙˆÙ Ø§Ù„Ù…ÙØ±Ø¯Ø©
        this._analyzeSingleCharacters();

        // Ø§Ù„Ø®Ø·ÙˆØ© 4: ØªØµÙÙŠØ© Ø§Ù„Ù…Ø¹Ø§Ù†ÙŠ Ø§Ù„Ø¶Ø¹ÙŠÙØ©
        for (let [char, analysis] of this.characterAnalyses) {
            let filtered = new Map();
            for (let [meaning, score] of analysis.meaningScores) {
                if (score >= minFrequency) {
                    filtered.set(meaning, score);
                }
            }
            analysis.meaningScores = filtered;
            analysis.totalMeanings = filtered.size;

            // Ø§Ù„Ø§Ø­ØªÙØ§Ø¸ Ø¨Ø£ÙØ¶Ù„ 20 ÙƒÙ„Ù…Ø©
            analysis.relatedWords = analysis.relatedWords.slice(0, 20);

            // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø«Ù‚Ø©
            analysis.calculateConfidence();
        }

        this.dynamicStates.totalAnalyses = this.characterAnalyses.size;
        this.dynamicStates.lastExtraction = Date.now();

        return this.characterAnalyses;
    }

    private _analyzeSingleCharacters(): void {
        let singleCharGroups = new Map();

        for (let [word, entry] of this.lexicon) {
            let uniqueChars = new Set(word.split(''));
            for (let char of uniqueChars) {
                if (!singleCharGroups.has(char)) {
                    singleCharGroups.set(char, []);
                }
                singleCharGroups.get(char).push(word);
            }
        }

        // ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª
        for (let [char, words] of singleCharGroups) {
            if (words.length >= 2) {
                if (!this.characterAnalyses.has(char)) {
                    this.characterAnalyses.set(char, new CharacterAnalysis(char));
                }

                let analysis = this.characterAnalyses.get(char);
                let meanings = this.analyzeSharedMeanings(words);

                for (let [meaning, score] of meanings) {
                    // ÙˆØ²Ù† Ø£Ù‚Ù„ Ù„Ù„Ø­Ø±ÙˆÙ Ø§Ù„Ù…ÙØ±Ø¯Ø©
                    analysis.addMeaning(meaning, score * 0.5, ExtractionMethod.SINGLE_CHARACTER);
                }

                for (let word of words) {
                    analysis.addRelatedWord(word);
                }
            }
        }
    }

    public getCharacterAnalysis(character: string): CharacterAnalysis | null {
        return this.characterAnalyses.get(character) || null;
    }

    public getTopMeanings(character: string, topN: number = 5): Array<{meaning: string, score: number}> {
        let analysis = this.getCharacterAnalysis(character);
        if (!analysis) {
            return [];
        }
        return analysis.getTopMeanings(topN);
    }

    public getStatistics(): object {
        let totalMeanings = 0;
        let totalConfidence = 0;
        let qualityDistribution = {
            [AnalysisQuality.EXCELLENT]: 0,
            [AnalysisQuality.HIGH]: 0,
            [AnalysisQuality.MEDIUM]: 0,
            [AnalysisQuality.LOW]: 0
        };

        for (let [char, analysis] of this.characterAnalyses) {
            totalMeanings += analysis.totalMeanings;
            totalConfidence += analysis.confidence;
            qualityDistribution[analysis.getQuality()]++;
        }

        let avgMeanings = this.characterAnalyses.size > 0
            ? totalMeanings / this.characterAnalyses.size
            : 0;
        let avgConfidence = this.characterAnalyses.size > 0
            ? totalConfidence / this.characterAnalyses.size
            : 0;

        return {
            totalCharacters: this.characterAnalyses.size,
            totalWords: this.lexicon.size,
            totalWordGroups: this.wordGroups.length,
            averageMeaningsPerChar: avgMeanings,
            averageConfidence: avgConfidence,
            qualityDistribution: qualityDistribution
        };
    }

    public exportAnalyses(): object {
        let data = {};
        for (let [char, analysis] of this.characterAnalyses) {
            data[char] = {
                character: char,
                totalWords: analysis.totalWords,
                totalMeanings: analysis.totalMeanings,
                confidence: analysis.confidence,
                quality: analysis.getQuality(),
                topMeanings: analysis.getTopMeanings(5),
                relatedWords: analysis.relatedWords.slice(0, 10)
            };
        }
        return data;
    }
}

export {
    ExtractionMethod,
    AnalysisQuality,
    CharacterAnalysis,
    WordGroup,
    CharacterMeaningExtractor
};

