/**
 * Ù…Ø­Ø³Ù† Ø§Ù„Ø·Ù„Ø§Ù‚Ø© - Fluency Enhancer
 * 
 * ÙŠØ­Ø³Ù† Ø·Ù„Ø§Ù‚Ø© Ø§Ù„Ù†Øµ Ø§Ù„Ù…ÙˆÙ„Ø¯
 * ÙŠØ¶ÙŠÙ Ø§Ù„Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ù„ØºÙˆÙŠØ©
 * ÙŠØ­Ø³Ù† Ø§Ù„ØªØ¯ÙÙ‚ ÙˆØ§Ù„Ø£Ø³Ù„ÙˆØ¨
 * 
 * @version 1.0.0
 * @author Baserah AI Team
 */

import { MotherEquation } from "../core/mother-equation.bn";
import { WritingStyle } from "./text-generator.bn";

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ø§Ù„ØªØ¹Ø¯Ø§Ø¯Ø§Øª - Enumerations
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Ù†ÙˆØ¹ Ø§Ù„Ø±Ø§Ø¨Ø· Ø§Ù„Ù„ØºÙˆÙŠ
 */
export enum ConnectorType {
    ADDITION = "ADDITION",          // Ø¥Ø¶Ø§ÙØ© (ÙˆØŒ Ø£ÙŠØ¶Ø§Ù‹ØŒ ÙƒØ°Ù„Ùƒ)
    CONTRAST = "CONTRAST",          // ØªØ¨Ø§ÙŠÙ† (Ù„ÙƒÙ†ØŒ Ø¨ÙŠÙ†Ù…Ø§ØŒ Ù…Ø¹ Ø°Ù„Ùƒ)
    CAUSE = "CAUSE",                // Ø³Ø¨Ø¨ (Ù„Ø£Ù†ØŒ Ø¨Ø³Ø¨Ø¨ØŒ Ù†Ø¸Ø±Ø§Ù‹)
    RESULT = "RESULT",              // Ù†ØªÙŠØ¬Ø© (Ù„Ø°Ù„ÙƒØŒ Ø¥Ø°Ù†ØŒ Ø¨Ø§Ù„ØªØ§Ù„ÙŠ)
    SEQUENCE = "SEQUENCE",          // ØªØ³Ù„Ø³Ù„ (Ø«Ù…ØŒ Ø¨Ø¹Ø¯ Ø°Ù„ÙƒØŒ Ø£ÙˆÙ„Ø§Ù‹)
    EXAMPLE = "EXAMPLE",            // Ù…Ø«Ø§Ù„ (Ù…Ø«Ù„Ø§Ù‹ØŒ Ø¹Ù„Ù‰ Ø³Ø¨ÙŠÙ„ Ø§Ù„Ù…Ø«Ø§Ù„)
    EMPHASIS = "EMPHASIS",          // ØªØ£ÙƒÙŠØ¯ (ÙØ¹Ù„Ø§Ù‹ØŒ Ø­Ù‚Ø§Ù‹ØŒ Ø¨Ø§Ù„ØªØ£ÙƒÙŠØ¯)
    CONCLUSION = "CONCLUSION"       // Ø®Ù„Ø§ØµØ© (ÙÙŠ Ø§Ù„Ù†Ù‡Ø§ÙŠØ©ØŒ Ø®Ù„Ø§ØµØ© Ø§Ù„Ù‚ÙˆÙ„)
}

/**
 * Ù†ÙˆØ¹ Ø§Ù„ØªØ­Ø³ÙŠÙ†
 */
export enum EnhancementType {
    CONNECTOR_ADDITION = "CONNECTOR_ADDITION",      // Ø¥Ø¶Ø§ÙØ© Ø±ÙˆØ§Ø¨Ø·
    SENTENCE_RESTRUCTURE = "SENTENCE_RESTRUCTURE",  // Ø¥Ø¹Ø§Ø¯Ø© Ù‡ÙŠÙƒÙ„Ø© Ø§Ù„Ø¬Ù…Ù„
    TONE_ADJUSTMENT = "TONE_ADJUSTMENT",            // Ø¶Ø¨Ø· Ø§Ù„Ù†Ø¨Ø±Ø©
    REDUNDANCY_REMOVAL = "REDUNDANCY_REMOVAL",      // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªÙƒØ±Ø§Ø±
    CLARITY_IMPROVEMENT = "CLARITY_IMPROVEMENT"     // ØªØ­Ø³ÙŠÙ† Ø§Ù„ÙˆØ¶ÙˆØ­
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ø§Ù„ÙØ¦Ø§Øª - Classes
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Ø±Ø§Ø¨Ø· Ù„ØºÙˆÙŠ
 */
export class LinguisticConnector extends MotherEquation {
    type: ConnectorType;
    text: string;
    alternatives: string[];
    usageCount: number;

    constructor(id: string, type: ConnectorType, text: string) {
        super(id);
        this.type = type;
        this.text = text;
        this.alternatives = [];
        this.usageCount = 0;
    }

    /**
     * Ø¥Ø¶Ø§ÙØ© Ø¨Ø¯ÙŠÙ„
     */
    addAlternative(alt: string): void {
        if (!this.alternatives.includes(alt)) {
            this.alternatives.push(alt);
        }
    }

    /**
     * Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø±Ø§Ø¨Ø·
     */
    use(): void {
        this.usageCount++;
    }
}

/**
 * ØªØ­Ø³ÙŠÙ† Ù…Ø·Ø¨Ù‚
 */
export class AppliedEnhancement extends MotherEquation {
    type: EnhancementType;
    originalText: string;
    enhancedText: string;
    position: number;
    confidence: number;

    constructor(
        id: string,
        type: EnhancementType,
        originalText: string,
        enhancedText: string,
        position: number
    ) {
        super(id);
        this.type = type;
        this.originalText = originalText;
        this.enhancedText = enhancedText;
        this.position = position;
        this.confidence = 0.8;
    }
}

/**
 * Ù†ØªÙŠØ¬Ø© Ø§Ù„ØªØ­Ø³ÙŠÙ†
 */
export class EnhancementResult extends MotherEquation {
    originalText: string;
    enhancedText: string;
    appliedEnhancements: AppliedEnhancement[];
    improvementScore: number; // 0-1
    processingTime: number;

    constructor(id: string, originalText: string) {
        super(id);
        this.originalText = originalText;
        this.enhancedText = originalText;
        this.appliedEnhancements = [];
        this.improvementScore = 0;
        this.processingTime = 0;
    }

    /**
     * Ø¥Ø¶Ø§ÙØ© ØªØ­Ø³ÙŠÙ†
     */
    addEnhancement(enhancement: AppliedEnhancement): void {
        this.appliedEnhancements.push(enhancement);
    }

    /**
     * ØªÙˆÙ„ÙŠØ¯ ØªÙ‚Ø±ÙŠØ±
     */
    generateReport(): string {
        let report = "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
        report += "âœ¨ ØªÙ‚Ø±ÙŠØ± ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø·Ù„Ø§Ù‚Ø©\n";
        report += "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";

        report += `ğŸ“ Ø§Ù„Ù†Øµ Ø§Ù„Ø£ØµÙ„ÙŠ:\n"${this.originalText}"\n\n`;
        report += `âœ… Ø§Ù„Ù†Øµ Ø§Ù„Ù…Ø­Ø³Ù†:\n"${this.enhancedText}"\n\n`;

        if (this.appliedEnhancements.length > 0) {
            report += `ğŸ”§ Ø§Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„Ù…Ø·Ø¨Ù‚Ø© (${this.appliedEnhancements.length}):\n`;
            for (let enhancement of this.appliedEnhancements) {
                report += `   - ${enhancement.type}\n`;
                report += `     Ù…Ù†: "${enhancement.originalText}"\n`;
                report += `     Ø¥Ù„Ù‰: "${enhancement.enhancedText}"\n`;
            }
            report += "\n";
        }

        report += `ğŸ“Š Ø¯Ø±Ø¬Ø© Ø§Ù„ØªØ­Ø³ÙŠÙ†: ${(this.improvementScore * 100).toFixed(1)}%\n`;
        report += `â±ï¸ ÙˆÙ‚Øª Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©: ${this.processingTime}ms\n`;

        return report;
    }
}

/**
 * Ù…Ø­Ø³Ù† Ø§Ù„Ø·Ù„Ø§Ù‚Ø© - Fluency Enhancer
 */
export class FluencyEnhancer extends MotherEquation {
    // Ø§Ù„Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ù„ØºÙˆÙŠØ©
    private connectors: Map<ConnectorType, LinguisticConnector[]>;
    
    // Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØ­Ø³ÙŠÙ†
    private enhancementRules: Map<EnhancementType, Function>;
    
    // Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
    private stats: {
        totalEnhancements: number;
        averageImprovement: number;
        enhancementTypeDistribution: Map<EnhancementType, number>;
    };

    constructor(id: string = "fluency-enhancer-001") {
        super(id);
        this.connectors = new Map();
        this.enhancementRules = new Map();
        this.stats = {
            totalEnhancements: 0,
            averageImprovement: 0,
            enhancementTypeDistribution: new Map()
        };
        
        this.initializeConnectors();
        this.initializeEnhancementRules();
    }

    /**
     * ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ù„ØºÙˆÙŠØ©
     */
    private initializeConnectors(): void {
        // Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ø¥Ø¶Ø§ÙØ©
        this.addConnector(ConnectorType.ADDITION, "Ùˆ", ["Ø£ÙŠØ¶Ø§Ù‹", "ÙƒØ°Ù„Ùƒ", "Ø¨Ø§Ù„Ø¥Ø¶Ø§ÙØ© Ø¥Ù„Ù‰ Ø°Ù„Ùƒ", "ÙØ¶Ù„Ø§Ù‹ Ø¹Ù† Ø°Ù„Ùƒ"]);
        
        // Ø±ÙˆØ§Ø¨Ø· Ø§Ù„ØªØ¨Ø§ÙŠÙ†
        this.addConnector(ConnectorType.CONTRAST, "Ù„ÙƒÙ†", ["Ø¨ÙŠÙ†Ù…Ø§", "Ù…Ø¹ Ø°Ù„Ùƒ", "Ø¹Ù„Ù‰ Ø§Ù„Ø±ØºÙ… Ù…Ù† Ø°Ù„Ùƒ", "ÙÙŠ Ø§Ù„Ù…Ù‚Ø§Ø¨Ù„"]);
        
        // Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ø³Ø¨Ø¨
        this.addConnector(ConnectorType.CAUSE, "Ù„Ø£Ù†", ["Ø¨Ø³Ø¨Ø¨", "Ù†Ø¸Ø±Ø§Ù‹ Ù„Ù€", "ÙƒÙˆÙ†", "Ø­ÙŠØ« Ø£Ù†"]);
        
        // Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ù†ØªÙŠØ¬Ø©
        this.addConnector(ConnectorType.RESULT, "Ù„Ø°Ù„Ùƒ", ["Ø¥Ø°Ù†", "Ø¨Ø§Ù„ØªØ§Ù„ÙŠ", "Ù…Ù† Ø«Ù…", "ÙˆØ¹Ù„ÙŠÙ‡"]);
        
        // Ø±ÙˆØ§Ø¨Ø· Ø§Ù„ØªØ³Ù„Ø³Ù„
        this.addConnector(ConnectorType.SEQUENCE, "Ø«Ù…", ["Ø¨Ø¹Ø¯ Ø°Ù„Ùƒ", "Ø£ÙˆÙ„Ø§Ù‹", "Ø«Ø§Ù†ÙŠØ§Ù‹", "Ø£Ø®ÙŠØ±Ø§Ù‹"]);
        
        // Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ù…Ø«Ø§Ù„
        this.addConnector(ConnectorType.EXAMPLE, "Ù…Ø«Ù„Ø§Ù‹", ["Ø¹Ù„Ù‰ Ø³Ø¨ÙŠÙ„ Ø§Ù„Ù…Ø«Ø§Ù„", "ÙƒÙ…Ø«Ø§Ù„ Ø¹Ù„Ù‰ Ø°Ù„Ùƒ", "Ù…Ø«Ù„"]);
        
        // Ø±ÙˆØ§Ø¨Ø· Ø§Ù„ØªØ£ÙƒÙŠØ¯
        this.addConnector(ConnectorType.EMPHASIS, "ÙØ¹Ù„Ø§Ù‹", ["Ø­Ù‚Ø§Ù‹", "Ø¨Ø§Ù„ØªØ£ÙƒÙŠØ¯", "Ø¨Ø§Ù„ÙØ¹Ù„", "Ø­Ù‚ÙŠÙ‚Ø©Ù‹"]);
        
        // Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ø®Ù„Ø§ØµØ©
        this.addConnector(ConnectorType.CONCLUSION, "ÙÙŠ Ø§Ù„Ù†Ù‡Ø§ÙŠØ©", ["Ø®Ù„Ø§ØµØ© Ø§Ù„Ù‚ÙˆÙ„", "Ø¨Ø§Ø®ØªØµØ§Ø±", "ÙÙŠ Ø§Ù„Ø®ØªØ§Ù…"]);
    }

    /**
     * Ø¥Ø¶Ø§ÙØ© Ø±Ø§Ø¨Ø·
     */
    private addConnector(type: ConnectorType, text: string, alternatives: string[]): void {
        let connector = new LinguisticConnector(
            `connector-${type}-${text}`,
            type,
            text
        );
        
        for (let alt of alternatives) {
            connector.addAlternative(alt);
        }

        if (!this.connectors.has(type)) {
            this.connectors.set(type, []);
        }
        
        this.connectors.get(type).push(connector);
    }

    /**
     * ØªÙ‡ÙŠØ¦Ø© Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØ­Ø³ÙŠÙ†
     */
    private initializeEnhancementRules(): void {
        // Ù‚Ø§Ø¹Ø¯Ø© Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø±ÙˆØ§Ø¨Ø·
        this.enhancementRules.set(
            EnhancementType.CONNECTOR_ADDITION,
            (text: string) => this.addConnectors(text)
        );

        // Ù‚Ø§Ø¹Ø¯Ø© Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªÙƒØ±Ø§Ø±
        this.enhancementRules.set(
            EnhancementType.REDUNDANCY_REMOVAL,
            (text: string) => this.removeRedundancy(text)
        );

        // Ù‚Ø§Ø¹Ø¯Ø© ØªØ­Ø³ÙŠÙ† Ø§Ù„ÙˆØ¶ÙˆØ­
        this.enhancementRules.set(
            EnhancementType.CLARITY_IMPROVEMENT,
            (text: string) => this.improveClarity(text)
        );
    }

    /**
     * ØªØ­Ø³ÙŠÙ† Ø§Ù„Ù†Øµ
     */
    enhance(text: string, style: WritingStyle = WritingStyle.FORMAL): EnhancementResult {
        let startTime = Date.now();
        
        let result = new EnhancementResult(
            `enhancement-${Date.now()}`,
            text
        );

        let currentText = text;

        // 1. Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ù„ØºÙˆÙŠØ©
        currentText = this.applyEnhancement(
            result,
            EnhancementType.CONNECTOR_ADDITION,
            currentText
        );

        // 2. Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªÙƒØ±Ø§Ø±
        currentText = this.applyEnhancement(
            result,
            EnhancementType.REDUNDANCY_REMOVAL,
            currentText
        );

        // 3. ØªØ­Ø³ÙŠÙ† Ø§Ù„ÙˆØ¶ÙˆØ­
        currentText = this.applyEnhancement(
            result,
            EnhancementType.CLARITY_IMPROVEMENT,
            currentText
        );

        // 4. Ø¶Ø¨Ø· Ø§Ù„Ù†Ø¨Ø±Ø© Ø­Ø³Ø¨ Ø§Ù„Ø£Ø³Ù„ÙˆØ¨
        currentText = this.adjustTone(currentText, style);

        result.enhancedText = currentText;
        result.improvementScore = this.calculateImprovement(text, currentText);
        result.processingTime = Date.now() - startTime;

        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
        this.updateStats(result);

        return result;
    }

    /**
     * ØªØ·Ø¨ÙŠÙ‚ ØªØ­Ø³ÙŠÙ†
     */
    private applyEnhancement(
        result: EnhancementResult,
        type: EnhancementType,
        text: string
    ): string {
        if (!this.enhancementRules.has(type)) {
            return text;
        }

        let rule = this.enhancementRules.get(type);
        let enhancedText = rule(text);

        if (enhancedText !== text) {
            let enhancement = new AppliedEnhancement(
                `applied-${Date.now()}`,
                type,
                text,
                enhancedText,
                0
            );
            result.addEnhancement(enhancement);
        }

        return enhancedText;
    }

    /**
     * Ø¥Ø¶Ø§ÙØ© Ø±ÙˆØ§Ø¨Ø· Ù„ØºÙˆÙŠØ©
     */
    private addConnectors(text: string): string {
        // Ù…Ù†Ø·Ù‚ Ø¨Ø³ÙŠØ·: Ø¥Ø¶Ø§ÙØ© "Ùˆ" Ø¨ÙŠÙ† Ø§Ù„Ø¬Ù…Ù„ Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù‡Ù†Ø§Ùƒ Ø±Ø§Ø¨Ø·
        let sentences = text.split(". ");
        
        if (sentences.length <= 1) {
            return text;
        }

        let enhanced = sentences[0];
        
        for (let i = 1; i < sentences.length; i++) {
            let sentence = sentences[i].trim();
            
            if (sentence.length === 0) continue;

            // Ø¥Ø°Ø§ Ù„Ù… ØªØ¨Ø¯Ø£ Ø§Ù„Ø¬Ù…Ù„Ø© Ø¨Ø±Ø§Ø¨Ø·ØŒ Ø£Ø¶Ù "Ùˆ"
            if (!this.startsWithConnector(sentence)) {
                enhanced += ". Ùˆ" + sentence;
            } else {
                enhanced += ". " + sentence;
            }
        }

        return enhanced;
    }

    /**
     * Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„Ø¬Ù…Ù„Ø© Ø¨Ø±Ø§Ø¨Ø·
     */
    private startsWithConnector(sentence: string): boolean {
        let commonConnectors = ["Ùˆ", "Ù„ÙƒÙ†", "Ù„Ø°Ù„Ùƒ", "Ø«Ù…", "Ø£ÙŠØ¶Ø§Ù‹", "ÙƒØ°Ù„Ùƒ", "Ø¨ÙŠÙ†Ù…Ø§"];
        
        for (let connector of commonConnectors) {
            if (sentence.startsWith(connector)) {
                return true;
            }
        }
        
        return false;
    }

    /**
     * Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªÙƒØ±Ø§Ø±
     */
    private removeRedundancy(text: string): string {
        // Ù…Ù†Ø·Ù‚ Ø¨Ø³ÙŠØ·: Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…ØªÙƒØ±Ø±Ø© Ø§Ù„Ù…ØªØªØ§Ù„ÙŠØ©
        let words = text.split(" ");
        let filtered: string[] = [];
        
        for (let i = 0; i < words.length; i++) {
            if (i === 0 || words[i] !== words[i - 1]) {
                filtered.push(words[i]);
            }
        }
        
        return filtered.join(" ");
    }

    /**
     * ØªØ­Ø³ÙŠÙ† Ø§Ù„ÙˆØ¶ÙˆØ­
     */
    private improveClarity(text: string): string {
        // Ù…Ù†Ø·Ù‚ Ø¨Ø³ÙŠØ·: Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø¨Ø¹Ø¶ Ø§Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„ØºØ§Ù…Ø¶Ø©
        let replacements: Map<string, string> = new Map([
            ["Ù‡Ø°Ø§ Ø§Ù„Ø´ÙŠØ¡", "Ù‡Ø°Ø§"],
            ["Ø°Ù„Ùƒ Ø§Ù„Ø´ÙŠØ¡", "Ø°Ù„Ùƒ"],
            ["Ø§Ù„Ø´ÙŠØ¡ Ù‡Ø°Ø§", "Ù‡Ø°Ø§"],
            ["Ù…Ù…ÙƒÙ† ÙŠÙƒÙˆÙ†", "Ø±Ø¨Ù…Ø§"],
            ["ÙŠÙ…ÙƒÙ† Ø£Ù† ÙŠÙƒÙˆÙ†", "Ø±Ø¨Ù…Ø§"]
        ]);

        let enhanced = text;
        
        for (let [original, replacement] of replacements) {
            enhanced = enhanced.replace(new RegExp(original, "g"), replacement);
        }
        
        return enhanced;
    }

    /**
     * Ø¶Ø¨Ø· Ø§Ù„Ù†Ø¨Ø±Ø©
     */
    private adjustTone(text: string, style: WritingStyle): string {
        switch (style) {
            case WritingStyle.FORMAL:
                // Ø¥Ø¶Ø§ÙØ© ØµÙŠØº Ø±Ø³Ù…ÙŠØ©
                text = text.replace(/Ø£Ù†Øª/g, "Ø­Ø¶Ø±ØªÙƒ");
                text = text.replace(/Ø´ÙˆÙ/g, "Ø§Ù†Ø¸Ø±");
                break;
                
            case WritingStyle.FRIENDLY:
                // Ø¥Ø¶Ø§ÙØ© ØªØ¹Ø¨ÙŠØ±Ø§Øª ÙˆØ¯ÙŠØ©
                if (!text.includes("ğŸ˜Š") && !text.includes("ğŸ‘‹")) {
                    text = text + " ğŸ˜Š";
                }
                break;
                
            case WritingStyle.CASUAL:
                // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù„ØºØ© Ø¹Ø§Ù…ÙŠØ© Ø®ÙÙŠÙØ©
                text = text.replace(/Ø­Ø¶Ø±ØªÙƒ/g, "Ø£Ù†Øª");
                text = text.replace(/Ø§Ù†Ø¸Ø±/g, "Ø´ÙˆÙ");
                break;
        }
        
        return text;
    }

    /**
     * Ø­Ø³Ø§Ø¨ Ø¯Ø±Ø¬Ø© Ø§Ù„ØªØ­Ø³ÙŠÙ†
     */
    private calculateImprovement(original: string, enhanced: string): number {
        // Ù…Ù†Ø·Ù‚ Ø¨Ø³ÙŠØ·: Ù†Ø³Ø¨Ø© Ø§Ù„ØªØºÙŠÙŠØ±
        if (original === enhanced) {
            return 0;
        }

        let lengthDiff = Math.abs(enhanced.length - original.length);
        let maxLength = Math.max(original.length, enhanced.length);
        
        // Ø¯Ø±Ø¬Ø© Ø§Ù„ØªØ­Ø³ÙŠÙ† ØªØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ Ù…Ù‚Ø¯Ø§Ø± Ø§Ù„ØªØºÙŠÙŠØ±
        let changeRatio = lengthDiff / maxLength;
        
        // Ù†ÙØªØ±Ø¶ Ø£Ù† Ø§Ù„ØªØºÙŠÙŠØ± Ø§Ù„Ù…Ø¹ØªØ¯Ù„ (5-15%) Ù‡Ùˆ Ø§Ù„Ø£ÙØ¶Ù„
        if (changeRatio >= 0.05 && changeRatio <= 0.15) {
            return 0.8;
        } else if (changeRatio < 0.05) {
            return 0.3;
        } else {
            return 0.5;
        }
    }

    /**
     * ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
     */
    private updateStats(result: EnhancementResult): void {
        this.stats.totalEnhancements++;

        // ØªØ­Ø¯ÙŠØ« Ù…ØªÙˆØ³Ø· Ø§Ù„ØªØ­Ø³ÙŠÙ†
        let total = this.stats.averageImprovement * (this.stats.totalEnhancements - 1);
        total += result.improvementScore;
        this.stats.averageImprovement = total / this.stats.totalEnhancements;

        // ØªØ­Ø¯ÙŠØ« ØªÙˆØ²ÙŠØ¹ Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„ØªØ­Ø³ÙŠÙ†
        for (let enhancement of result.appliedEnhancements) {
            let count = this.stats.enhancementTypeDistribution.get(enhancement.type) || 0;
            this.stats.enhancementTypeDistribution.set(enhancement.type, count + 1);
        }
    }

    /**
     * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
     */
    getStats(): any {
        return {
            totalEnhancements: this.stats.totalEnhancements,
            averageImprovement: (this.stats.averageImprovement * 100).toFixed(1) + "%",
            enhancementTypeDistribution: Object.fromEntries(this.stats.enhancementTypeDistribution)
        };
    }
}

