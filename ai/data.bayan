# Data utilities: simple CSV rows and descriptive statistics

# Parse CSV given as list of row strings (no quotes handling, educational)
def parse_csv_rows(rows, delimiter=","):
{
    out = []
    for r in rows:
    {
        fields = []
        cur = ""
        for i in range(len(r)):
        {
            ch = r[i]
            if ch == delimiter:
            {
                fields.append(cur)
                cur = ""
            }
            else:
            {
                cur = cur + ch
            }
        }
        fields.append(cur)
        out.append(fields)
    }
    return out
}

# Convert list of rows (list of list of strings) to list of row strings
def to_csv_rows(rows, delimiter=","):
{
    out = []
    for i in range(len(rows)):
    {
        row = rows[i]
        if len(row) == 0:
        {
            out.append("")
        }
        else:
        {
            s = row[0]
            for j in range(1, len(row)):
            {
                s = s + delimiter + row[j]
            }
            out.append(s)
        }
    }
    return out
}

# Read CSV from a single string (lines separated by \n); educational parser

def read_csv_string(text, delimiter=","):
{
    lines = []
    cur = ""
    for i in range(len(text)):
    {
        ch = text[i]
        if ch == "\n":
        {
            lines.append(cur)
            cur = ""
        }
        else:
        {
            if ch == "\r": { }
            else: { cur = cur + ch }
        }
    }
    lines.append(cur)
    return parse_csv_rows(lines, delimiter)
}

# Write CSV to a single string (lines joined by \n)

def write_csv_string(rows, delimiter=","):
{
    lines = to_csv_rows(rows, delimiter)
    nl = "\n"
    return nl.join(lines)
}

# --- Minimal JSON I/O (strings, arrays, objects) ---

def _is_space(ch):
{
    if ch == " ": { return True }
    if ch == "\n": { return True }
    if ch == "\r": { return True }
    if ch == "\t": { return True }
    return False
}

def _skip_ws(text, i):
{
    n = len(text)
    j = i
    while j < n:
    {
        if _is_space(text[j]): { j = j + 1 }
        else: { break }
    }
    return j
}

def _parse_string_json(text, i):
{
    j = i + 1
    s = ""
    n = len(text)
    while j < n:
    {
        ch = text[j]
        if ch == '"': { return [s, j + 1] }
        else:
        {
            if ch == "\\":
            {
                j = j + 1
                if j >= n: { return [s, j] }
                esc = text[j]
                if esc == "n": { s = s + "\n" }
                else:
                {
                    if esc == "t": { s = s + "\t" }
                    else:
                    {
                        if esc == "r": { s = s + "\r" }
                        else:
                        {
                            if esc == '"': { s = s + '"' }
                            else:
                            {
                                if esc == "\\": { s = s + "\\" }
                                else: { s = s + esc }
                            }
                        }
                    }
                }
                j = j + 1
            }
            else:
            {
                s = s + ch
                j = j + 1
            }
        }
    }
    return [s, j]
}

def _parse_array_json(text, i):
{
    j = i + 1
    arr = []
    j = _skip_ws(text, j)
    if j < len(text) and text[j] == "]": { return [arr, j + 1] }
    while j < len(text):
    {
        tmp = _parse_value_json(text, j)
        val = tmp[0]
        j = tmp[1]
        arr.append(val)
        j = _skip_ws(text, j)
        if j < len(text) and text[j] == ",":
        {
            j = j + 1
            j = _skip_ws(text, j)
        }
        else:
        {
            if j < len(text) and text[j] == "]": { return [arr, j + 1] }
            else: { return [arr, j] }
        }
    }
    return [arr, j]
}

def _parse_object_json(text, i):
{
    j = i + 1
    obj = {}
    j = _skip_ws(text, j)
    if j < len(text) and text[j] == "}": { return [obj, j + 1] }
    while j < len(text):
    {
        j = _skip_ws(text, j)
        if j >= len(text): { return [obj, j] }
        if text[j] != '"': { return [obj, j] }
        tk = _parse_string_json(text, j)
        key = tk[0]
        j = tk[1]
        j = _skip_ws(text, j)
        if j < len(text) and text[j] == ":": { j = j + 1 }
        j = _skip_ws(text, j)
        tv = _parse_value_json(text, j)
        val = tv[0]
        j = tv[1]
        obj[key] = val
        j = _skip_ws(text, j)
        if j < len(text) and text[j] == ",":
        {
            j = j + 1
            j = _skip_ws(text, j)
        }
        else:
        {
            if j < len(text) and text[j] == "}": { return [obj, j + 1] }
            else: { return [obj, j] }
        }
    }
    return [obj, j]
}

def _parse_value_json(text, i):
{
    j = _skip_ws(text, i)
    if j >= len(text): { return ["", j] }
    ch = text[j]
    if ch == '"': { return _parse_string_json(text, j) }
    if ch == "[": { return _parse_array_json(text, j) }
    if ch == "{": { return _parse_object_json(text, j) }
    # bare token until delimiter => return as string
    s = ""
    while j < len(text):
    {
        c = text[j]
        if c == "," or c == "]" or c == "}" or _is_space(c): { break }
        else:
        {
            s = s + c
            j = j + 1
        }
    }
    return [s, j]
}

def read_json_string(text):
{
    tmp = _parse_value_json(text, 0)
    return tmp[0]
}

def _json_escape(s):
{
    out = ""
    for i in range(len(s)):
    {
        ch = s[i]
        if ch == '"': { out = out + "\\" + '"' }
        else:
        {
            if ch == "\\": { out = out + "\\" + "\\" }
            else:
            {
                if ch == "\n": { out = out + "\\n" }
                else:
                {
                    if ch == "\t": { out = out + "\\t" }
                    else:
                    {
                        if ch == "\r": { out = out + "\\r" }
                        else: { out = out + ch }
                    }
                }
            }
        }
    }
    return out
}

def write_json_array_string(lst):
{
    n = len(lst)
    s = "["
    for i in range(n):
    {
        if i > 0: { s = s + "," }
        s = s + '"' + _json_escape(lst[i]) + '"'
    }
    s = s + "]"
    return s
}

def _sort_strings(xs):
{
    n = len(xs)
    ys = []
    for i in range(n): { ys.append(xs[i]) }
    for i in range(n):
    {
        min_idx = i
        for j in range(i + 1, n):
        {
            if ys[j] < ys[min_idx]: { min_idx = j }
        }
        tmp = ys[i]
        ys[i] = ys[min_idx]
        ys[min_idx] = tmp
    }
    return ys
}

def write_json_object_string(obj):
{
    keys = []
    for k in obj: { keys.append(k) }
    ks = _sort_strings(keys)
    s = "{"
    for i in range(len(ks)):
    {
        if i > 0: { s = s + "," }
        k = ks[i]
        v = obj[k]
        s = s + '"' + _json_escape(k) + '":' + '"' + _json_escape(v) + '"'
    }
    s = s + "}"
    return s
}

# Arabic wrappers for JSON

def قراءة_JSON_نص(نص): { return read_json_string(نص) }

def كتابة_JSON_قائمة(قائمة): { return write_json_array_string(قائمة) }

def كتابة_JSON_كائن(كائن): { return write_json_object_string(كائن) }


# Median and percentile (with simple selection sort)

def _copy_and_sort(xs):
{
    n = len(xs)
    ys = []
    for i in range(n): { ys.append(xs[i]) }


    # selection sort
    for i in range(n):
    {
        min_idx = i
        for j in range(i + 1, n):
        {
            if ys[j] < ys[min_idx]: { min_idx = j }
        }
        tmp = ys[i]
        ys[i] = ys[min_idx]
        ys[min_idx] = tmp
    }
    return ys
}

def median(xs):
{
    n = len(xs)
    if n == 0: { return 0.0 }
    a = _copy_and_sort(xs)
    # q = floor(n/2) via repeated subtraction by 2
    q = 0
    r = n
    while r >= 2:
    {
        r = r - 2
        q = q + 1
    }
    # r == 0 (even) or 1 (odd)
    if r == 1: { return a[q] }
    # even: average of a[q-1], a[q]
    i1 = q - 1
    if i1 < 0: { i1 = 0 }
    return (a[i1] + a[q]) / 2.0
}

def percentile(xs, p):
{
    n = len(xs)
    if n == 0: { return 0.0 }
    if p < 0.0: { p = 0.0 }
    if p > 100.0: { p = 100.0 }
    a = _copy_and_sort(xs)
    # pos = (p/100) * (n-1)
    pos = (p / 100.0) * (n - 1)
    i = 0
    while (i + 1) <= pos: { i = i + 1 }
    j = i + 1
    if j >= n: { j = i }
    w = pos - i
    return a[i] * (1.0 - w) + a[j] * w
}


# Descriptive statistics

def mean(xs):
{
    n = len(xs)
    if n == 0: { return 0.0 }
    return sum(xs) / n
}

def variance(xs):
{
    n = len(xs)
    if n == 0: { return 0.0 }
    m = mean(xs)
    acc = 0.0
    for i in range(n):
    {
        diff = xs[i] - m
        acc = acc + diff * diff
    }
    return acc / n
}

def stddev(xs):
{
    v = variance(xs)
    return pow(v, 0.5)
}

# Additional descriptive stats: min/max/range and z-score normalization

def min_value(xs):
{
    n = len(xs)
    if n == 0: { return 0.0 }
    m = xs[0]
    for i in range(1, n):
    {
        if xs[i] < m: { m = xs[i] }
    }
    return m
}


def max_value(xs):
{
    n = len(xs)
    if n == 0: { return 0.0 }
    m = xs[0]
    for i in range(1, n):
    {
        if xs[i] > m: { m = xs[i] }
    }
    return m
}

# Arabic wrappers for new stats helpers

def أدنى(قائمة): { return min_value(قائمة) }

def أقصى(قائمة): { return max_value(قائمة) }

def مجال(قائمة): { return data_range(قائمة) }

def تطبيع_Z(قائمة): { return zscore_normalize(قائمة) }



def data_range(xs):
{
    n = len(xs)
    if n == 0: { return 0.0 }
    lo = min_value(xs)
    hi = max_value(xs)
    return hi - lo
}


def zscore_normalize(xs):
{
    n = len(xs)
    if n == 0: { return [] }
    # compute mean inline to avoid cross-module deps at import site
    ssum = 0.0
    for i in range(n): { ssum = ssum + xs[i] }
    m = ssum / (1.0 * n)
    # compute stddev inline
    vsum = 0.0
    for i in range(n):
    {
        d = xs[i] - m
        vsum = vsum + d * d
    }
    v = vsum / (1.0 * n)
    s = pow(v, 0.5)
    out = []
    if s == 0.0:
    {
        for i in range(n): { out.append(0.0) }
        return out
    }
    for i in range(n):
    {
        out.append((xs[i] - m) / s)
    }
    return out
}


# Arabic wrappers

def قراءة_CSV_سطور(سطور, فاصل=","):{ return parse_csv_rows(سطور, فاصل) }

def كتابة_CSV_سطور(صفوف, فاصل=","):{ return to_csv_rows(صفوف, فاصل) }

# CSV text wrappers (Arabic)

def قراءة_CSV_نص(نص, فاصل=","):{ return read_csv_string(نص, فاصل) }

def كتابة_CSV_نص(صفوف, فاصل=","):{ return write_csv_string(صفوف, فاصل) }




def متوسط(قائمة): { return mean(قائمة) }

def تباين(قائمة): { return variance(قائمة) }

def انحراف_معياري(قائمة): { return stddev(قائمة) }

# Additional Arabic wrappers for stats

def وسيط(قائمة): { return median(قائمة) }

def مئين(قائمة, نسبة): { return percentile(قائمة, نسبة) }


# --- Simple PRNG (LCG) and shuffling/splitting ---

def lcg_next(state):
{
    a = 1103515245
    c = 12345
    m = 2147483648  # 2^31
    state = (a * state + c) % m
    u = state / m
    return [state, u]
}

# Inside-out Fisher–Yates to build a random permutation deterministically

def random_permutation(n, seed=42):
{
    perm = []
    for i in range(n): { perm.append(0) }
    state = seed
    for i in range(n):
    {
        perm[i] = i
        a = 1103515245
        c = 12345
        m = 2147483648
        state = (a * state + c) % m
        u = state / m
        t = u * (i + 1)
        j = 0
        while (j + 1) <= t:
        {
            j = j + 1
        }
        # swap perm[i], perm[j]
        tmp = perm[i]
        perm[i] = perm[j]
        perm[j] = tmp
    }
    return perm
}


# Unified PRNG API (module-level state box)

PRNG_BOX = {"state": 42}

# Set global seed

def set_seed(seed):
{
    PRNG_BOX["state"] = seed
    return seed
}

# Uniform random in [0,1)

def rand():
{
    st = lcg_next(PRNG_BOX["state"])
    PRNG_BOX["state"] = st[0]
    return st[1]
}

# Random integer in [a, b]

def randint(a, b):
{
    if b < a:
    {
        t = a
        a = b
        b = t
    }
    u = rand()
    span = (b - a) + 1
    t = u * span
    j = 0
    while (j + 1) <= t:
    {
        j = j + 1
    }
    return a + j
}

# Shuffle: returns a new shuffled copy using module PRNG

def shuffle_list(lst):
{
    n = len(lst)
    out = []
    for i in range(n): { out.append(lst[i]) }
    for i in range(n - 1, -1, -1):
    {
        st = lcg_next(PRNG_BOX["state"])
        PRNG_BOX["state"] = st[0]
        u = st[1]
        t = u * (i + 1)
        j = 0
        while (j + 1) <= t: { j = j + 1 }
        tmp = out[i]
        out[i] = out[j]
        out[j] = tmp
    }
    return out
}

# Sample k unique elements (k <= n)

def sample_list(lst, k):
{
    out = shuffle_list(lst)
    n = len(out)
    if k < 0: { k = 0 }
    if k > n: { k = n }
    res = []
    for i in range(k): { res.append(out[i]) }
    return res
}

# Arabic wrappers

def تعيين_بذرة(بذرة): { PRNG_BOX["state"] = بذرة }

def عشوائي_0_1(): { return rand() }

def عشوائي_صحيح_بين(أ, ب): { return randint(أ, ب) }

def خلط_قائمة(قائمة): { return shuffle_list(قائمة) }

def عينة_من_قائمة(قائمة, ك): { return sample_list(قائمة, ك) }

# Train/test split with shuffle using PRNG

def train_test_split_shuffle(X, y, test_ratio=0.25, seed=42):
{
    n = len(X)
    test_n = round(n * test_ratio)
    if test_n < 0: { test_n = 0 }
    if test_n > n: { test_n = n }
    perm = random_permutation(n, seed)
    X_shuf = []
    y_shuf = []
    for i in range(n):
    {
        idx = perm[i]
        X_shuf.append(X[idx])
        y_shuf.append(y[idx])
    }
    split_idx = n - test_n
    X_train = []
    X_test = []
    y_train = []
    y_test = []
    for i in range(n):
    {
        if i < split_idx:
        {
            X_train.append(X_shuf[i])
            y_train.append(y_shuf[i])
        }
        else:
        {
            X_test.append(X_shuf[i])
            y_test.append(y_shuf[i])
        }
    }
    return [X_train, X_test, y_train, y_test]
}

# Arabic wrappers

def ترتيب_عشوائي(n, بذرة=42): { return random_permutation(n, بذرة) }

def تقسيم_عشوائي_تدريب_اختبار(س, ت, نسبة_اختبار=0.25, بذرة=42): { return train_test_split_shuffle(س, ت, نسبة_اختبار, بذرة) }
