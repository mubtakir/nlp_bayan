# Data utilities: simple CSV rows and descriptive statistics

# Parse CSV given as list of row strings (no quotes handling, educational)
def parse_csv_rows(rows, delimiter=","):
{
    out = []
    for r in rows:
    {
        fields = []
        cur = ""
        for i in range(len(r)):
        {
            ch = r[i]
            if ch == delimiter:
            {
                fields.append(cur)
                cur = ""
            }
            else:
            {
                cur = cur + ch
            }
        }
        fields.append(cur)
        out.append(fields)
    }
    return out
}

# Convert list of rows (list of list of strings) to list of row strings
def to_csv_rows(rows, delimiter=","):
{
    out = []
    for i in range(len(rows)):
    {
        row = rows[i]
        if len(row) == 0:
        {
            out.append("")
        }
        else:
        {
            s = row[0]
            for j in range(1, len(row)):
            {
                s = s + delimiter + row[j]
            }
            out.append(s)
        }
    }
    return out
}

# Descriptive statistics

def mean(xs):
{
    n = len(xs)
    if n == 0: { return 0.0 }
    return sum(xs) / n
}

def variance(xs):
{
    n = len(xs)
    if n == 0: { return 0.0 }
    m = mean(xs)
    acc = 0.0
    for i in range(n):
    {
        diff = xs[i] - m
        acc = acc + diff * diff
    }
    return acc / n
}

def stddev(xs):
{
    v = variance(xs)
    return pow(v, 0.5)
}

# Arabic wrappers

def قراءة_CSV_سطور(سطور, فاصل=","):{ return parse_csv_rows(سطور, فاصل) }

def كتابة_CSV_سطور(صفوف, فاصل=","):{ return to_csv_rows(صفوف, فاصل) }

def متوسط(قائمة): { return mean(قائمة) }

def تباين(قائمة): { return variance(قائمة) }

def انحراف_معياري(قائمة): { return stddev(قائمة) }


# --- Simple PRNG (LCG) and shuffling/splitting ---

def lcg_next(state):
{
    a = 1103515245
    c = 12345
    m = 2147483648  # 2^31
    state = (a * state + c) % m
    u = state / m
    return [state, u]
}

# Inside-out Fisher–Yates to build a random permutation deterministically

def random_permutation(n, seed=42):
{
    perm = []
    for i in range(n): { perm.append(0) }
    state = seed
    for i in range(n):
    {
        perm[i] = i
        a = 1103515245
        c = 12345
        m = 2147483648
        state = (a * state + c) % m
        u = state / m
        t = u * (i + 1)
        j = 0
        while (j + 1) <= t:
        {
            j = j + 1
        }
        # swap perm[i], perm[j]
        tmp = perm[i]
        perm[i] = perm[j]
        perm[j] = tmp
    }
    return perm
}

# Train/test split with shuffle using PRNG

def train_test_split_shuffle(X, y, test_ratio=0.25, seed=42):
{
    n = len(X)
    test_n = round(n * test_ratio)
    if test_n < 0: { test_n = 0 }
    if test_n > n: { test_n = n }
    perm = random_permutation(n, seed)
    X_shuf = []
    y_shuf = []
    for i in range(n):
    {
        idx = perm[i]
        X_shuf.append(X[idx])
        y_shuf.append(y[idx])
    }
    split_idx = n - test_n
    X_train = []
    X_test = []
    y_train = []
    y_test = []
    for i in range(n):
    {
        if i < split_idx:
        {
            X_train.append(X_shuf[i])
            y_train.append(y_shuf[i])
        }
        else:
        {
            X_test.append(X_shuf[i])
            y_test.append(y_shuf[i])
        }
    }
    return [X_train, X_test, y_train, y_test]
}

# Arabic wrappers

def ترتيب_عشوائي(n, بذرة=42): { return random_permutation(n, بذرة) }

def تقسيم_عشوائي_تدريب_اختبار(س, ت, نسبة_اختبار=0.25, بذرة=42): { return train_test_split_shuffle(س, ت, نسبة_اختبار, بذرة) }
