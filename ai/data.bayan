# Data utilities: simple CSV rows and descriptive statistics

# Parse CSV given as list of row strings (no quotes handling, educational)
def parse_csv_rows(rows, delimiter=","):
{
    out = []
    for r in (rows) {
        fields = []
        cur = ""
        for i in (range(len(r))) {
            ch = r[i]
            if (ch == delimiter) {
                fields.append(cur)
                cur = ""
            }
            else {
            
                cur = cur + ch
            }
        }
        fields.append(cur)
        out.append(fields)
    }
    return out
}

# Convert list of rows (list of list of strings) to list of row strings
def to_csv_rows(rows, delimiter=","):
{
    out = []
    for i in (range(len(rows))) {
        row = rows[i]
        if (len(row) == 0) {
            out.append("")
        }
        else {
        
            s = row[0]
            for j in (range(1, len(row))) {
                s = s + delimiter + row[j]
            }
            out.append(s)
        }
    }
    return out
}

# Read CSV from a single string (lines separated by \n); educational parser

def read_csv_string(text, delimiter=","):
{
    lines = []
    cur = ""
    for i in (range(len(text))) {
        ch = text[i]
        if (ch == "\n") {
            lines.append(cur)
            cur = ""
        }
        else {
        
            if (ch == "\r") { }
            else { cur = cur + ch }
        }
    }
    lines.append(cur)
    return parse_csv_rows(lines, delimiter)
}

# Write CSV to a single string (lines joined by \n)

def write_csv_string(rows, delimiter=","):
{
    lines = to_csv_rows(rows, delimiter)
    nl = "\n"
    return nl.join(lines)
}

# --- Minimal JSON I/O (strings, arrays, objects) ---

def _is_space(ch):
{
    if (ch == " ") { return True }
    if (ch == "\n") { return True }
    if (ch == "\r") { return True }
    if (ch == "\t") { return True }
    return False
}

def _skip_ws(text, i):
{
    n = len(text)
    j = i
    while (j < n) {
        if (_is_space(text[j])) { j = j + 1 }
        else { break }
    }
    return j
}

def _parse_string_json(text, i):
{
    j = i + 1
    s = ""
    n = len(text)
    while (j < n) {
        ch = text[j]
        if (ch == '"') { return [s, j + 1] }
        else {
        
            if (ch == "\\") {
                j = j + 1
                if (j >= n) { return [s, j] }
                esc = text[j]
                if (esc == "n") { s = s + "\n" }
                else {
                
                    if (esc == "t") { s = s + "\t" }
                    else {
                    
                        if (esc == "r") { s = s + "\r" }
                        else {
                        
                            if (esc == '"') { s = s + '"' }
                            else {
                            
                                if (esc == "\\") { s = s + "\\" }
                                else { s = s + esc }
                            }
                        }
                    }
                }
                j = j + 1
            }
            else {
            
                s = s + ch
                j = j + 1
            }
        }
    }
    return [s, j]
}

def _parse_array_json(text, i):
{
    j = i + 1
    arr = []
    j = _skip_ws(text, j)
    if (j < len(text) and text[j] == "]") { return [arr, j + 1] }
    while (j < len(text)) {
        tmp = _parse_value_json(text, j)
        val = tmp[0]
        j = tmp[1]
        arr.append(val)
        j = _skip_ws(text, j)
        if (j < len(text) and text[j] == ",") {
            j = j + 1
            j = _skip_ws(text, j)
        }
        else {
        
            if (j < len(text) and text[j] == "]") { return [arr, j + 1] }
            else { return [arr, j] }
        }
    }
    return [arr, j]
}

def _parse_object_json(text, i):
{
    j = i + 1
    obj = {}
    j = _skip_ws(text, j)
    if (j < len(text) and text[j] == "}") { return [obj, j + 1] }
    while (j < len(text)) {
        j = _skip_ws(text, j)
        if (j >= len(text)) { return [obj, j] }
        if (text[j] != '"') { return [obj, j] }
        tk = _parse_string_json(text, j)
        key = tk[0]
        j = tk[1]
        j = _skip_ws(text, j)
        if (j < len(text) and text[j] == ":") { j = j + 1 }
        j = _skip_ws(text, j)
        tv = _parse_value_json(text, j)
        val = tv[0]
        j = tv[1]
        obj[key] = val
        j = _skip_ws(text, j)
        if (j < len(text) and text[j] == ",") {
            j = j + 1
            j = _skip_ws(text, j)
        }
        else {
        
            if (j < len(text) and text[j] == "}") { return [obj, j + 1] }
            else { return [obj, j] }
        }
    }
    return [obj, j]
}

def _parse_value_json(text, i):
{
    j = _skip_ws(text, i)
    if (j >= len(text)) { return ["", j] }
    ch = text[j]
    if (ch == '"') { return _parse_string_json(text, j) }
    if (ch == "[") { return _parse_array_json(text, j) }
    if (ch == "{") { return _parse_object_json(text, j) }
    # bare token until delimiter => return as string
    s = ""
    while (j < len(text)) {
        c = text[j]
        if (c == "," or c == "]" or c == "}" or _is_space(c)) { break }
        else {
        
            s = s + c
            j = j + 1
        }
    }
    return [s, j]
}

def read_json_string(text):
{
    tmp = _parse_value_json(text, 0)
    return tmp[0]
}

def _json_escape(s):
{
    out = ""
    for i in (range(len(s))) {
        ch = s[i]
        if (ch == '"') { out = out + "\\" + '"' }
        else {
        
            if (ch == "\\") { out = out + "\\" + "\\" }
            else {
            
                if (ch == "\n") { out = out + "\\n" }
                else {
                
                    if (ch == "\t") { out = out + "\\t" }
                    else {
                    
                        if (ch == "\r") { out = out + "\\r" }
                        else { out = out + ch }
                    }
                }
            }
        }
    }
    return out
}

def write_json_array_string(lst):
{
    n = len(lst)
    s = "["
    for i in (range(n)) {
        if (i > 0) { s = s + "," }
        s = s + '"' + _json_escape(lst[i]) + '"'
    }
    s = s + "]"
    return s
}

def _sort_strings(xs):
{
    n = len(xs)
    ys = []
    for i in (range(n)) { ys.append(xs[i]) }
    for i in (range(n)) {
        min_idx = i
        for j in (range(i + 1, n)) {
            if (ys[j] < ys[min_idx]) { min_idx = j }
        }
        tmp = ys[i]
        ys[i] = ys[min_idx]
        ys[min_idx] = tmp
    }
    return ys
}

def write_json_object_string(obj):
{
    keys = []
    for k in (obj) { keys.append(k) }
    ks = _sort_strings(keys)
    s = "{"
    for i in (range(len(ks))) {
        if (i > 0) { s = s + "," }
        k = ks[i]
        v = obj[k]
        s = s + '"' + _json_escape(k) + '":' + '"' + _json_escape(v) + '"'
    }
    s = s + "}"
    return s
}

# Arabic wrappers for JSON

def قراءة_JSON_نص(نص): { return read_json_string(نص) }

def كتابة_JSON_قائمة(قائمة): { return write_json_array_string(قائمة) }

def كتابة_JSON_كائن(كائن): { return write_json_object_string(كائن) }


# Median and percentile (with simple selection sort)

def _copy_and_sort(xs):
{
    n = len(xs)
    ys = []
    for i in (range(n)) { ys.append(xs[i]) }


    # selection sort
    for i in (range(n)) {
        min_idx = i
        for j in (range(i + 1, n)) {
            if (ys[j] < ys[min_idx]) { min_idx = j }
        }
        tmp = ys[i]
        ys[i] = ys[min_idx]
        ys[min_idx] = tmp
    }
    return ys
}

def median(xs):
{
    n = len(xs)
    if (n == 0) { return 0.0 }
    a = _copy_and_sort(xs)
    # q = floor(n/2) via repeated subtraction by 2
    q = 0
    r = n
    while (r >= 2) {
        r = r - 2
        q = q + 1
    }
    # r == 0 (even) or 1 (odd)
    if (r == 1) { return a[q] }
    # even: average of a[q-1], a[q]
    i1 = q - 1
    if (i1 < 0) { i1 = 0 }
    return (a[i1] + a[q]) / 2.0
}

def percentile(xs, p):
{
    n = len(xs)
    if (n == 0) { return 0.0 }
    if (p < 0.0) { p = 0.0 }
    if (p > 100.0) { p = 100.0 }
    a = _copy_and_sort(xs)
    # pos = (p/100) * (n-1)
    pos = (p / 100.0) * (n - 1)
    i = 0
    while ((i + 1) <= pos) { i = i + 1 }
    j = i + 1
    if (j >= n) { j = i }
    w = pos - i
    return a[i] * (1.0 - w) + a[j] * w
}

# Quantiles (general list of q in [0,1]) and IQR; Pearson correlation

def quantiles(xs, qs):
{
    out = []
    for i in (range(len(qs))) {
        q = qs[i]
        if (q < 0.0) { q = 0.0 }
        if (q > 1.0) { q = 1.0 }
        p = q * 100.0
        out.append(percentile(xs, p))
    }
    return out
}


def iqr(xs):
{
    n = len(xs)
    if (n == 0) { return 0.0 }
    a = _copy_and_sort(xs)
    # Tukey's hinges: median of lower/upper halves (exclude median when odd)
    q = 0
    r = n
    while (r >= 2) {
        r = r - 2
        q = q + 1
    }
    lower = []
    upper = []
    if (r == 1) {
        for i in (range(q)) { lower.append(a[i]) }
        for i in (range(q + 1, n)) { upper.append(a[i]) }
    }
    else {
    
        for i in (range(q)) { lower.append(a[i]) }
        for i in (range(q, n)) { upper.append(a[i]) }
    }
    q1 = median(lower)
    q3 = median(upper)
    return q3 - q1
}


def pearson_r(xs, ys):
{
    n = len(xs)
    if (n == 0 or len(ys) != n) { return 0.0 }
    sx = 0.0
    sy = 0.0
    for i in (range(n)) {
        sx = sx + xs[i]
        sy = sy + ys[i]
    }
    mx = sx / (1.0 * n)
    my = sy / (1.0 * n)
    sum_xy = 0.0
    sum_x2 = 0.0
    sum_y2 = 0.0
    for i in (range(n)) {
        dx = xs[i] - mx
        dy = ys[i] - my
        sum_xy = sum_xy + dx * dy
        sum_x2 = sum_x2 + dx * dx
        sum_y2 = sum_y2 + dy * dy
    }
    denom = pow(sum_x2, 0.5) * pow(sum_y2, 0.5)
    if (denom == 0.0) { return 0.0 }
    return sum_xy / denom
}



# Descriptive statistics

def mean(xs):
{
    n = len(xs)
    if (n == 0) { return 0.0 }
    return sum(xs) / n
}

def variance(xs):
{
    n = len(xs)
    if (n == 0) { return 0.0 }
    m = mean(xs)
    acc = 0.0
    for i in (range(n)) {
        diff = xs[i] - m
        acc = acc + diff * diff
    }
    return acc / n
}

def stddev(xs):
{
    v = variance(xs)
    return pow(v, 0.5)
}

# Additional descriptive stats: min/max/range and z-score normalization

def min_value(xs):
{
    n = len(xs)
    if (n == 0) { return 0.0 }
    m = xs[0]
    for i in (range(1, n)) {
        if (xs[i] < m) { m = xs[i] }
    }
    return m
}


def max_value(xs):
{
    n = len(xs)
    if (n == 0) { return 0.0 }
    m = xs[0]
    for i in (range(1, n)) {
        if (xs[i] > m) { m = xs[i] }
    }
    return m
}

# Arabic wrappers for new stats helpers

def أدنى(قائمة): { return min_value(قائمة) }

def أقصى(قائمة): { return max_value(قائمة) }

def مجال(قائمة): { return data_range(قائمة) }

def تطبيع_Z(قائمة): { return zscore_normalize(قائمة) }



def data_range(xs):
{
    n = len(xs)
    if (n == 0) { return 0.0 }
    lo = min_value(xs)
    hi = max_value(xs)
    return hi - lo
}


def zscore_normalize(xs):
{

    n = len(xs)
    if (n == 0) { return [] }
    # compute mean inline to avoid cross-module deps at import site
    ssum = 0.0
    for i in (range(n)) { ssum = ssum + xs[i] }
    m = ssum / (1.0 * n)
    # compute stddev inline
    vsum = 0.0
    for i in (range(n)) {
        d = xs[i] - m
        vsum = vsum + d * d
    }
    v = vsum / (1.0 * n)
    s = pow(v, 0.5)
    out = []
    if (s == 0.0) {
        for i in (range(n)) { out.append(0.0) }
        return out
    }
    for i in (range(n)) {
        out.append((xs[i] - m) / s)
    }
    return out
}

# Min-Max normalization to [0,1]

def minmax_normalize(xs):
{
    n = len(xs)
    if (n == 0) { return [] }
    lo = min_value(xs)
    hi = max_value(xs)
    rng = hi - lo
    out = []
    if (rng == 0.0) {
        for i in (range(n)) { out.append(0.0) }
        return out
    }
    for i in (range(n)) {
        out.append((xs[i] - lo) / rng)
    }
    return out
}

# Wave 8: Scalers (fit/transform)

# Standard Scaler: mean/std

def standard_scaler_fit(xs):
{
    n = len(xs)
    if (n == 0) { return [0.0, 1.0] }
    ssum = 0.0
    for i in (range(n)) { ssum = ssum + xs[i] }
    m = ssum / (1.0 * n)
    vsum = 0.0
    for i in (range(n)) {
        d = xs[i] - m
        vsum = vsum + d * d
    }
    v = vsum / (1.0 * n)
    s = pow(v, 0.5)
    if (s == 0.0) { s = 1.0 }
    return [m, s]
}


def standard_scaler_transform(xs, mean_val, std_val):
{
    n = len(xs)
    out = []
    if (n == 0) { return out }
    s = std_val
    if (s == 0.0) { s = 1.0 }
    for i in (range(n)) {
        out.append((xs[i] - mean_val) / s)
    }
    return out
}


# Robust Scaler: median/IQR

def robust_scaler_fit(xs):
{
    n = len(xs)
    if (n == 0) { return [0.0, 1.0] }
    # compute median inline: copy and selection sort
    a = []
    for i in (range(n)) { a.append(xs[i]) }
    for i in (range(n)) {
        min_idx = i
        for j in (range(i + 1, n)) {
            if (a[j] < a[min_idx]) { min_idx = j }
        }
        tmp = a[i]
        a[i] = a[min_idx]
        a[min_idx] = tmp
    }
    q = 0
    r = n
    while (r >= 2) {
        r = r - 2
        q = q + 1
    }
    med = 0.0
    if (r == 1) {
        med = a[q]
    }
    else {
    
        i1 = q - 1
        if (i1 < 0) { i1 = 0 }
        med = (a[i1] + a[q]) / 2.0
    }
    # compute IQR inline (Tukey's hinges)
    qh = 0
    rh = n
    while (rh >= 2) {
        rh = rh - 2
        qh = qh + 1
    }
    lower = []
    upper = []
    if (rh == 1) {
        for i in (range(qh)) { lower.append(a[i]) }
        for i in (range(qh + 1, n)) { upper.append(a[i]) }
    }
    else {
    
        for i in (range(qh)) { lower.append(a[i]) }
        for i in (range(qh, n)) { upper.append(a[i]) }
    }
    # median of lower
    nl = len(lower)
    ml = 0.0
    if (nl == 0) { ml = 0.0 }
    else {
    
        ql = 0
        rl = nl
        while (rl >= 2) {
            rl = rl - 2
            ql = ql + 1
        }
        if (rl == 1) { ml = lower[ql] }
        else {
        
            i1 = ql - 1
            if (i1 < 0) { i1 = 0 }
            ml = (lower[i1] + lower[ql]) / 2.0
        }
    }
    # median of upper
    nu = len(upper)
    mu = 0.0
    if (nu == 0) { mu = 0.0 }
    else {
    
        qu = 0
        ru = nu
        while (ru >= 2) {
            ru = ru - 2
            qu = qu + 1
        }
        if (ru == 1) { mu = upper[qu] }
        else {
        
            i1 = qu - 1
            if (i1 < 0) { i1 = 0 }
            mu = (upper[i1] + upper[qu]) / 2.0
        }
    }
    rq = mu - ml
    if (rq == 0.0) { rq = 1.0 }
    return [med, rq]
}


def robust_scaler_transform(xs, median_val, iqr_val):
{
    n = len(xs)
    out = []
    if (n == 0) { return out }
    r = iqr_val
    if (r == 0.0) { r = 1.0 }
    for i in (range(n)) {
        out.append((xs[i] - median_val) / r)
    }
    return out
}


# Min-Max Scaler: fit/transform pair

def minmax_scaler_fit(xs):
{
    n = len(xs)
    if (n == 0) { return [0.0, 1.0] }
    lo = xs[0]
    hi = xs[0]
    for i in (range(1, n)) {
        v = xs[i]
        if (v < lo) { lo = v }
        if (v > hi) { hi = v }
    }
    if (hi <= lo) { return [lo, lo] }
    return [lo, hi]
}


def minmax_scaler_transform(xs, lo, hi):
{
    n = len(xs)
    out = []
    if (n == 0) { return out }
    rng = hi - lo
    if (rng == 0.0) {
        for i in (range(n)) { out.append(0.0) }
        return out
    }
    for i in (range(n)) {
        out.append((xs[i] - lo) / rng)
    }
    return out
}


# Wave 9: Equal-width binning and one-hot encoding

def bin_equal_width(xs, bins):
{
    n = len(xs)
    out = []
    if (n == 0) { return out }
    if (bins < 1) { bins = 1 }
    lo = xs[0]
    hi = xs[0]
    for i in (range(1, n)) {
        v = xs[i]
        if (v < lo) { lo = v }
        if (v > hi) { hi = v }
    }
    if (hi == lo) {
        for i in (range(n)) { out.append(0) }
        return out
    }
    width = (hi - lo) / (1.0 * bins)
    for i in (range(n)) {
        t = (xs[i] - lo) / width
        j = 0
        while ((j + 1) <= t) { j = j + 1 }
        if (j < 0) { j = 0 }
        if (j >= bins) { j = bins - 1 }
        out.append(j)
    }
    return out
}


def one_hot_encode(indices, num_classes):
{
    n = len(indices)
    k = num_classes
    out = []
    if (k < 1) { k = 1 }
    for i in (range(n)) {
        row = []
        for j in (range(k)) { row.append(0) }
        idx = indices[i]
        if (idx < 0) { idx = 0 }
        if (idx >= k) { idx = k - 1 }
        row[idx] = 1
        out.append(row)
    }
    return out
}

# Arabic wrappers (Wave 9)

def تجزئة_عرض_متساوي(قائمة, صناديق): { return bin_equal_width(قائمة, صناديق) }

def ترميز_واحد_ساخن(فهارس, عدد_فئات): { return one_hot_encode(فهارس, عدد_فئات) }


# Wave 10: Encoders (fit/transform)

# Label Encoder

def label_encoder_fit(xs):
{
    vocab = []
    seen = {}
    for i in (range(len(xs))) {
        v = xs[i]
        if (v in seen) { }
        else {
        
            seen[v] = 1
            vocab.append(v)
        }
    }
    return vocab
}


def label_encoder_transform(xs, vocab):
{
    idx_map = {}
    for i in (range(len(vocab))) {
        idx_map[vocab[i]] = i
    }
    out = []
    for i in (range(len(xs))) {
        v = xs[i]
        if (v in idx_map) { out.append(idx_map[v]) }
        else {
         out.append(-1) }
    }
    return out
}


# Frequency Encoder

def frequency_encoder_fit(xs):
{
    n = len(xs)
    counts = {}
    for i in (range(n)) {
        v = xs[i]
        if (v in counts) { counts[v] = counts[v] + 1 }
        else {
         counts[v] = 1 }
    }
    freqs = {}
    if (n == 0) { return freqs }
    for k in (counts) {
        freqs[k] = counts[k] / (1.0 * n)
    }
    return freqs
}


def frequency_encoder_transform(xs, freqs):
{
    out = []
    for i in (range(len(xs))) {
        v = xs[i]
        if (v in freqs) { out.append(freqs[v]) }
        else {
         out.append(0.0) }
    }
    return out
}


# Target Encoder (mean encoding)

def target_encoder_fit(xs, ys):
{
    n = len(xs)
    if (len(ys) != n) { return {"means": {}, "global": 0.0} }
    sums = {}
    counts = {}
    total = 0.0
    for i in (range(n)) {
        v = xs[i]
        y = ys[i]
        total = total + y
        if (v in sums) {
            sums[v] = sums[v] + y
            counts[v] = counts[v] + 1
        }
        else {
        
            sums[v] = y
            counts[v] = 1
        }
    }
    g = 0.0
    if (n > 0) { g = total / (1.0 * n) }
    means = {}
    for k in (sums) {
        c = counts[k]
        if (c == 0) { means[k] = g }
        else {
         means[k] = sums[k] / (1.0 * c) }
    }
    return {"means": means, "global": g}
}


def target_encoder_transform(xs, enc):
{
    means = enc["means"]
    g = enc["global"]
    out = []
    for i in (range(len(xs))) {
        v = xs[i]
        if (v in means) { out.append(means[v]) }
        else {
         out.append(g) }
    }
    return out
}


# Arabic wrappers (Wave 10)

def ملاءمة_ترميز_تسميات(قائمة): { return label_encoder_fit(قائمة) }

def تحويل_ترميز_تسميات(قائمة, مفردات): { return label_encoder_transform(قائمة, مفردات) }

def ملاءمة_ترميز_تكرار(قائمة): { return frequency_encoder_fit(قائمة) }

def تحويل_ترميز_تكرار(قائمة, تكرارات): { return frequency_encoder_transform(قائمة, تكرارات) }

def ملاءمة_ترميز_هدفي(قيم, أهداف): { return target_encoder_fit(قيم, أهداف) }

def تحويل_ترميز_هدفي(قيم, مشفر): { return target_encoder_transform(قيم, مشفر) }




# Wave 8 Arabic wrappers (Scalers)

def ملاءمة_قياسي(قائمة): { return standard_scaler_fit(قائمة) }

def تحويل_قياسي(قائمة, متوسط, انحراف): { return standard_scaler_transform(قائمة, متوسط, انحراف) }

def ملاءمة_قوي(قائمة): { return robust_scaler_fit(قائمة) }

def تحويل_قوي(قائمة, وسيط_قيمة, مدى_ربيعي_قيمة): { return robust_scaler_transform(قائمة, وسيط_قيمة, مدى_ربيعي_قيمة) }

def ملاءمة_أدنى_أقصى(قائمة): { return minmax_scaler_fit(قائمة) }

def تحويل_أدنى_أقصى(قائمة, أدنى, أقصى): { return minmax_scaler_transform(قائمة, أدنى, أقصى) }




# Arabic wrappers

def تطبيع_أدنى_أقصى(قائمة): { return minmax_normalize(قائمة) }

def قراءة_CSV_سطور(سطور, فاصل=","):{ return parse_csv_rows(سطور, فاصل) }

def كتابة_CSV_سطور(صفوف, فاصل=","):{ return to_csv_rows(صفوف, فاصل) }

# CSV text wrappers (Arabic)

def قراءة_CSV_نص(نص, فاصل=","):{ return read_csv_string(نص, فاصل) }

def كتابة_CSV_نص(صفوف, فاصل=","):{ return write_csv_string(صفوف, فاصل) }




def متوسط(قائمة): { return mean(قائمة) }

def تباين(قائمة): { return variance(قائمة) }

def انحراف_معياري(قائمة): { return stddev(قائمة) }

# Additional Arabic wrappers for stats

def وسيط(قائمة): { return median(قائمة) }

def مئين(قائمة, نسبة): { return percentile(قائمة, نسبة) }

# Wave 7 Arabic wrappers (Data)

def نسب_مئوية_متعددة(قائمة, نسب): { return quantiles(قائمة, نسب) }

def مدى_ربيعي(قائمة): { return iqr(قائمة) }

def ارتباط_بيرسون(س, ص): { return pearson_r(س, ص) }



# --- Simple PRNG (LCG) and shuffling/splitting ---

def lcg_next(state):
{
    a = 1103515245
    c = 12345

    m = 2147483648  # 2^31
    state = (a * state + c) % m
    u = state / m
    return [state, u]
}

# Inside-out Fisher–Yates to build a random permutation deterministically

def random_permutation(n, seed=42):
{
    perm = []
    for i in (range(n)) { perm.append(0) }
    state = seed
    for i in (range(n)) {
        perm[i] = i
        a = 1103515245
        c = 12345
        m = 2147483648
        state = (a * state + c) % m
        u = state / m
        t = u * (i + 1)
        j = 0
        while ((j + 1) <= t) {
            j = j + 1
        }
        # swap perm[i], perm[j]
        tmp = perm[i]
        perm[i] = perm[j]
        perm[j] = tmp
    }
    return perm
}


# Unified PRNG API (module-level state box)

PRNG_BOX = {"state": 42}

# Set global seed

def set_seed(seed):
{
    PRNG_BOX["state"] = seed
    return seed
}

# Uniform random in [0,1)

def rand():
{
    st = lcg_next(PRNG_BOX["state"])
    PRNG_BOX["state"] = st[0]
    return st[1]
}

# Random integer in [a, b]

def randint(a, b):
{
    if (b < a) {
        t = a
        a = b
        b = t
    }
    u = rand()
    span = (b - a) + 1
    t = u * span
    j = 0
    while ((j + 1) <= t) {
        j = j + 1
    }
    return a + j
}

# Shuffle: returns a new shuffled copy using module PRNG

def shuffle_list(lst):
{
    n = len(lst)
    out = []
    for i in (range(n)) { out.append(lst[i]) }
    for i in (range(n - 1, -1, -1)) {
        st = lcg_next(PRNG_BOX["state"])
        PRNG_BOX["state"] = st[0]
        u = st[1]
        t = u * (i + 1)
        j = 0
        while ((j + 1) <= t) { j = j + 1 }
        tmp = out[i]
        out[i] = out[j]
        out[j] = tmp
    }
    return out
}

# Sample k unique elements (k <= n)

def sample_list(lst, k):
{
    out = shuffle_list(lst)
    n = len(out)
    if (k < 0) { k = 0 }
    if (k > n) { k = n }
    res = []
    for i in (range(k)) { res.append(out[i]) }
    return res
}

# Arabic wrappers

def تعيين_بذرة(بذرة): { PRNG_BOX["state"] = بذرة }

def عشوائي_0_1(): { return rand() }

def عشوائي_صحيح_بين(أ, ب): { return randint(أ, ب) }

def خلط_قائمة(قائمة): { return shuffle_list(قائمة) }

def عينة_من_قائمة(قائمة, ك): { return sample_list(قائمة, ك) }

# Train/test split with shuffle using PRNG

def train_test_split_shuffle(X, y, test_ratio=0.25, seed=42):
{
    n = len(X)
    test_n = round(n * test_ratio)
    if (test_n < 0) { test_n = 0 }
    if (test_n > n) { test_n = n }
    perm = random_permutation(n, seed)
    X_shuf = []
    y_shuf = []
    for i in (range(n)) {
        idx = perm[i]
        X_shuf.append(X[idx])
        y_shuf.append(y[idx])
    }
    split_idx = n - test_n
    X_train = []
    X_test = []
    y_train = []
    y_test = []
    for i in (range(n)) {
        if (i < split_idx) {
            X_train.append(X_shuf[i])
            y_train.append(y_shuf[i])
        }
        else {
        
            X_test.append(X_shuf[i])
            y_test.append(y_shuf[i])
        }
    }
    return [X_train, X_test, y_train, y_test]
}

# Arabic wrappers

def ترتيب_عشوائي(n, بذرة=42): { return random_permutation(n, بذرة) }

def تقسيم_عشوائي_تدريب_اختبار(س, ت, نسبة_اختبار=0.25, بذرة=42): { return train_test_split_shuffle(س, ت, نسبة_اختبار, بذرة) }


# --- Wave 17: Simple Pipeline utilities ---

# Each step: [name, fit_fn, transform_fn, params]
# fit_fn(X, params) -> model
# transform_fn(X, model) -> X_transformed

def pipeline_fit_transform(steps, X):
{
    X_cur = X
    models = []
    for si in (range(len(steps))) {
        step = steps[si]
        name = step[0]
        fit_fn = step[1]
        trans_fn = step[2]
        params = step[3]
        model = fit_fn(X_cur, params)
        models.append(model)
        X_cur = trans_fn(X_cur, model)
    }
    return [X_cur, models]
}


def pipeline_transform(steps, X, models):
{
    X_cur = X
    for si in (range(len(steps))) {
        step = steps[si]
        trans_fn = step[2]
        model = models[si]
        X_cur = trans_fn(X_cur, model)
    }
    return X_cur
}

# Arabic wrappers (Wave 17)

def pipeline_fit_transform_ar(steps, X): { return pipeline_fit_transform(steps, X) }

def pipeline_transform_ar(steps, X, models): { return pipeline_transform(steps, X, models) }

# Arabic wrappers (Wave 20 additions)

def ملاءمة_تحويل_أنبوب(خطوات, س): { return pipeline_fit_transform(خطوات, س) }

def تحويل_أنبوب(خطوات, س, نماذج): { return pipeline_transform(خطوات, س, نماذج) }


