# Conceptual orchestrator: choose and run meaning programs based on
# simple control messages (domain / intent / explicit program_id).

import ai.conceptual_programs as programs


# Program registry: each entry describes a meaning program that can be
# selected by domain/intent or by explicit id. We keep this inside a
# helper function so there are no global assignments at module load.

def get_program_registry():
{
    return [
        {
            "id": "student_study",
            "description": "Student study narrative meaning program",
            "domains": ["education", "student"],
            "intents": ["study_scenario"],
            "builder": programs.build_student_study_narrative_program,
            "preferred_for": {
                "time_horizon": "medium_term",
                "focus": "balanced"
            }
        },
        {
            "id": "student_study_causal",
            "description": "Student study with causal focus (alternative)",
            "domains": ["education", "student"],
            "intents": ["study_scenario"],
            "builder": programs.build_student_study_narrative_program,
            "preferred_for": {
                "focus": "causal"
            }
        },
        {
            "id": "medical_treatment",
            "description": "Medical treatment with possible side effects meaning program",
            "domains": ["health", "medicine"],
            "intents": ["treatment_scenario"],
            "builder": programs.build_medical_treatment_uncertainty_program,
            "preferred_for": {
                "time_horizon": "medium_term",
                "focus": "uncertainty"
            }
        },
        {
            "id": "medical_treatment_short",
            "description": "Medical treatment for short-term scenarios",
            "domains": ["health", "medicine"],
            "intents": ["treatment_scenario"],
            "builder": programs.build_medical_treatment_uncertainty_program,
            "preferred_for": {
                "time_horizon": "short_term"
            }
        },
        {
            "id": "economic_investment",
            "description": "Economic investment scenario with potential risk",
            "domains": ["economy", "finance", "market"],
            "intents": ["investment_scenario"],
            "builder": programs.build_economic_investment_risk_program,
            "preferred_for": {
                "time_horizon": "long_term",
                "focus": "uncertainty"
            }
        },
        {
            "id": "social_relationship",
            "description": "Social relationship building narrative meaning program",
            "domains": ["social", "friendship", "relationships"],
            "intents": ["relationship_scenario", "friendship_scenario"],
            "builder": programs.build_social_relationship_program,
            "preferred_for": {
                "time_horizon": "medium_term",
                "focus": "balanced"
            }
        },
        {
            "id": "social_relationship_temporal",
            "description": "Social relationship with temporal focus",
            "domains": ["social", "friendship", "relationships"],
            "intents": ["relationship_scenario", "friendship_scenario"],
            "builder": programs.build_social_relationship_program,
            "preferred_for": {
                "focus": "temporal"
            }
        },
        {
            "id": "daily_decision",
            "description": "Daily decision-making narrative meaning program",
            "domains": ["daily_life", "personal", "decision"],
            "intents": ["decision_scenario", "choice_scenario"],
            "builder": programs.build_daily_decision_program,
            "preferred_for": {
                "time_horizon": "short_term",
                "focus": "balanced"
            }
        }
    ]
}


# Helper: score a program entry based on control_message preferences
# Returns a score (higher is better) or -1 if no match.
def _score_program(entry, control_message):
{
    score = 0

    # Check domain match
    if "domain" in control_message:
    {
        requested_domain = control_message["domain"]
        if "domains" in entry:
        {
            doms = entry["domains"]
            matched = False
            for j in range(len(doms)):
            {
                if doms[j] == requested_domain:
                {
                    matched = True
                    break
                }
            }
            if matched:
            {
                score = score + 10
            }
            else:
            {
                return -1
            }
        }
    }

    # Check intent match
    if "intent" in control_message:
    {
        intent = control_message["intent"]
        if "intents" in entry:
        {
            intents = entry["intents"]
            matched = False
            for j in range(len(intents)):
            {
                if intents[j] == intent:
                {
                    matched = True
                    break
                }
            }
            if matched:
            {
                score = score + 10
            }
            else:
            {
                return -1
            }
        }
    }

    # Bonus: preferred_settings alignment
    if "preferred_settings" in control_message:
    {
        prefs = control_message["preferred_settings"]

        # Check if program has metadata about preferred settings
        if "preferred_for" in entry:
        {
            pref_for = entry["preferred_for"]

            # Check scenario_variant preference
            if "scenario_variant" in prefs and "scenario_variant" in pref_for:
            {
                if prefs["scenario_variant"] == pref_for["scenario_variant"]:
                {
                    score = score + 5
                }
            }

            # Check time_horizon preference
            if "time_horizon" in prefs and "time_horizon" in pref_for:
            {
                if prefs["time_horizon"] == pref_for["time_horizon"]:
                {
                    score = score + 5
                }
            }

            # Check focus preference
            if "focus" in prefs and "focus" in pref_for:
            {
                if prefs["focus"] == pref_for["focus"]:
                {
                    score = score + 3
                }
            }
        }
    }

    return score
}


# control_message is expected to be a dict-like object, e.g.:
#   {"domain": "education", "intent": "study_scenario"}
# or {"program_id": "student_study"}
# or {"domain": "social", "preferred_settings": {"focus": "causal"}}
# Returns the selected registry entry or None.
# Now supports multiple programs per domain with intelligent selection.
def select_program(control_message):
{
    registry = get_program_registry()

    # 1) Explicit program_id has highest priority
    if "program_id" in control_message:
    {
        requested_id = control_message["program_id"]
        for i in range(len(registry)):
        {
            entry = registry[i]
            if entry["id"] == requested_id:
            {
                return entry
            }
        }
        return None
    }

    # 2) Score all programs and pick the best match
    best_entry = None
    best_score = -1

    for i in range(len(registry)):
    {
        entry = registry[i]
        score = _score_program(entry, control_message)

        if score > best_score:
        {
            best_score = score
            best_entry = entry
        }
    }

    return best_entry
}


# Normalize optional control settings (detail level, languages, perspective,
# focus, scenario_variant, time_horizon) into a small settings dict that
# downstream code can rely on.
def normalize_settings(control_message):
{
    # Detail level controls how many components will be realized.
    # Allowed values (by convention): "low", "medium", "high".
    detail = "high"
    if "detail_level" in control_message:
    {
        detail = control_message["detail_level"]
    }

    # Languages control which symbolic sentences are generated.
    # "arabic"/"ar", "english"/"en", or "both" (default both).
    langs = ["english", "arabic"]
    if "languages" in control_message:
    {
        lang_spec = control_message["languages"]
        if lang_spec == "arabic" or lang_spec == "ar":
        {
            langs = ["arabic"]
        }
        elif lang_spec == "english" or lang_spec == "en":
        {
            langs = ["english"]
        }
        elif lang_spec == "both":
        {
            langs = ["english", "arabic"]
        }
    }

    # Perspective can be used by the LM layer (e.g. to choose register).
    perspective = "neutral"
    if "perspective" in control_message:
    {
        perspective = control_message["perspective"]
    }

    # Focus indicates which conceptual aspect to emphasize in realization.
    # Examples: "causal", "temporal", "uncertainty", "context".
    focus = None
    if "focus" in control_message:
    {
        focus = control_message["focus"]
    }

    # Scenario variant is a coarse hint about positivity/negativity.
    # Allowed values: "positive", "negative", "neutral".
    scenario_variant = "neutral"
    if "scenario_variant" in control_message:
    {
        variant = control_message["scenario_variant"]
        if variant == "positive" or variant == "negative" or variant == "neutral":
        {
            scenario_variant = variant
        }
    }

    # Time horizon is a rough indication of short/medium/long term.
    # Allowed values: "short_term", "medium_term", "long_term".
    time_horizon = "medium_term"
    if "time_horizon" in control_message:
    {
        th = control_message["time_horizon"]
        if th == "short_term" or th == "medium_term" or th == "long_term":
        {
            time_horizon = th
        }
    }

    return {
        "detail_level": detail,
        "languages": langs,
        "perspective": perspective,
        "focus": focus,
        "scenario_variant": scenario_variant,
        "time_horizon": time_horizon
    }
}


# High-level entry point: given a control_message, pick a program,
# run it, and return a uniform structure combining selection metadata
# with the program output (trace + components).
def dispatch_request(control_message):
{
    entry = select_program(control_message)
    if entry == None:
    {
        return {
            "ok": False,
            "error": "no_program_match",
            "control_message": control_message
        }
    }

    # Normalize optional control settings so that downstream code does
    # not have to check for missing keys.
    settings = normalize_settings(control_message)

    builder = entry["builder"]
    program_output = builder(settings)

    # Generate text using the Realizer
    # We need to convert the conceptual components into sentence trees first.
    # For this prototype, we'll assume a simple mapping or use the realizer's ability 
    # to handle raw concepts if we had a planner. 
    # Since we don't have a full planner yet, we will use a simplified approach:
    # We will iterate over the components and try to realize them if they have a trace.
    # Ideally, we would use `conceptual_surface_planner` here.
    
    # For now, let's just return the components. The user asked to "Update ai/conceptual_orchestrator.bayan to use Realizer".
    # But the Realizer needs a SurfacePlan or SentenceTree.
    # The `conceptual_surface_planner` (which we haven't touched yet) is responsible for that.
    # However, to demonstrate the pipeline, we can try to construct a simple plan here or just leave it for the verification script.
    
    # Let's stick to the plan: "Update: Modify the pipeline to explicitly call conceptual_surface_realizer...".
    # But wait, we need the Planner to go from Circuit -> SentenceTree.
    # I will add a TODO note here and let the verification script handle the glue for now, 
    # OR I can import the planner if it exists and is usable.
    # Checking `ai/conceptual_surface_planner.bayan`... it exists.
    
    return {
        "ok": True,
        "selected_program": entry["id"],
        "program_description": entry["description"],
        "control_message": control_message,
        "settings": settings,
        "trace": program_output["trace"],
        "components": program_output["components"]
    }
}

