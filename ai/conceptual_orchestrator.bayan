# Conceptual orchestrator: choose and run meaning programs based on
# simple control messages (domain / intent / explicit program_id).

import ai.conceptual_programs as programs


# Program registry: each entry describes a meaning program that can be
# selected by domain/intent or by explicit id. We keep this inside a
# helper function so there are no global assignments at module load.

def get_program_registry():
{
    return [
        # --- EDUCATION ---
        {
            "id": "student_study",
            "description": "Student study narrative (Default)",
            "domains": ["education", "student"],
            "intents": ["study_scenario", "narrative"],
            "builder": programs.build_student_study_narrative_program,
            "preferred_for": {
                "scenario_variant": "neutral",
                "focus": "balanced"
            }
        },
        {
            "id": "student_success",
            "description": "Student success narrative (Optimistic)",
            "domains": ["education", "student"],
            "intents": ["study_scenario", "narrative", "success"],
            "builder": programs.build_student_success_narrative,
            "preferred_for": {
                "scenario_variant": "positive",
                "focus": "balanced"
            }
        },
        {
            "id": "student_struggle",
            "description": "Student struggle narrative (Pessimistic)",
            "domains": ["education", "student"],
            "intents": ["study_scenario", "narrative", "struggle"],
            "builder": programs.build_student_struggle_narrative,
            "preferred_for": {
                "scenario_variant": "negative",
                "focus": "uncertainty"
            }
        },

        # --- HEALTH ---
        {
            "id": "medical_treatment",
            "description": "Medical treatment (Default)",
            "domains": ["health", "medicine"],
            "intents": ["treatment_scenario", "narrative"],
            "builder": programs.build_medical_treatment_uncertainty_program,
            "preferred_for": {
                "time_horizon": "medium_term",
                "focus": "uncertainty"
            }
        },
        {
            "id": "acute_treatment",
            "description": "Acute treatment program (Short-term)",
            "domains": ["health", "medicine"],
            "intents": ["treatment_scenario", "narrative", "acute"],
            "builder": programs.build_acute_treatment_program,
            "preferred_for": {
                "time_horizon": "short_term",
                "focus": "causal"
            }
        },
        {
            "id": "chronic_management",
            "description": "Chronic management program (Long-term)",
            "domains": ["health", "medicine"],
            "intents": ["treatment_scenario", "narrative", "chronic"],
            "builder": programs.build_chronic_management_program,
            "preferred_for": {
                "time_horizon": "long_term",
                "focus": "temporal"
            }
        },

        # --- ECONOMY ---
        {
            "id": "economic_investment",
            "description": "Economic investment (Default)",
            "domains": ["economy", "finance", "market"],
            "intents": ["investment_scenario", "narrative"],
            "builder": programs.build_economic_investment_risk_program,
            "preferred_for": {
                "scenario_variant": "neutral",
                "focus": "uncertainty"
            }
        },
        {
            "id": "growth_investment",
            "description": "Growth investment (Bull Market)",
            "domains": ["economy", "finance", "market"],
            "intents": ["investment_scenario", "narrative", "growth"],
            "builder": programs.build_growth_investment_program,
            "preferred_for": {
                "scenario_variant": "positive",
                "focus": "causal"
            }
        },
        {
            "id": "recession_strategy",
            "description": "Recession strategy (Bear Market)",
            "domains": ["economy", "finance", "market"],
            "intents": ["investment_scenario", "narrative", "recession"],
            "builder": programs.build_recession_strategy_program,
            "preferred_for": {
                "scenario_variant": "negative",
                "focus": "uncertainty"
            }
        },

        # --- SOCIAL ---
        {
            "id": "social_relationship",
            "description": "Social relationship (Default)",
            "domains": ["social", "friendship", "relationships"],
            "intents": ["relationship_scenario", "narrative"],
            "builder": programs.build_social_relationship_program,
            "preferred_for": {
                "time_horizon": "medium_term",
                "focus": "balanced"
            }
        },
        {
            "id": "relationship_building",
            "description": "Relationship building (New)",
            "domains": ["social", "friendship", "relationships"],
            "intents": ["relationship_scenario", "narrative", "new"],
            "builder": programs.build_relationship_building_program,
            "preferred_for": {
                "time_horizon": "short_term",
                "focus": "temporal"
            }
        },
        {
            "id": "relationship_maintenance",
            "description": "Relationship maintenance (Established)",
            "domains": ["social", "friendship", "relationships"],
            "intents": ["relationship_scenario", "narrative", "maintenance"],
            "builder": programs.build_relationship_maintenance_program,
            "preferred_for": {
                "time_horizon": "long_term",
                "focus": "balanced"
            }
        },

        # --- DAILY LIFE ---
        {
            "id": "daily_decision",
            "description": "Daily decision (Default)",
            "domains": ["daily_life", "personal", "decision"],
            "intents": ["decision_scenario", "narrative"],
            "builder": programs.build_daily_decision_program,
            "preferred_for": {
                "detail_level": "medium",
                "focus": "balanced"
            }
        },
        {
            "id": "routine_decision",
            "description": "Routine decision (Low stakes)",
            "domains": ["daily_life", "personal", "decision"],
            "intents": ["decision_scenario", "narrative", "routine"],
            "builder": programs.build_routine_decision_program,
            "preferred_for": {
                "detail_level": "low",
                "focus": "balanced"
            }
        },
        {
            "id": "crisis_decision",
            "description": "Crisis decision (High stakes)",
            "domains": ["daily_life", "personal", "decision"],
            "intents": ["decision_scenario", "narrative", "crisis"],
            "builder": programs.build_crisis_decision_program,
            "preferred_for": {
                "detail_level": "high",
                "focus": "uncertainty"
            }
        }
    ]
}


# Helper: score a program entry based on control_message preferences
# Returns a score (higher is better) or -1 if no match.
def _score_program(entry, control_message):
{
    score = 0

    # Check domain match
    if ("domain" in control_message) {
        requested_domain = control_message["domain"]
        if ("domains" in entry) {
            doms = entry["domains"]
            matched = False
            for j in (range(len(doms))) {
                if (doms[j] == requested_domain) {
                    matched = True
                    break
                }
            }
            if (matched) {
                score = score + 10
            }
            else {
                return -1
            }
        }
    }

    # Check intent match
    if ("intent" in control_message) {
        intent = control_message["intent"]
        if ("intents" in entry) {
            intents = entry["intents"]
            matched = False
            for j in (range(len(intents))) {
                if (intents[j] == intent) {
                    matched = True
                    break
                }
            }
            if (matched) {
                score = score + 10
            }
        }
    }

    # Check preferences (both in preferred_settings and top-level)
    if ("preferred_for" in entry) {
        pref_for = entry["preferred_for"]
        
        # Helper to check a setting
        # We check control_message[key] AND control_message["preferred_settings"][key]
        
        # 1. Scenario Variant
        if ("scenario_variant" in pref_for) {
            val = None
            if ("scenario_variant" in control_message) {
                val = control_message["scenario_variant"]
            }
            elif ("preferred_settings" in control_message and "scenario_variant" in control_message["preferred_settings"]) {
                val = control_message["preferred_settings"]["scenario_variant"]
            }
            
            if (val != None and val == pref_for["scenario_variant"]) {
                score = score + 5
            }
        }

        # 2. Time Horizon
        if ("time_horizon" in pref_for) {
            val = None
            if ("time_horizon" in control_message) {
                val = control_message["time_horizon"]
            }
            elif ("preferred_settings" in control_message and "time_horizon" in control_message["preferred_settings"]) {
                val = control_message["preferred_settings"]["time_horizon"]
            }
            
            if (val != None and val == pref_for["time_horizon"]) {
                score = score + 5
            }
        }

        # 3. Focus
        if ("focus" in pref_for) {
            val = None
            if ("focus" in control_message) {
                val = control_message["focus"]
            }
            elif ("preferred_settings" in control_message and "focus" in control_message["preferred_settings"]) {
                val = control_message["preferred_settings"]["focus"]
            }
            
            if (val != None and val == pref_for["focus"]) {
                score = score + 3
            }
        }
        
        # 4. Detail Level
        if ("detail_level" in pref_for) {
            val = None
            if ("detail_level" in control_message) {
                val = control_message["detail_level"]
            }
            elif ("preferred_settings" in control_message and "detail_level" in control_message["preferred_settings"]) {
                val = control_message["preferred_settings"]["detail_level"]
            }
            
            if (val != None and val == pref_for["detail_level"]) {
                score = score + 3
            }
        }
    }

    return score
}


# control_message is expected to be a dict-like object, e.g.:
#   {"domain": "education", "intent": "study_scenario"}
# or {"program_id": "student_study"}
# or {"domain": "social", "scenario_variant": "positive"}
# Returns the selected registry entry or None.
# Now supports multiple programs per domain with intelligent selection.
def select_program(control_message):
{
    registry = get_program_registry()

    # 1) Explicit program_id has highest priority
    if ("program_id" in control_message) {
        requested_id = control_message["program_id"]
        for i in (range(len(registry))) {
            entry = registry[i]
            if (entry["id"] == requested_id) {
                return entry
            }
        }
        return None
    }

    # 2) Score all programs and pick the best match
    best_entry = None
    best_score = -1

    for i in (range(len(registry))) {
        entry = registry[i]
        score = _score_program(entry, control_message)

        if (score > best_score) {
            best_score = score
            best_entry = entry
        }
    }

    return best_entry
}


# Normalize optional control settings (detail level, languages, perspective,
# focus, scenario_variant, time_horizon) into a small settings dict that
# downstream code can rely on.
def normalize_settings(control_message):
{
    # Detail level controls how many components will be realized.
    # Allowed values (by convention): "low", "medium", "high".
    detail = "high"
    if ("detail_level" in control_message) {
        detail = control_message["detail_level"]
    }

    # Languages control which symbolic sentences are generated.
    # "arabic"/"ar", "english"/"en", or "both" (default both).
    langs = ["english", "arabic"]
    if ("languages" in control_message) {
        lang_spec = control_message["languages"]
        if (lang_spec == "arabic" or lang_spec == "ar") {
            langs = ["arabic"]
        }
        elif (lang_spec == "english" or lang_spec == "en") {
            langs = ["english"]
        }
        elif (lang_spec == "both") {
            langs = ["english", "arabic"]
        }
    }

    # Perspective can be used by the LM layer (e.g. to choose register).
    perspective = "neutral"
    if ("perspective" in control_message) {
        perspective = control_message["perspective"]
    }

    # Focus indicates which conceptual aspect to emphasize in realization.
    # Examples: "causal", "temporal", "uncertainty", "context".
    focus = None
    if ("focus" in control_message) {
        focus = control_message["focus"]
    }

    # Scenario variant is a coarse hint about positivity/negativity.
    # Allowed values: "positive", "negative", "neutral".
    scenario_variant = "neutral"
    if ("scenario_variant" in control_message) {
        variant = control_message["scenario_variant"]
        if (variant == "positive" or variant == "negative" or variant == "neutral") {
            scenario_variant = variant
        }
    }

    # Time horizon is a rough indication of short/medium/long term.
    # Allowed values: "short_term", "medium_term", "long_term".
    time_horizon = "medium_term"
    if ("time_horizon" in control_message) {
        th = control_message["time_horizon"]
        if (th == "short_term" or th == "medium_term" or th == "long_term") {
            time_horizon = th
        }
    }

    return {
        "detail_level": detail,
        "languages": langs,
        "perspective": perspective,
        "focus": focus,
        "scenario_variant": scenario_variant,
        "time_horizon": time_horizon
    }
}


# High-level entry point: given a control_message, pick a program,
# run it, and return a uniform structure combining selection metadata
# with the program output (trace + components).
def dispatch_request(control_message):
{
    entry = select_program(control_message)
    if (entry == None) {
        return {
            "ok": False,
            "error": "no_program_match",
            "control_message": control_message
        }
    }

    # Normalize optional control settings so that downstream code does
    # not have to check for missing keys.
    settings = normalize_settings(control_message)

    builder = entry["builder"]
    program_output = builder(settings)

    # Generate text using the Realizer
    # We need to convert the conceptual components into sentence trees first.
    # For this prototype, we'll assume a simple mapping or use the realizer's ability 
    # to handle raw concepts if we had a planner. 
    # Since we don't have a full planner yet, we will use a simplified approach:
    # We will iterate over the components and try to realize them if they have a trace.
    # Ideally, we would use `conceptual_surface_planner` here.
    
    # For now, let's just return the components. The user asked to "Update ai/conceptual_orchestrator.bayan to use Realizer".
    # But the Realizer needs a SurfacePlan or SentenceTree.
    # The `conceptual_surface_planner` (which we haven't touched yet) is responsible for that.
    # However, to demonstrate the pipeline, we can try to construct a simple plan here or just leave it for the verification script.
    
    # Let's stick to the plan: "Update: Modify the pipeline to explicitly call conceptual_surface_realizer...".
    # But wait, we need the Planner to go from Circuit -> SentenceTree.
    # I will add a TODO note here and let the verification script handle the glue for now, 
    # OR I can import the planner if it exists and is usable.
    # Checking `ai/conceptual_surface_planner.bayan`... it exists.
    
    return {
        "ok": True,
        "selected_program": entry["id"],
        "program_description": entry["description"],
        "control_message": control_message,
        "settings": settings,
        "trace": program_output["trace"],
        "components": program_output["components"]
    }
}

