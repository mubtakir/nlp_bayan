# Morphology Engine: Generates surface forms from lemmas
# المولد الصرفي: يولد الكلمات المشكلة من الجذور

# --- ARABIC MORPHOLOGY ---

# Note: This file now uses native Camel Tools integration when available
# The conjugate_verb and extract_root functions are provided by the runtime
# and will automatically use Camel Tools if installed, with fallback to manual rules

def conjugate_arabic_verb(lemma, tense, person_gender_number)
{
    # Use native conjugate_verb function (provided by ArabicNLPAdapter)
    # This automatically uses Camel Tools if available, otherwise falls back
    return conjugate_verb(lemma, tense, person_gender_number)
}


def decline_arabic_noun(lemma, definiteness, gender="m"):
{
    # Simplified: just handling Al- definition and Ta-Marbuta
    if (definiteness == "def") {
        if (lemma.startswith("ال")) {
            return lemma
        }
        return "ال" + lemma
    }
    
    return lemma
}

def apply_pattern(root_str, pattern):
{
    # Generates a word from a trilateral root and a pattern
    # root_str: string of 3 letters (e.g. "كتب")
    # pattern: string representing the pattern (e.g. "فاعل", "مفعول")
    
    if (len(root_str) != 3) { return root_str } # Only trilateral roots supported for now
    
    r1 = root_str[0]
    r2 = root_str[1]
    r3 = root_str[2]
    
    if (pattern == "فاعل") { return r1 + "ا" + r2 + r3 }
    if (pattern == "مفعول") { return "م" + r1 + r2 + "و" + r3 }
    if (pattern == "فعال") { return r1 + r2 + "ا" + r3 } # Simplified shadda handling
    if (pattern == "فعل") { return r1 + r2 + r3 }
    if (pattern == "أفعل") { return "أ" + r1 + r2 + r3 }
    if (pattern == "تفعيل") { return "ت" + r1 + r2 + "ي" + r3 }
    if (pattern == "مفاعل") { return "م" + r1 + "ا" + r2 + r3 }
    if (pattern == "افتعال") { return "ا" + r1 + "ت" + r2 + "ا" + r3 }
    if (pattern == "استفعال") { return "است" + r1 + r2 + "ا" + r3 }
    if (pattern == "مستفعل") { return "مست" + r1 + r2 + r3 }
    
    return root_str # Unknown pattern
}

def extract_root(word):
{
    # A very simplified root extractor (stemmer)
    # This is a heuristic approach, not a full morphological analyzer
    
    w = word
    
    # Remove definite article
    if (w.startswith("ال")) { w = w[2:] }
    
    # Remove common suffixes
    if (w.endswith("ون")) { w = w[0:len(w)-2] }
    elif (w.endswith("ين")) { w = w[0:len(w)-2] }
    elif (w.endswith("ات")) { w = w[0:len(w)-2] }
    elif (w.endswith("ة")) { w = w[0:len(w)-1] }
    
    # Remove common prefixes
    if (w.startswith("است")) { w = w[3:] }
    elif (w.startswith("مست")) { w = w[3:] }
    elif (w.startswith("يت")) { w = w[2:] }
    
    # If length is 3, assume it's the root
    if (len(w) == 3) { return w }
    
    # Handle "فاعل" -> "فعل"
    if (len(w) == 4 and w[1] == "ا") { return w[0] + w[2] + w[3] }
    
    # Handle "مفعول" -> "فعل"
    if (len(w) == 5 and w[0] == "م" and w[3] == "و") { return w[1] + w[2] + w[4] }
    
    return w
}


# --- ENGLISH MORPHOLOGY ---

def conjugate_english_verb(lemma, tense, person_number):
{
    if (tense == "past") {
        if (lemma == "take") { return "took" }
        if (lemma == "eat") { return "ate" }
        if (lemma == "go") { return "went" }
        
        if (lemma.endswith("e")) {
            return lemma + "d"
        }
        if (lemma.endswith("y") and lemma != "play" and lemma != "stay") {
             return lemma[0:len(lemma)-1] + "ied"
        }
        return lemma + "ed" # Simplified regular
    }
    elif (tense == "present") {
        if (person_number == "3s") {
            if (lemma.endswith("y")) {
                # study -> studies
                # play -> plays (vowel+y) - simplified check
                if (lemma == "study" or lemma == "try") {
                     return lemma[0:len(lemma)-1] + "ies"
                }
            }
            
            if (lemma.endswith("s") or lemma.endswith("sh") or lemma.endswith("ch")) {
                return lemma + "es"
            }
            
            return lemma + "s"
        }
        return lemma
    }
    elif (tense == "future") {
        return "will " + lemma
    }

    return lemma
}

def pluralize_english_noun(lemma):
{
    if (lemma.endswith("y")) {
         if (lemma == "library" or lemma == "city") {
             return lemma[0:len(lemma)-1] + "ies"
         }
    }
    
    if (lemma.endswith("s")) {
        return lemma + "es"
    }
    
    return lemma + "s"
}
