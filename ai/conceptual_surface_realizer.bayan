# Conceptual surface realizer layer for Bayan

hybrid {
    import ai.lexicon as lex
    import ai.morphology as morph
}

# Helper: shallow clone of a sequence list
def _clone_sequence(seq):
{
    cloned = []
    for i in (range(len(seq))) {
        cloned.append(seq[i])
    }
    return cloned
}

# Realize directly from a SurfacePlan
def realize_from_surface_plan(plan, register):
{
    if (register == None) {
        register = "neutral"
    }

    # 1. Get the abstract sequence
    abstract_seq = plan["sequence"]
    lang = plan["lang"]
    
    # 2. Transform into surface tokens using Lexicon & Morphology
    surface_tokens = []
    
    for i in (range(len(abstract_seq))) {
        node = abstract_seq[i]
        
        # Unwrap slot/value if present (from planner)
        if (isinstance(node, dict) and "value" in node) {
            node = node["value"]
        }
        
        # Default to the node itself if not a dict or no concept
        token_str = str(node)
        
        if (isinstance(node, dict)) {
            # Check if it has a concept to realize
            if ("concept_key" in node) {
                concept_id = node["concept_key"]
                # Lookup lemma
                entry = lex.lookup_lemma(concept_id, lang)
                
                if (entry != None) {
                    lemma = entry["lemma"]
                    pos = entry["pos"]
                    
                    # Apply Morphology based on POS and features
                    features = {}
                    if ("features" in node) {
                        features = node["features"]
                    }
                    
                    if (pos == "verb") {
                        # Verb Conjugation
                        tense = "past" # default
                        if ("tense" in features) { tense = features["tense"] }
                        
                        person = "3ms" # default
                        if ("person" in features) { person = features["person"] }
                        
                        if (lang == "arabic" or lang == "ar") {
                            token_str = morph.conjugate_arabic_verb(lemma, tense, person)
                        }
                        else {
                            # English needs person mapping (3ms -> 3s)
                            en_person = "3s"
                            if (person == "1s") { en_person = "1s" }
                            token_str = morph.conjugate_english_verb(lemma, tense, en_person)
                        }
                    }
                    elif (pos == "noun") {
                        # Noun Declension / Pluralization
                        if (lang == "arabic" or lang == "ar") {
                            definiteness = "indef"
                            if ("definiteness" in features) { definiteness = features["definiteness"] }
                            token_str = morph.decline_arabic_noun(lemma, definiteness)
                        }
                        else {
                            number = "singular"
                            if ("number" in features) { number = features["number"] }
                            if (number == "plural") {
                                token_str = morph.pluralize_english_noun(lemma)
                            }
                            else {
                                token_str = lemma
                            }
                            
                            # English definite article
                            if ("definiteness" in features and features["definiteness"] == "def") {
                                token_str = "the " + token_str
                            }
                        }
                    }
                    else {
                        token_str = lemma
                    }
                }
                else {
                    # Concept not found, fallback to concept name
                    token_str = "[" + concept_id + "]"
                }
            }
            elif ("symbol" in node) {
                token_str = node["symbol"]
            }
        }
        elif (isinstance(node, str)) {
            # Handle symbolic connectors
            if (node == "TEMPORAL_NEXT") {
                token_str = "then"
                if (lang == "arabic" or lang == "ar") { token_str = "ثم" }
            }
            elif (node == "TEMPORAL_BEFORE") {
                token_str = "before"
                if (lang == "arabic" or lang == "ar") { token_str = "قبل" }
            }
            elif (node == "TEMPORAL_AFTER") {
                token_str = "after"
                if (lang == "arabic" or lang == "ar") { token_str = "بعد" }
            }
            elif (node == "CAUSE_EFFECT_LINK") {
                token_str = "leads to"
                if (lang == "arabic" or lang == "ar") { token_str = "يؤدي إلى" }
            }
        }
        
        surface_tokens.append(token_str)
    }

    return {
        "realization_type": "SurfaceRealization",
        "sentence_type": plan["sentence_type"],
        "lang": plan["lang"],
        "register": register,
        "tokens": surface_tokens,
        "modifiers": plan["modifiers"],
        "source": "SurfacePlan"
    }
}


# Realize from a SentenceTree
def realize_from_sentence_tree(tree, register):
{
    if (register == None) {
        register = "neutral"
    }

    plan = {
        "plan_type": "SurfacePlan",
        "sentence_type": tree["sentence_type"],
        "lang": tree["lang_hint"],
        "sequence": tree["linearization"],
        "modifiers": tree["modifiers"]
    }
    return realize_from_surface_plan(plan, register)
}


# Generic entry point
def realize_any(struct, register):
{
    if (register == None) {
        register = "neutral"
    }
    if ("tree_type" in struct) {
        return realize_from_sentence_tree(struct, register)
    }
    elif ("plan_type" in struct) {
        return realize_from_surface_plan(struct, register)
    }
    else {
    
        return {
            "realization_type": "SurfaceRealization",
            "sentence_type": struct.get("sentence_type", "Unknown"),
            "lang": "abstract",
            "register": register,
            "tokens": [],
            "modifiers": {},
            "raw": struct
        }
    }
}


# Convert to token strings
def realization_to_token_strings(realization):
{
    toks = []
    seq = realization["tokens"]
    for i in (range(len(seq))) {
        tok = seq[i]
        if (isinstance(tok, dict) and "symbol" in tok) {
            toks.append(tok["symbol"])
        }
        elif (isinstance(tok, str)) {
            toks.append(tok)
        }
        else {
        
            toks.append(str(tok))
        }
    }
    return toks
}


# Convert to text
def realization_to_text(realization):
{
    toks = realization_to_token_strings(realization)
    sep = " "
    return sep.join(toks)
}


# Build LM example
def build_conceptual_lm_example(conceptual_trace, blueprint_roles, stree, register):
{
    if (register == None) {
        register = "neutral"
    }

    surface = realize_from_sentence_tree(stree, register)
    text = realization_to_text(surface)
    return {
        "conceptual_trace": conceptual_trace,
        "blueprint_roles": blueprint_roles,
        "sentence_tree": stree,
        "surface": surface,
        "text": text
    }
}


# Build training data from program output
def build_lm_training_data(program_output, language):
{
    if (language == None) {
        language = "arabic"
    }

    examples = []
    full_text_parts = []

    # Extract circuits from program output
    if ("circuits" in program_output) {
        circuits = program_output["circuits"]
        for i in (range(len(circuits))) {
            circuit = circuits[i]

            # Generate text for this circuit
            text = _circuit_to_text(circuit, language)
            full_text_parts.append(text)

            # Create a training example from circuit
            example = {
                "circuit_type": circuit.get("circuit_type", "unknown"),
                "language": language,
                "text": text,
                "index": i
            }
            examples.append(example)
        }
    }

    # Join all texts
    sep = " "
    if (language == "arabic") {
        sep = "، "
    }
    else {
    
        sep = ", "
    }
    full_text = sep.join(full_text_parts)

    return {
        "training_examples": examples,
        "full_text": full_text,
        "count": len(examples),
        "language": language
    }
}


# Helper: Convert circuit to text
    import ai.conceptual_surface_planner as planner

# --- Circuit Realization Functions ---

def realize_action_state_circuit(circuit, lang="abstract"):
{
    # Map circuit fields to sentence roles
    sent = {
        "type": "ActionSentence",
        "subject": {"concept_key": "entity_" + circuit["entity"]},
        "predicate": {"concept_key": "action_" + circuit["action"]},
        "object": {"concept_key": "state_" + circuit["state"]}, # Simplified
        "intensity": circuit.get("strength", 0.5),
        "context": "neutral"
    }
    
    # Plan surface structure
    plan = planner.plan_action_sentence(sent, lang)
    
    # Realize to tokens
    return realize_from_surface_plan(plan, "neutral")
}

def realize_causal_circuit(circuit, lang="abstract"):
{
    # Causal: Cause -> Effect
    sent = {
        "type": "CausalSentence",
        "cause_event": {"concept_key": "event_" + circuit["cause_event"]},
        "effect_event": {"concept_key": "event_" + circuit["effect_event"]},
        "strength": circuit.get("strength", 0.8),
        "probability": circuit.get("probability", 1.0),
        "context": circuit.get("context", "neutral")
    }
    
    plan = planner.plan_causal_sentence(sent, lang)
    return realize_from_surface_plan(plan, "neutral")
}

def realize_temporal_circuit(circuit, lang="abstract"):
{
    # Temporal: Event1 -> Event2 ...
    
    # Handle both simple (2 events) and multi-event circuits
    events = []
    relations = []
    
    if ("events" in circuit):
        # Multi-event
        raw_events = circuit["events"]
        for e in (raw_events) {
            events.append({"concept_key": "event_" + e})
        }
        relations = circuit["relations"]
    else:
        # Simple 2-event
        events.append({"concept_key": "event_" + circuit["event1"]})
        events.append({"concept_key": "event_" + circuit["event2"]})
        relations.append(circuit["relation"])
        
    sent = {
        "type": "TemporalSentence",
        "events": events,
        "relations": relations,
        "context": circuit.get("context", "neutral")
    }
    
    plan = planner.plan_temporal_sentence(sent, lang)
    return realize_from_surface_plan(plan, "neutral")
}

def realize_comparison_circuit(circuit, lang="abstract"):
{
    # Comparison: Entity1 vs Entity2
    sent = {
        "type": "ComparisonSentence",
        "entity1": {"concept_key": "entity_" + circuit["entity1"]},
        "entity2": {"concept_key": "entity_" + circuit["entity2"]},
        "axis": {"concept_key": "axis_" + circuit["axis"]},
        "relation": circuit["relation"], # better/worse
        "degree": circuit.get("degree", 1.0)
    }
    
    plan = planner.plan_comparison_sentence(sent, lang)
    return realize_from_surface_plan(plan, "neutral")
}

def realize_uncertainty_circuit(circuit, lang="abstract"):
{
    # Uncertainty: Cause -> Effect (Uncertain)
    sent = {
        "type": "UncertaintySentence",
        "content": {
            "cause": {"concept_key": "event_" + circuit["cause_event"]},
            "effect": {"concept_key": "event_" + circuit["effect_event"]}
        },
        "degree": circuit.get("probability", 0.5)
    }
    
    plan = planner.plan_uncertainty_sentence(sent, lang)
    return realize_from_surface_plan(plan, "neutral")
}


# Helper: Convert circuit to text (Updated to use realization)
def _circuit_to_text(circuit, language):
{
    circuit_type = circuit.get("circuit_type", "unknown")
    
    realization = None
    
    if (circuit_type == "action_state_eval") {
        realization = realize_action_state_circuit(circuit, language)
    }
    elif (circuit_type == "causal_link") {
        realization = realize_causal_circuit(circuit, language)
    }
    elif (circuit_type == "temporal_sequence" or circuit_type == "multi_event_temporal_sequence") {
        realization = realize_temporal_circuit(circuit, language)
    }
    elif (circuit_type == "enhanced_comparison") {
        realization = realize_comparison_circuit(circuit, language)
    }
    elif (circuit_type == "uncertain_cause_effect") {
        realization = realize_uncertainty_circuit(circuit, language)
    }
    
    if (realization != None) {
        return realization_to_text(realization)
    }
    
    # Fallback for unknown types
    if (language == "arabic") {
        return "دائرة مفاهيمية: " + circuit_type
    }
    return "conceptual circuit: " + circuit_type
}


# Convert conceptual trace to natural text
def trace_to_natural_text(trace, language):
{
    if (language == None) {
        language = "arabic"
    }

    # Extract key information from trace
    entities = trace.get("entities", [])
    events = trace.get("events", [])
    transforms = trace.get("transforms", [])

    # Generate natural text based on trace content
    parts = []

    if (language == "arabic") {
        # Arabic text generation
        if (len(entities) > 0) {
            parts.append("الكيانات: " + str(len(entities)))
        }
        if (len(events) > 0) {
            parts.append("الأحداث: " + str(len(events)))
        }
        if (len(transforms) > 0) {
            parts.append("التحولات: " + str(len(transforms)))
        }

        if (len(parts) == 0) {
            return "أثر مفاهيمي"
        }

        sep = "، "
        return sep.join(parts)
    }
    else {
    
        # English text generation
        if (len(entities) > 0) {
            parts.append("entities: " + str(len(entities)))
        }
        if (len(events) > 0) {
            parts.append("events: " + str(len(events)))
        }
        if (len(transforms) > 0) {
            parts.append("transforms: " + str(len(transforms)))
        }

        if (len(parts) == 0) {
            return "conceptual trace"
        }

        sep = ", "
        return sep.join(parts)
    }
}
