# درس تعليمي موسّع: المترادفات/التشابه في بيان

يوضح هذا الدرس كيف تُصرِّح عن علاقات مترادفة/متقاربة بصياغة لغوية أصلية مثل:

- أسد(غضنفر:0.8، هيضم:0.5)
- روح(نفس:0.9، ذات:0.5)
- ذهب(راح:0.8، انطلق:0.6، سار:0.7)

وكيف تستعلم عنها بمنطق hybrid عبر حقائق `similar/5` وقواعد `close/3` و`close/4` من وحدة `bayan.core.similarity`.

## 1) قبل أن تبدأ
- التصريح بصيغة `Head(term:score, ...)` يولِّد داخليًا حقائق منطقية متناظرة:
  - `similar(Head, Term, Score, "syn", "lexicon")`
  - و"العكس" تلقائيًا: `similar(Term, Head, Score, "syn", "lexicon")`
- للاستفادة من قواعد العتبة الافتراضية `sim_threshold/2` والاستعلام المختصر `close/3` و`close/4`، استورد وحدة التشابه ثم انسخ تعريفاتها إلى محركك المنطقي الحالي.

## 2) مثال كامل خطوة بخطوة

أولًا: صرّح عن المترادفات في المستوى الأعلى (خارج hybrid) بصيغة السكر النحوي:

```bayan
أسد(غضنفر:0.8, هيضم:0.5)
روح(نفس:0.9, ذات:0.5)
ذهب(راح:0.8, انطلق:0.6, سار:0.7)
```

ثانيًا: داخل كتلة hybrid، استورد الوحدة وفعّل قواعدها ثم نفّذ استعلامات متنوعة:

```bayan
hybrid {
  # 1) استيراد الوحدة وتحميل قواعد التشابه والعتبات إلى المحرك المنطقي الحالي
  import bayan.core.similarity as sim
  sim.load_selective(logical, ["similarity"])  # يحمّل: similar/5, sim_threshold/2, close/3, close/4, synonym/3

  # 2) الاستعلام المباشر عن درجة التشابه المصرَّح بها
  query similar("أسد", "غضنفر", ?S, "syn", "lexicon").   # يجب أن يعيد S = 0.8

  # 3) الاستعلام المختصر بالعتبة الافتراضية Kind="syn" (افتراضيها 0.7)
  query close("أسد", "غضنفر", "syn").                  # True (0.8 ≥ 0.7)
  query close("أسد", "هيضم", "syn").                    # False (0.5 < 0.7)

  # 4) الاستعلام بعتبة مخصّصة (close/4): Tau = 0.6
  query close("أسد", "هيضم", 0.6, "syn").               # True (0.5 < 0.6 → False) — تصحيح: False

  # 5) إيجاد جميع المترادفات الأقرب من العتبة الافتراضية
  query close("أسد", ?كلمة, "syn").                      # يعيد كل ?كلمة حيث score ≥ 0.7 (مثلاً: غضنفر)

  # 6) بناء مجموعة مترادفات برمجياً (من قاموس/سلسلة/قائمة)
  sim.synset("ذهب", {"راح":0.8, "انطلق":0.6, "سار":0.7}, default=0.7)
  query close("ذهب", ?مرادف, "syn").                      # يتضمن: راح، سار (≥ 0.7)؛ و"انطلق" أقل من 0.7 → False

  # 7) أمثلة متعددة المجالات (غير معجمية) باستخدام assert_similar
  sim.assert_similar("H2O", "Water", 1.0, kind="alias", domain="chem")
  sim.assert_similar("متر", "100 سم", 1.0, kind="approx_eq", domain="physics")
  query close("H2O", "Water", "alias").                   # True (≥ 0.7 الافتراضية لـ alias)
}
```

ملاحظات:
- داخل hybrid يُستحسن إنهاء التصريحات المنطقية بنقطة `.` مثل الحقائق.
- `close/3` يستخدم عتبة النوع (`sim_threshold/2`). افتراضيًا: `"syn" → 0.7` و`"alias" → 0.7` (قابلة للتوسعة في الوحدة).
- لا حاجة لتكرار الاتجاهين؛ السكر يولّد التشابهين (تماثل) تلقائيًا.

## 3) الطباعة والتحقق البراغماتي
يمكنك استخدام `print(...)` للتحقق السريع بوصفه تعبيرًا منطقيًا يعيد True/False عند وجود حلول:

```bayan
hybrid {
  import bayan.core.similarity as sim
  sim.load_selective(logical, ["similarity"])

  # True/False حسب وجود حل لِلـ close/3 أو close/4
  print(close("أسد", "غضنفر", "syn"))     # True
  print(close("أسد", "هيضم", "syn"))       # False
  print(close("أسد", "هيضم", 0.4, "syn"))  # True (0.5 ≥ 0.4)
}
```

## 4) أنماط إدخال مرنة عبر synset
`sim.synset(head, items, default=0.7, kind="syn", domain="lexicon")` تقبل:
- قاموس: `{"مرادف":درجة, ...}`
- سلسلة: `"مرادف1:0.8, مرادف2:0.6, مرادف3"` (بدون درجة → تُستخدم قيمة default)
- قائمة: `[("اسم", 0.8), ("آخر", 0.6), "ثالث"]`

أمثلة إضافية:

```bayan
hybrid {
  import bayan.core.similarity as sim
  sim.load_selective(logical, ["similarity"])

  sim.synset("طالب", "تلميذ:0.8, دارس:0.6, متعلم")  # "متعلم" يأخذ default=0.7
  query close("طالب", ?Y, "syn").                     # يعيد: تلميذ، متعلم
}
```

## 5) أخطاء شائعة وكيفية تفاديها
- نسيان تحميل قواعد الوحدة إلى محركك الحالي: استخدم `sim.load_selective(logical, ["similarity"])` قبل الاستعلام بـ `close`.
- درجة غير رقمية: يجب أن تكون `score` عددية؛ وإلا سترى خطأ وقت التنفيذ.
- الالتباس بين الحقائق المنطقية والتصريحات السكرية: داخل hybrid، اختم بنقطة `.`؛ في المستوى الأعلى لا حاجة لذلك.
- توقع تصفية حسب "المجال" Domain داخل `close/3`: الصيغة الحالية تتجاهل الـ Domain عمدًا وتُرشّح حسب `Kind` فقط. إن أردت فصلًا بحسب المجال، أضف قاعدة مشتقة مخصّصة.

## 6) كيف أوسّع الأنواع والمجالات؟
- للأنواع الإضافية (Kind)، مثل `approx_eq`, `pathway`, `alias`… يمكنك استعمال `sim.assert_similar` و/أو تحديث عتباتها عبر حقائق `sim_threshold/2` في وحدة التشابه (أو نسخة مخصّصة).
- للمجالات (Domain) مثل `chem`, `physics`, `psychology`… استعمل معاملات `domain` في `assert_similar/synset`؛ قواعد `close` الحالية لا تُقيد على المجال، ويمكنك إضافة قواعد بديلة إن أردت ذلك.

> للمزيد من التفاصيل النحوية: راجع المرجع الشامل في `docs/reference.md` قسم "تصريح المترادفات".

